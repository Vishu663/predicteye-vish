{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/wire_protocol/constants.ts"],"sourcesContent":["export const MIN_SUPPORTED_SERVER_VERSION = '4.2';\nexport const MAX_SUPPORTED_SERVER_VERSION = '8.0';\nexport const MIN_SUPPORTED_WIRE_VERSION = 8;\nexport const MAX_SUPPORTED_WIRE_VERSION = 25;\nexport const MIN_SUPPORTED_QE_WIRE_VERSION = 21;\nexport const MIN_SUPPORTED_QE_SERVER_VERSION = '7.0';\nexport const OP_REPLY = 1;\nexport const OP_UPDATE = 2001;\nexport const OP_INSERT = 2002;\nexport const OP_QUERY = 2004;\nexport const OP_DELETE = 2006;\nexport const OP_COMPRESSED = 2012;\nexport const OP_MSG = 2013;\n"],"names":[],"mappings":";;;;;AAAa,QAAA,4BAA4B,GAAG;AAC/B,QAAA,4BAA4B,GAAG;AAC/B,QAAA,0BAA0B,GAAG;AAC7B,QAAA,0BAA0B,GAAG;AAC7B,QAAA,6BAA6B,GAAG;AAChC,QAAA,+BAA+B,GAAG;AAClC,QAAA,QAAQ,GAAG;AACX,QAAA,SAAS,GAAG;AACZ,QAAA,SAAS,GAAG;AACZ,QAAA,QAAQ,GAAG;AACX,QAAA,SAAS,GAAG;AACZ,QAAA,aAAa,GAAG;AAChB,QAAA,MAAM,GAAG"}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/wire_protocol/on_demand/document.ts"],"sourcesContent":["import {\n  Binary,\n  type BSONElement,\n  BSONError,\n  BSONType,\n  deserialize,\n  type DeserializeOptions,\n  getBigInt64LE,\n  getFloat64LE,\n  getInt32LE,\n  ObjectId,\n  parseToElementsToArray,\n  Timestamp,\n  toUTF8\n} from '../../../bson';\n\n// eslint-disable-next-line no-restricted-syntax\nconst enum BSONElementOffset {\n  type = 0,\n  nameOffset = 1,\n  nameLength = 2,\n  offset = 3,\n  length = 4\n}\n\n/** @internal */\nexport type JSTypeOf = {\n  [BSONType.null]: null;\n  [BSONType.undefined]: null;\n  [BSONType.double]: number;\n  [BSONType.int]: number;\n  [BSONType.long]: bigint;\n  [BSONType.timestamp]: Timestamp;\n  [BSONType.binData]: Binary;\n  [BSONType.bool]: boolean;\n  [BSONType.objectId]: ObjectId;\n  [BSONType.string]: string;\n  [BSONType.date]: Date;\n  [BSONType.object]: OnDemandDocument;\n  [BSONType.array]: OnDemandDocument;\n};\n\n/** @internal */\ntype CachedBSONElement = { element: BSONElement; value: any | undefined };\n\n/**\n * @internal\n *\n * Options for `OnDemandDocument.toObject()`. Validation is required to ensure\n * that callers provide utf8 validation options. */\nexport type OnDemandDocumentDeserializeOptions = Omit<DeserializeOptions, 'validation'> &\n  Required<Pick<DeserializeOptions, 'validation'>>;\n\n/** @internal */\nexport class OnDemandDocument {\n  /**\n   * Maps JS strings to elements and jsValues for speeding up subsequent lookups.\n   * - If `false` then name does not exist in the BSON document\n   * - If `CachedBSONElement` instance name exists\n   * - If `cache[name].value == null` jsValue has not yet been parsed\n   *   - Null/Undefined values do not get cached because they are zero-length values.\n   */\n  private readonly cache: Record<string, CachedBSONElement | false | undefined> =\n    Object.create(null);\n  /** Caches the index of elements that have been named */\n  private readonly indexFound: Record<number, boolean> = Object.create(null);\n\n  /** All bson elements in this document */\n  private readonly elements: ReadonlyArray<BSONElement>;\n\n  constructor(\n    /** BSON bytes, this document begins at offset */\n    protected readonly bson: Uint8Array,\n    /** The start of the document */\n    private readonly offset = 0,\n    /** If this is an embedded document, indicates if this was a BSON array */\n    public readonly isArray = false,\n    /** If elements was already calculated */\n    elements?: BSONElement[]\n  ) {\n    this.elements = elements ?? parseToElementsToArray(this.bson, offset);\n  }\n\n  /** Only supports basic latin strings */\n  private isElementName(name: string, element: BSONElement): boolean {\n    const nameLength = element[BSONElementOffset.nameLength];\n    const nameOffset = element[BSONElementOffset.nameOffset];\n\n    if (name.length !== nameLength) return false;\n\n    const nameEnd = nameOffset + nameLength;\n    for (\n      let byteIndex = nameOffset, charIndex = 0;\n      charIndex < name.length && byteIndex < nameEnd;\n      charIndex++, byteIndex++\n    ) {\n      if (this.bson[byteIndex] !== name.charCodeAt(charIndex)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Seeks into the elements array for an element matching the given name.\n   *\n   * @remarks\n   * Caching:\n   * - Caches the existence of a property making subsequent look ups for non-existent properties return immediately\n   * - Caches names mapped to elements to avoid reiterating the array and comparing the name again\n   * - Caches the index at which an element has been found to prevent rechecking against elements already determined to belong to another name\n   *\n   * @param name - a basic latin string name of a BSON element\n   * @returns\n   */\n  private getElement(name: string | number): CachedBSONElement | null {\n    const cachedElement = this.cache[name];\n    if (cachedElement === false) return null;\n\n    if (cachedElement != null) {\n      return cachedElement;\n    }\n\n    if (typeof name === 'number') {\n      if (this.isArray) {\n        if (name < this.elements.length) {\n          const element = this.elements[name];\n          const cachedElement = { element, value: undefined };\n          this.cache[name] = cachedElement;\n          this.indexFound[name] = true;\n          return cachedElement;\n        } else {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    }\n\n    for (let index = 0; index < this.elements.length; index++) {\n      const element = this.elements[index];\n\n      // skip this element if it has already been associated with a name\n      if (!(index in this.indexFound) && this.isElementName(name, element)) {\n        const cachedElement = { element, value: undefined };\n        this.cache[name] = cachedElement;\n        this.indexFound[index] = true;\n        return cachedElement;\n      }\n    }\n\n    this.cache[name] = false;\n    return null;\n  }\n\n  /**\n   * Translates BSON bytes into a javascript value. Checking `as` against the BSON element's type\n   * this methods returns the small subset of BSON types that the driver needs to function.\n   *\n   * @remarks\n   * - BSONType.null and BSONType.undefined always return null\n   * - If the type requested does not match this returns null\n   *\n   * @param element - The element to revive to a javascript value\n   * @param as - A type byte expected to be returned\n   */\n  private toJSValue<T extends keyof JSTypeOf>(element: BSONElement, as: T): JSTypeOf[T];\n  private toJSValue(element: BSONElement, as: keyof JSTypeOf): any {\n    const type = element[BSONElementOffset.type];\n    const offset = element[BSONElementOffset.offset];\n    const length = element[BSONElementOffset.length];\n\n    if (as !== type) {\n      return null;\n    }\n\n    switch (as) {\n      case BSONType.null:\n      case BSONType.undefined:\n        return null;\n      case BSONType.double:\n        return getFloat64LE(this.bson, offset);\n      case BSONType.int:\n        return getInt32LE(this.bson, offset);\n      case BSONType.long:\n        return getBigInt64LE(this.bson, offset);\n      case BSONType.bool:\n        return Boolean(this.bson[offset]);\n      case BSONType.objectId:\n        return new ObjectId(this.bson.subarray(offset, offset + 12));\n      case BSONType.timestamp:\n        return new Timestamp(getBigInt64LE(this.bson, offset));\n      case BSONType.string:\n        return toUTF8(this.bson, offset + 4, offset + length - 1, false);\n      case BSONType.binData: {\n        const totalBinarySize = getInt32LE(this.bson, offset);\n        const subType = this.bson[offset + 4];\n\n        if (subType === 2) {\n          const subType2BinarySize = getInt32LE(this.bson, offset + 1 + 4);\n          if (subType2BinarySize < 0)\n            throw new BSONError('Negative binary type element size found for subtype 0x02');\n          if (subType2BinarySize > totalBinarySize - 4)\n            throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n          if (subType2BinarySize < totalBinarySize - 4)\n            throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n          return new Binary(\n            this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize),\n            2\n          );\n        }\n\n        return new Binary(\n          this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize),\n          subType\n        );\n      }\n      case BSONType.date:\n        // Pretend this is correct.\n        return new Date(Number(getBigInt64LE(this.bson, offset)));\n\n      case BSONType.object:\n        return new OnDemandDocument(this.bson, offset);\n      case BSONType.array:\n        return new OnDemandDocument(this.bson, offset, true);\n\n      default:\n        throw new BSONError(`Unsupported BSON type: ${as}`);\n    }\n  }\n\n  /**\n   * Returns the number of elements in this BSON document\n   */\n  public size() {\n    return this.elements.length;\n  }\n\n  /**\n   * Checks for the existence of an element by name.\n   *\n   * @remarks\n   * Uses `getElement` with the expectation that will populate caches such that a `has` call\n   * followed by a `getElement` call will not repeat the cost paid by the first look up.\n   *\n   * @param name - element name\n   */\n  public has(name: string): boolean {\n    const cachedElement = this.cache[name];\n    if (cachedElement === false) return false;\n    if (cachedElement != null) return true;\n    return this.getElement(name) != null;\n  }\n\n  /**\n   * Turns BSON element with `name` into a javascript value.\n   *\n   * @typeParam T - must be one of the supported BSON types determined by `JSTypeOf` this will determine the return type of this function.\n   * @param name - the element name\n   * @param as - the bson type expected\n   * @param required - whether or not the element is expected to exist, if true this function will throw if it is not present\n   */\n  public get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: boolean\n  ): JSTypeOf[T] | null;\n\n  /** `required` will make `get` throw if name does not exist or is null/undefined */\n  public get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required: true\n  ): JSTypeOf[T];\n\n  public get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: boolean\n  ): JSTypeOf[T] | null {\n    const element = this.getElement(name);\n    if (element == null) {\n      if (required === true) {\n        throw new BSONError(`BSON element \"${name}\" is missing`);\n      } else {\n        return null;\n      }\n    }\n\n    if (element.value == null) {\n      const value = this.toJSValue(element.element, as);\n      if (value == null) {\n        if (required === true) {\n          throw new BSONError(`BSON element \"${name}\" is missing`);\n        } else {\n          return null;\n        }\n      }\n      // It is important to never store null\n      element.value = value;\n    }\n\n    return element.value;\n  }\n\n  /**\n   * Supports returning int, double, long, and bool as javascript numbers\n   *\n   * @remarks\n   * **NOTE:**\n   * - Use this _only_ when you believe the potential precision loss of an int64 is acceptable\n   * - This method does not cache the result as Longs or booleans would be stored incorrectly\n   *\n   * @param name - element name\n   * @param required - throws if name does not exist\n   */\n  public getNumber<const Req extends boolean = false>(\n    name: string,\n    required?: Req\n  ): Req extends true ? number : number | null;\n  public getNumber(name: string, required: boolean): number | null {\n    const maybeBool = this.get(name, BSONType.bool);\n    const bool = maybeBool == null ? null : maybeBool ? 1 : 0;\n\n    const maybeLong = this.get(name, BSONType.long);\n    const long = maybeLong == null ? null : Number(maybeLong);\n\n    const result = bool ?? long ?? this.get(name, BSONType.int) ?? this.get(name, BSONType.double);\n\n    if (required === true && result == null) {\n      throw new BSONError(`BSON element \"${name}\" is missing`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Deserialize this object, DOES NOT cache result so avoid multiple invocations\n   * @param options - BSON deserialization options\n   */\n  public toObject(options?: OnDemandDocumentDeserializeOptions): Record<string, any> {\n    return deserialize(this.bson, {\n      ...options,\n      index: this.offset,\n      allowObjectSmallerThanBufferSize: true\n    });\n  }\n\n  /** Returns this document's bytes only */\n  toBytes() {\n    const size = getInt32LE(this.bson, this.offset);\n    return this.bson.subarray(this.offset, this.offset + size);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/wire_protocol/responses.ts"],"sourcesContent":["import {\n  type BSONElement,\n  type BSONSerializeOptions,\n  BSONType,\n  type DeserializeOptions,\n  type Document,\n  Long,\n  parseToElementsToArray,\n  parseUtf8ValidationOption,\n  pluckBSONSerializeOptions,\n  serialize,\n  type Timestamp\n} from '../../bson';\nimport { MONGODB_ERROR_CODES, MongoUnexpectedServerResponseError } from '../../error';\nimport { type ClusterTime } from '../../sdam/common';\nimport { decorateDecryptionResult, ns } from '../../utils';\nimport {\n  type JSTypeOf,\n  OnDemandDocument,\n  type OnDemandDocumentDeserializeOptions\n} from './on_demand/document';\n\n// eslint-disable-next-line no-restricted-syntax\nconst enum BSONElementOffset {\n  type = 0,\n  nameOffset = 1,\n  nameLength = 2,\n  offset = 3,\n  length = 4\n}\n/**\n * Accepts a BSON payload and checks for na \"ok: 0\" element.\n * This utility is intended to prevent calling response class constructors\n * that expect the result to be a success and demand certain properties to exist.\n *\n * For example, a cursor response always expects a cursor embedded document.\n * In order to write the class such that the properties reflect that assertion (non-null)\n * we cannot invoke the subclass constructor if the BSON represents an error.\n *\n * @param bytes - BSON document returned from the server\n */\nexport function isErrorResponse(bson: Uint8Array, elements: BSONElement[]): boolean {\n  for (let eIdx = 0; eIdx < elements.length; eIdx++) {\n    const element = elements[eIdx];\n\n    if (element[BSONElementOffset.nameLength] === 2) {\n      const nameOffset = element[BSONElementOffset.nameOffset];\n\n      // 111 == \"o\", 107 == \"k\"\n      if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {\n        const valueOffset = element[BSONElementOffset.offset];\n        const valueLength = element[BSONElementOffset.length];\n\n        // If any byte in the length of the ok number (works for any type) is non zero,\n        // then it is considered \"ok: 1\"\n        for (let i = valueOffset; i < valueOffset + valueLength; i++) {\n          if (bson[i] !== 0x00) return false;\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return true;\n}\n\n/** @internal */\nexport type MongoDBResponseConstructor = {\n  new (bson: Uint8Array, offset?: number, isArray?: boolean): MongoDBResponse;\n  make(bson: Uint8Array): MongoDBResponse;\n};\n\n/** @internal */\nexport class MongoDBResponse extends OnDemandDocument {\n  // Wrap error thrown from BSON\n  public override get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: false\n  ): JSTypeOf[T] | null;\n  public override get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required: true\n  ): JSTypeOf[T];\n  public override get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: boolean\n  ): JSTypeOf[T] | null {\n    try {\n      return super.get(name, as, required);\n    } catch (cause) {\n      throw new MongoUnexpectedServerResponseError(cause.message, { cause });\n    }\n  }\n\n  static is(value: unknown): value is MongoDBResponse {\n    return value instanceof MongoDBResponse;\n  }\n\n  static make(bson: Uint8Array) {\n    const elements = parseToElementsToArray(bson, 0);\n    const isError = isErrorResponse(bson, elements);\n    return isError\n      ? new MongoDBResponse(bson, 0, false, elements)\n      : new this(bson, 0, false, elements);\n  }\n\n  // {ok:1}\n  static empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));\n\n  /**\n   * Returns true iff:\n   * - ok is 0 and the top-level code === 50\n   * - ok is 1 and the writeErrors array contains a code === 50\n   * - ok is 1 and the writeConcern object contains a code === 50\n   */\n  get isMaxTimeExpiredError() {\n    // {ok: 0, code: 50 ... }\n    const isTopLevel = this.ok === 0 && this.code === MONGODB_ERROR_CODES.MaxTimeMSExpired;\n    if (isTopLevel) return true;\n\n    if (this.ok === 0) return false;\n\n    // {ok: 1, writeConcernError: {code: 50 ... }}\n    const isWriteConcern =\n      this.get('writeConcernError', BSONType.object)?.getNumber('code') ===\n      MONGODB_ERROR_CODES.MaxTimeMSExpired;\n    if (isWriteConcern) return true;\n\n    const writeErrors = this.get('writeErrors', BSONType.array);\n    if (writeErrors?.size()) {\n      for (let i = 0; i < writeErrors.size(); i++) {\n        const isWriteError =\n          writeErrors.get(i, BSONType.object)?.getNumber('code') ===\n          MONGODB_ERROR_CODES.MaxTimeMSExpired;\n\n        // {ok: 1, writeErrors: [{code: 50 ... }]}\n        if (isWriteError) return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the\n   * contents of the document.\n   */\n  get recoveryToken(): Document | null {\n    return (\n      this.get('recoveryToken', BSONType.object)?.toObject({\n        promoteValues: false,\n        promoteLongs: false,\n        promoteBuffers: false,\n        validation: { utf8: true }\n      }) ?? null\n    );\n  }\n\n  /**\n   * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.\n   * For the distinct command the server adds a top-level atClusterTime field to the response.\n   * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.\n   */\n  public get atClusterTime(): Timestamp | null {\n    return (\n      this.get('cursor', BSONType.object)?.get('atClusterTime', BSONType.timestamp) ??\n      this.get('atClusterTime', BSONType.timestamp)\n    );\n  }\n\n  public get operationTime(): Timestamp | null {\n    return this.get('operationTime', BSONType.timestamp);\n  }\n\n  /** Normalizes whatever BSON value is \"ok\" to a JS number 1 or 0. */\n  public get ok(): 0 | 1 {\n    return this.getNumber('ok') ? 1 : 0;\n  }\n\n  public get $err(): string | null {\n    return this.get('$err', BSONType.string);\n  }\n\n  public get errmsg(): string | null {\n    return this.get('errmsg', BSONType.string);\n  }\n\n  public get code(): number | null {\n    return this.getNumber('code');\n  }\n\n  private clusterTime?: ClusterTime | null;\n  public get $clusterTime(): ClusterTime | null {\n    if (!('clusterTime' in this)) {\n      const clusterTimeDoc = this.get('$clusterTime', BSONType.object);\n      if (clusterTimeDoc == null) {\n        this.clusterTime = null;\n        return null;\n      }\n      const clusterTime = clusterTimeDoc.get('clusterTime', BSONType.timestamp, true);\n      const signature = clusterTimeDoc.get('signature', BSONType.object)?.toObject();\n      // @ts-expect-error: `signature` is incorrectly typed. It is public API.\n      this.clusterTime = { clusterTime, signature };\n    }\n    return this.clusterTime ?? null;\n  }\n\n  public override toObject(options?: BSONSerializeOptions): Record<string, any> {\n    const exactBSONOptions = {\n      ...pluckBSONSerializeOptions(options ?? {}),\n      validation: parseUtf8ValidationOption(options)\n    };\n    return super.toObject(exactBSONOptions);\n  }\n}\n\n/** @internal */\nexport class CursorResponse extends MongoDBResponse {\n  /**\n   * Devtools need to know which keys were encrypted before the driver automatically decrypted them.\n   * If decorating is enabled (`Symbol.for('@@mdb.decorateDecryptionResult')`), this field will be set,\n   * storing the original encrypted response from the server, so that we can build an object that has\n   * the list of BSON keys that were encrypted stored at a well known symbol: `Symbol.for('@@mdb.decryptedKeys')`.\n   */\n  encryptedResponse?: MongoDBResponse;\n  /**\n   * This supports a feature of the FindCursor.\n   * It is an optimization to avoid an extra getMore when the limit has been reached\n   */\n  static get emptyGetMore(): CursorResponse {\n    return new CursorResponse(serialize({ ok: 1, cursor: { id: 0n, nextBatch: [] } }));\n  }\n\n  static override is(value: unknown): value is CursorResponse {\n    return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;\n  }\n\n  private _batch: OnDemandDocument | null = null;\n  private iterated = 0;\n\n  get cursor() {\n    return this.get('cursor', BSONType.object, true);\n  }\n\n  public get id(): Long {\n    try {\n      return Long.fromBigInt(this.cursor.get('id', BSONType.long, true));\n    } catch (cause) {\n      throw new MongoUnexpectedServerResponseError(cause.message, { cause });\n    }\n  }\n\n  public get ns() {\n    const namespace = this.cursor.get('ns', BSONType.string);\n    if (namespace != null) return ns(namespace);\n    return null;\n  }\n\n  public get length() {\n    return Math.max(this.batchSize - this.iterated, 0);\n  }\n\n  private _encryptedBatch: OnDemandDocument | null = null;\n  get encryptedBatch() {\n    if (this.encryptedResponse == null) return null;\n    if (this._encryptedBatch != null) return this._encryptedBatch;\n\n    const cursor = this.encryptedResponse?.get('cursor', BSONType.object);\n    if (cursor?.has('firstBatch'))\n      this._encryptedBatch = cursor.get('firstBatch', BSONType.array, true);\n    else if (cursor?.has('nextBatch'))\n      this._encryptedBatch = cursor.get('nextBatch', BSONType.array, true);\n    else throw new MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n\n    return this._encryptedBatch;\n  }\n\n  private get batch() {\n    if (this._batch != null) return this._batch;\n    const cursor = this.cursor;\n    if (cursor.has('firstBatch')) this._batch = cursor.get('firstBatch', BSONType.array, true);\n    else if (cursor.has('nextBatch')) this._batch = cursor.get('nextBatch', BSONType.array, true);\n    else throw new MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n    return this._batch;\n  }\n\n  public get batchSize() {\n    return this.batch?.size();\n  }\n\n  public get postBatchResumeToken() {\n    return (\n      this.cursor.get('postBatchResumeToken', BSONType.object)?.toObject({\n        promoteValues: false,\n        promoteLongs: false,\n        promoteBuffers: false,\n        validation: { utf8: true }\n      }) ?? null\n    );\n  }\n\n  public shift(options: OnDemandDocumentDeserializeOptions): any {\n    if (this.iterated >= this.batchSize) {\n      return null;\n    }\n\n    const result = this.batch.get(this.iterated, BSONType.object, true) ?? null;\n    const encryptedResult = this.encryptedBatch?.get(this.iterated, BSONType.object, true) ?? null;\n\n    this.iterated += 1;\n\n    if (options?.raw) {\n      return result.toBytes();\n    } else {\n      const object = result.toObject(options);\n      if (encryptedResult) {\n        decorateDecryptionResult(object, encryptedResult.toObject(options), true);\n      }\n      return object;\n    }\n  }\n\n  public clear() {\n    this.iterated = this.batchSize;\n  }\n}\n\n/**\n * Explain responses have nothing to do with cursor responses\n * This class serves to temporarily avoid refactoring how cursors handle\n * explain responses which is to detect that the response is not cursor-like and return the explain\n * result as the \"first and only\" document in the \"batch\" and end the \"cursor\"\n */\nexport class ExplainedCursorResponse extends CursorResponse {\n  isExplain = true;\n\n  override get id(): Long {\n    return Long.fromBigInt(0n);\n  }\n\n  override get batchSize() {\n    return 0;\n  }\n\n  override get ns() {\n    return null;\n  }\n\n  _length = 1;\n  override get length(): number {\n    return this._length;\n  }\n\n  override shift(options?: DeserializeOptions) {\n    if (this._length === 0) return null;\n    this._length -= 1;\n    return this.toObject(options);\n  }\n}\n\n/**\n * Client bulk writes have some extra metadata at the top level that needs to be\n * included in the result returned to the user.\n */\nexport class ClientBulkWriteCursorResponse extends CursorResponse {\n  get insertedCount() {\n    return this.get('nInserted', BSONType.int, true);\n  }\n\n  get upsertedCount() {\n    return this.get('nUpserted', BSONType.int, true);\n  }\n\n  get matchedCount() {\n    return this.get('nMatched', BSONType.int, true);\n  }\n\n  get modifiedCount() {\n    return this.get('nModified', BSONType.int, true);\n  }\n\n  get deletedCount() {\n    return this.get('nDeleted', BSONType.int, true);\n  }\n\n  get writeConcernError() {\n    return this.get('writeConcernError', BSONType.object, false);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 536, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 540, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/auth_provider.ts"],"sourcesContent":["import type { Document } from '../../bson';\nimport { MongoRuntimeError } from '../../error';\nimport type { HandshakeDocument } from '../connect';\nimport type { Connection, ConnectionOptions } from '../connection';\nimport type { MongoCredentials } from './mongo_credentials';\n\n/**\n * Context used during authentication\n * @internal\n */\nexport class AuthContext {\n  /** The connection to authenticate */\n  connection: Connection;\n  /** The credentials to use for authentication */\n  credentials?: MongoCredentials;\n  /** If the context is for reauthentication. */\n  reauthenticating = false;\n  /** The options passed to the `connect` method */\n  options: ConnectionOptions;\n\n  /** A response from an initial auth attempt, only some mechanisms use this (e.g, SCRAM) */\n  response?: Document;\n  /** A random nonce generated for use in an authentication conversation */\n  nonce?: Buffer;\n\n  constructor(\n    connection: Connection,\n    credentials: MongoCredentials | undefined,\n    options: ConnectionOptions\n  ) {\n    this.connection = connection;\n    this.credentials = credentials;\n    this.options = options;\n  }\n}\n\n/**\n * Provider used during authentication.\n * @internal\n */\nexport abstract class AuthProvider {\n  /**\n   * Prepare the handshake document before the initial handshake.\n   *\n   * @param handshakeDoc - The document used for the initial handshake on a connection\n   * @param authContext - Context for authentication flow\n   */\n  async prepare(\n    handshakeDoc: HandshakeDocument,\n    _authContext: AuthContext\n  ): Promise<HandshakeDocument> {\n    return handshakeDoc;\n  }\n\n  /**\n   * Authenticate\n   *\n   * @param context - A shared context for authentication flow\n   */\n  abstract auth(context: AuthContext): Promise<void>;\n\n  /**\n   * Reauthenticate.\n   * @param context - The shared auth context.\n   */\n  async reauth(context: AuthContext): Promise<void> {\n    if (context.reauthenticating) {\n      throw new MongoRuntimeError('Reauthentication already in progress.');\n    }\n    try {\n      context.reauthenticating = true;\n      await this.auth(context);\n    } finally {\n      context.reauthenticating = false;\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAKA;;;IAIA,MAAa;IAeX,YACE,UAAsB,EACtB,WAAyC,EACzC,OAA0B,CAAA;QAb5B,4CAAA,GACA,IAAA,CAAA,gBAAgB,GAAG;QAcjB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,OAAO,GAAG;IACjB;;AAvBF,QAAA,WAAA,GAAA;AA0BA;;;IAIA,MAAsB;IACpB;;;;;QAMA,MAAM,QACJ,YAA+B,EAC/B,YAAyB,EAAA;QAEzB,OAAO;IACT;IASA;;;QAIA,MAAM,OAAO,OAAoB,EAAA;QAC/B,IAAI,QAAQ,gBAAgB,EAAE;YAC5B,MAAM,IAAI,QAAA,iBAAiB,CAAC;QAC9B;QACA,IAAI;YACF,QAAQ,gBAAgB,GAAG;YAC3B,MAAM,IAAI,CAAC,IAAI,CAAC;QAClB,SAAU;YACR,QAAQ,gBAAgB,GAAG;QAC7B;IACF;;AAnCF,QAAA,YAAA,GAAA"}},
    {"offset": {"line": 586, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 590, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/gssapi.ts"],"sourcesContent":["import * as dns from 'dns';\n\nimport { getKerberos, type Kerberos, type KerberosClient } from '../../deps';\nimport { MongoInvalidArgumentError, MongoMissingCredentialsError } from '../../error';\nimport { ns } from '../../utils';\nimport type { Connection } from '../connection';\nimport { type AuthContext, AuthProvider } from './auth_provider';\n\n/** @public */\nexport const GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n} as const);\n\n/** @public */\nexport type GSSAPICanonicalizationValue =\n  (typeof GSSAPICanonicalizationValue)[keyof typeof GSSAPICanonicalizationValue];\n\ntype MechanismProperties = {\n  CANONICALIZE_HOST_NAME?: GSSAPICanonicalizationValue;\n  SERVICE_HOST?: string;\n  SERVICE_NAME?: string;\n  SERVICE_REALM?: string;\n};\n\nasync function externalCommand(\n  connection: Connection,\n  command: ReturnType<typeof saslStart> | ReturnType<typeof saslContinue>\n): Promise<{ payload: string; conversationId: number }> {\n  const response = await connection.command(ns('$external.$cmd'), command);\n  return response as { payload: string; conversationId: number };\n}\n\nlet krb: Kerberos;\n\nexport class GSSAPI extends AuthProvider {\n  override async auth(authContext: AuthContext): Promise<void> {\n    const { connection, credentials } = authContext;\n    if (credentials == null) {\n      throw new MongoMissingCredentialsError('Credentials required for GSSAPI authentication');\n    }\n\n    const { username } = credentials;\n\n    const client = await makeKerberosClient(authContext);\n\n    const payload = await client.step('');\n\n    const saslStartResponse = await externalCommand(connection, saslStart(payload));\n\n    const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);\n\n    const saslContinueResponse = await externalCommand(\n      connection,\n      saslContinue(negotiatedPayload, saslStartResponse.conversationId)\n    );\n\n    const finalizePayload = await finalize(client, username, saslContinueResponse.payload);\n\n    await externalCommand(connection, {\n      saslContinue: 1,\n      conversationId: saslContinueResponse.conversationId,\n      payload: finalizePayload\n    });\n  }\n}\n\nasync function makeKerberosClient(authContext: AuthContext): Promise<KerberosClient> {\n  const { hostAddress } = authContext.options;\n  const { credentials } = authContext;\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    throw new MongoInvalidArgumentError(\n      'Connection must have host and port and credentials defined.'\n    );\n  }\n\n  loadKrb();\n  if ('kModuleError' in krb) {\n    throw krb['kModuleError'];\n  }\n  const { initializeClient } = krb;\n\n  const { username, password } = credentials;\n  const mechanismProperties = credentials.mechanismProperties as MechanismProperties;\n\n  const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n\n  const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);\n\n  const initOptions = {};\n  if (password != null) {\n    // TODO(NODE-5139): These do not match the typescript options in initializeClient\n    Object.assign(initOptions, { user: username, password: password });\n  }\n\n  const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n  let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n  if ('SERVICE_REALM' in mechanismProperties) {\n    spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n  }\n\n  return await initializeClient(spn, initOptions);\n}\n\nfunction saslStart(payload: string) {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  } as const;\n}\n\nfunction saslContinue(payload: string, conversationId: number) {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  } as const;\n}\n\nasync function negotiate(\n  client: KerberosClient,\n  retries: number,\n  payload: string\n): Promise<string> {\n  try {\n    const response = await client.step(payload);\n    return response || '';\n  } catch (error) {\n    if (retries === 0) {\n      // Retries exhausted, raise error\n      throw error;\n    }\n    // Adjust number of retries and call step again\n    return await negotiate(client, retries - 1, payload);\n  }\n}\n\nasync function finalize(client: KerberosClient, user: string, payload: string): Promise<string> {\n  // GSS Client Unwrap\n  const response = await client.unwrap(payload);\n  return await client.wrap(response || '', { user });\n}\n\nexport async function performGSSAPICanonicalizeHostName(\n  host: string,\n  mechanismProperties: MechanismProperties\n): Promise<string> {\n  const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n  if (!mode || mode === GSSAPICanonicalizationValue.none) {\n    return host;\n  }\n\n  // If forward and reverse or true\n  if (\n    mode === GSSAPICanonicalizationValue.on ||\n    mode === GSSAPICanonicalizationValue.forwardAndReverse\n  ) {\n    // Perform the lookup of the ip address.\n    const { address } = await dns.promises.lookup(host);\n\n    try {\n      // Perform a reverse ptr lookup on the ip address.\n      const results = await dns.promises.resolvePtr(address);\n      // If the ptr did not error but had no results, return the host.\n      return results.length > 0 ? results[0] : host;\n    } catch {\n      // This can error as ptr records may not exist for all ips. In this case\n      // fallback to a cname lookup as dns.lookup() does not return the\n      // cname.\n      return await resolveCname(host);\n    }\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    return await resolveCname(host);\n  }\n}\n\nexport async function resolveCname(host: string): Promise<string> {\n  // Attempt to resolve the host name\n  try {\n    const results = await dns.promises.resolveCname(host);\n    // Get the first resolved host id\n    return results.length > 0 ? results[0] : host;\n  } catch {\n    return host;\n  }\n}\n\n/**\n * Load the Kerberos library.\n */\nfunction loadKrb() {\n  if (!krb) {\n    krb = getKerberos();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 743, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 747, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/providers.ts"],"sourcesContent":["/** @public */\nexport const AuthMechanism = Object.freeze({\n  MONGODB_AWS: 'MONGODB-AWS',\n  MONGODB_CR: 'MONGODB-CR',\n  MONGODB_DEFAULT: 'DEFAULT',\n  MONGODB_GSSAPI: 'GSSAPI',\n  MONGODB_PLAIN: 'PLAIN',\n  MONGODB_SCRAM_SHA1: 'SCRAM-SHA-1',\n  MONGODB_SCRAM_SHA256: 'SCRAM-SHA-256',\n  MONGODB_X509: 'MONGODB-X509',\n  MONGODB_OIDC: 'MONGODB-OIDC'\n} as const);\n\n/** @public */\nexport type AuthMechanism = (typeof AuthMechanism)[keyof typeof AuthMechanism];\n\n/** @internal */\nexport const AUTH_MECHS_AUTH_SRC_EXTERNAL = new Set<AuthMechanism>([\n  AuthMechanism.MONGODB_GSSAPI,\n  AuthMechanism.MONGODB_AWS,\n  AuthMechanism.MONGODB_OIDC,\n  AuthMechanism.MONGODB_X509\n]);\n"],"names":[],"mappings":";;;;;AAAA,YAAA,GACa,QAAA,aAAa,GAAG,OAAO,MAAM,CAAC;IACzC,aAAa;IACb,YAAY;IACZ,iBAAiB;IACjB,gBAAgB;IAChB,eAAe;IACf,oBAAoB;IACpB,sBAAsB;IACtB,cAAc;IACd,cAAc;;AAMhB,cAAA,GACa,QAAA,4BAA4B,GAAG,IAAI,IAAmB;IACjE,QAAA,aAAa,CAAC,cAAc;IAC5B,QAAA,aAAa,CAAC,WAAW;IACzB,QAAA,aAAa,CAAC,YAAY;IAC1B,QAAA,aAAa,CAAC,YAAY;CAC3B"}},
    {"offset": {"line": 769, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 773, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongo_credentials.ts"],"sourcesContent":["// Resolves the default auth mechanism according to\n// Resolves the default auth mechanism according to\nimport type { Document } from '../../bson';\nimport {\n  MongoAPIError,\n  MongoInvalidArgumentError,\n  MongoMissingCredentialsError\n} from '../../error';\nimport type { AWSCredentialProvider } from './aws_temporary_credentials';\nimport { GSSAPICanonicalizationValue } from './gssapi';\nimport type { OIDCCallbackFunction } from './mongodb_oidc';\nimport { AUTH_MECHS_AUTH_SRC_EXTERNAL, AuthMechanism } from './providers';\n\n/**\n * @see https://github.com/mongodb/specifications/blob/master/source/auth/auth.md\n */\nfunction getDefaultAuthMechanism(hello: Document | null): AuthMechanism {\n  if (hello) {\n    // If hello contains saslSupportedMechs, use scram-sha-256\n    // if it is available, else scram-sha-1\n    if (Array.isArray(hello.saslSupportedMechs)) {\n      return hello.saslSupportedMechs.includes(AuthMechanism.MONGODB_SCRAM_SHA256)\n        ? AuthMechanism.MONGODB_SCRAM_SHA256\n        : AuthMechanism.MONGODB_SCRAM_SHA1;\n    }\n  }\n\n  // Default auth mechanism for 4.0 and higher.\n  return AuthMechanism.MONGODB_SCRAM_SHA256;\n}\n\nconst ALLOWED_ENVIRONMENT_NAMES: AuthMechanismProperties['ENVIRONMENT'][] = [\n  'test',\n  'azure',\n  'gcp',\n  'k8s'\n];\nconst ALLOWED_HOSTS_ERROR = 'Auth mechanism property ALLOWED_HOSTS must be an array of strings.';\n\n/** @internal */\nexport const DEFAULT_ALLOWED_HOSTS = [\n  '*.mongodb.net',\n  '*.mongodb-qa.net',\n  '*.mongodb-dev.net',\n  '*.mongodbgov.net',\n  'localhost',\n  '127.0.0.1',\n  '::1'\n];\n\n/** Error for when the token audience is missing in the environment. */\nconst TOKEN_RESOURCE_MISSING_ERROR =\n  'TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure or gcp.';\n\n/** @public */\nexport interface AuthMechanismProperties extends Document {\n  SERVICE_HOST?: string;\n  SERVICE_NAME?: string;\n  SERVICE_REALM?: string;\n  CANONICALIZE_HOST_NAME?: GSSAPICanonicalizationValue;\n  AWS_SESSION_TOKEN?: string;\n  /** A user provided OIDC machine callback function. */\n  OIDC_CALLBACK?: OIDCCallbackFunction;\n  /** A user provided OIDC human interacted callback function. */\n  OIDC_HUMAN_CALLBACK?: OIDCCallbackFunction;\n  /** The OIDC environment. Note that 'test' is for internal use only. */\n  ENVIRONMENT?: 'test' | 'azure' | 'gcp' | 'k8s';\n  /** Allowed hosts that OIDC auth can connect to. */\n  ALLOWED_HOSTS?: string[];\n  /** The resource token for OIDC auth in Azure and GCP. */\n  TOKEN_RESOURCE?: string;\n  /**\n   * A custom AWS credential provider to use. An example using the AWS SDK default provider chain:\n   *\n   * ```ts\n   * const client = new MongoClient(process.env.MONGODB_URI, {\n   *   authMechanismProperties: {\n   *     AWS_CREDENTIAL_PROVIDER: fromNodeProviderChain()\n   *   }\n   * });\n   * ```\n   *\n   * Using a custom function that returns AWS credentials:\n   *\n   * ```ts\n   * const client = new MongoClient(process.env.MONGODB_URI, {\n   *   authMechanismProperties: {\n   *     AWS_CREDENTIAL_PROVIDER: async () => {\n   *       return {\n   *         accessKeyId: process.env.ACCESS_KEY_ID,\n   *         secretAccessKey: process.env.SECRET_ACCESS_KEY\n   *       }\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  AWS_CREDENTIAL_PROVIDER?: AWSCredentialProvider;\n}\n\n/** @public */\nexport interface MongoCredentialsOptions {\n  username?: string;\n  password: string;\n  source: string;\n  db?: string;\n  mechanism?: AuthMechanism;\n  mechanismProperties: AuthMechanismProperties;\n}\n\n/**\n * A representation of the credentials used by MongoDB\n * @public\n */\nexport class MongoCredentials {\n  /** The username used for authentication */\n  readonly username: string;\n  /** The password used for authentication */\n  readonly password: string;\n  /** The database that the user should authenticate against */\n  readonly source: string;\n  /** The method used to authenticate */\n  readonly mechanism: AuthMechanism;\n  /** Special properties used by some types of auth mechanisms */\n  readonly mechanismProperties: AuthMechanismProperties;\n\n  constructor(options: MongoCredentialsOptions) {\n    this.username = options.username ?? '';\n    this.password = options.password;\n    this.source = options.source;\n    if (!this.source && options.db) {\n      this.source = options.db;\n    }\n    this.mechanism = options.mechanism || AuthMechanism.MONGODB_DEFAULT;\n    this.mechanismProperties = options.mechanismProperties || {};\n\n    if (this.mechanism.match(/MONGODB-AWS/i)) {\n      if (!this.username && process.env.AWS_ACCESS_KEY_ID) {\n        this.username = process.env.AWS_ACCESS_KEY_ID;\n      }\n\n      if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {\n        this.password = process.env.AWS_SECRET_ACCESS_KEY;\n      }\n\n      if (\n        this.mechanismProperties.AWS_SESSION_TOKEN == null &&\n        process.env.AWS_SESSION_TOKEN != null\n      ) {\n        this.mechanismProperties = {\n          ...this.mechanismProperties,\n          AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN\n        };\n      }\n    }\n\n    if (this.mechanism === AuthMechanism.MONGODB_OIDC && !this.mechanismProperties.ALLOWED_HOSTS) {\n      this.mechanismProperties = {\n        ...this.mechanismProperties,\n        ALLOWED_HOSTS: DEFAULT_ALLOWED_HOSTS\n      };\n    }\n\n    Object.freeze(this.mechanismProperties);\n    Object.freeze(this);\n  }\n\n  /** Determines if two MongoCredentials objects are equivalent */\n  equals(other: MongoCredentials): boolean {\n    return (\n      this.mechanism === other.mechanism &&\n      this.username === other.username &&\n      this.password === other.password &&\n      this.source === other.source\n    );\n  }\n\n  /**\n   * If the authentication mechanism is set to \"default\", resolves the authMechanism\n   * based on the server version and server supported sasl mechanisms.\n   *\n   * @param hello - A hello response from the server\n   */\n  resolveAuthMechanism(hello: Document | null): MongoCredentials {\n    // If the mechanism is not \"default\", then it does not need to be resolved\n    if (this.mechanism.match(/DEFAULT/i)) {\n      return new MongoCredentials({\n        username: this.username,\n        password: this.password,\n        source: this.source,\n        mechanism: getDefaultAuthMechanism(hello),\n        mechanismProperties: this.mechanismProperties\n      });\n    }\n\n    return this;\n  }\n\n  validate(): void {\n    if (\n      (this.mechanism === AuthMechanism.MONGODB_GSSAPI ||\n        this.mechanism === AuthMechanism.MONGODB_PLAIN ||\n        this.mechanism === AuthMechanism.MONGODB_SCRAM_SHA1 ||\n        this.mechanism === AuthMechanism.MONGODB_SCRAM_SHA256) &&\n      !this.username\n    ) {\n      throw new MongoMissingCredentialsError(`Username required for mechanism '${this.mechanism}'`);\n    }\n\n    if (this.mechanism === AuthMechanism.MONGODB_OIDC) {\n      if (\n        this.username &&\n        this.mechanismProperties.ENVIRONMENT &&\n        this.mechanismProperties.ENVIRONMENT !== 'azure'\n      ) {\n        throw new MongoInvalidArgumentError(\n          `username and ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' may not be used together for mechanism '${this.mechanism}'.`\n        );\n      }\n\n      if (this.username && this.password) {\n        throw new MongoInvalidArgumentError(\n          `No password is allowed in ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' for '${this.mechanism}'.`\n        );\n      }\n\n      if (\n        (this.mechanismProperties.ENVIRONMENT === 'azure' ||\n          this.mechanismProperties.ENVIRONMENT === 'gcp') &&\n        !this.mechanismProperties.TOKEN_RESOURCE\n      ) {\n        throw new MongoInvalidArgumentError(TOKEN_RESOURCE_MISSING_ERROR);\n      }\n\n      if (\n        this.mechanismProperties.ENVIRONMENT &&\n        !ALLOWED_ENVIRONMENT_NAMES.includes(this.mechanismProperties.ENVIRONMENT)\n      ) {\n        throw new MongoInvalidArgumentError(\n          `Currently only a ENVIRONMENT in ${ALLOWED_ENVIRONMENT_NAMES.join(\n            ','\n          )} is supported for mechanism '${this.mechanism}'.`\n        );\n      }\n\n      if (\n        !this.mechanismProperties.ENVIRONMENT &&\n        !this.mechanismProperties.OIDC_CALLBACK &&\n        !this.mechanismProperties.OIDC_HUMAN_CALLBACK\n      ) {\n        throw new MongoInvalidArgumentError(\n          `Either a ENVIRONMENT, OIDC_CALLBACK, or OIDC_HUMAN_CALLBACK must be specified for mechanism '${this.mechanism}'.`\n        );\n      }\n\n      if (this.mechanismProperties.ALLOWED_HOSTS) {\n        const hosts = this.mechanismProperties.ALLOWED_HOSTS;\n        if (!Array.isArray(hosts)) {\n          throw new MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);\n        }\n        for (const host of hosts) {\n          if (typeof host !== 'string') {\n            throw new MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);\n          }\n        }\n      }\n    }\n\n    if (AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {\n      if (this.source != null && this.source !== '$external') {\n        // TODO(NODE-3485): Replace this with a MongoAuthValidationError\n        throw new MongoAPIError(\n          `Invalid source '${this.source}' for mechanism '${this.mechanism}' specified.`\n        );\n      }\n    }\n\n    if (this.mechanism === AuthMechanism.MONGODB_PLAIN && this.source == null) {\n      // TODO(NODE-3485): Replace this with a MongoAuthValidationError\n      throw new MongoAPIError('PLAIN Authentication Mechanism needs an auth source');\n    }\n\n    if (this.mechanism === AuthMechanism.MONGODB_X509 && this.password != null) {\n      if (this.password === '') {\n        Reflect.set(this, 'password', undefined);\n        return;\n      }\n      // TODO(NODE-3485): Replace this with a MongoAuthValidationError\n      throw new MongoAPIError(`Password not allowed for mechanism MONGODB-X509`);\n    }\n\n    const canonicalization = this.mechanismProperties.CANONICALIZE_HOST_NAME ?? false;\n    if (!Object.values(GSSAPICanonicalizationValue).includes(canonicalization)) {\n      throw new MongoAPIError(`Invalid CANONICALIZE_HOST_NAME value: ${canonicalization}`);\n    }\n  }\n\n  static merge(\n    creds: MongoCredentials | undefined,\n    options: Partial<MongoCredentialsOptions>\n  ): MongoCredentials {\n    return new MongoCredentials({\n      username: options.username ?? creds?.username ?? '',\n      password: options.password ?? creds?.password ?? '',\n      mechanism: options.mechanism ?? creds?.mechanism ?? AuthMechanism.MONGODB_DEFAULT,\n      mechanismProperties: options.mechanismProperties ?? creds?.mechanismProperties ?? {},\n      source: options.source ?? options.db ?? creds?.source ?? 'admin'\n    });\n  }\n}\n"],"names":[],"mappings":";;;;;AAGA,MAAA;AAMA,MAAA;AAEA,MAAA;AAEA;;IAGA,SAAS,wBAAwB,KAAsB;IACrD,IAAI,OAAO;QACT,0DAA0D;QAC1D,uCAAuC;QACvC,IAAI,MAAM,OAAO,CAAC,MAAM,kBAAkB,GAAG;YAC3C,OAAO,MAAM,kBAAkB,CAAC,QAAQ,CAAC,YAAA,aAAa,CAAC,oBAAoB,IACvE,YAAA,aAAa,CAAC,oBAAoB,GAClC,YAAA,aAAa,CAAC,kBAAkB;QACtC;IACF;IAEA,6CAA6C;IAC7C,OAAO,YAAA,aAAa,CAAC,oBAAoB;AAC3C;AAEA,MAAM,4BAAsE;IAC1E;IACA;IACA;IACA;CACD;AACD,MAAM,sBAAsB;AAE5B,cAAA,GACa,QAAA,qBAAqB,GAAG;IACnC;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,qEAAA,GACA,MAAM,+BACJ;AA0DF;;;IAIA,MAAa;IAYX,YAAY,OAAgC,CAAA;QAC1C,IAAI,CAAC,QAAQ,GAAG,QAAQ,QAAQ,IAAI;QACpC,IAAI,CAAC,QAAQ,GAAG,QAAQ,QAAQ;QAChC,IAAI,CAAC,MAAM,GAAG,QAAQ,MAAM;QAC5B,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,QAAQ,EAAE,EAAE;YAC9B,IAAI,CAAC,MAAM,GAAG,QAAQ,EAAE;QAC1B;QACA,IAAI,CAAC,SAAS,GAAG,QAAQ,SAAS,IAAI,YAAA,aAAa,CAAC,eAAe;QACnE,IAAI,CAAC,mBAAmB,GAAG,QAAQ,mBAAmB,IAAI,CAAA;QAE1D,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,iBAAiB;YACxC,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,QAAQ,GAAG,CAAC,iBAAiB,EAAE;gBACnD,IAAI,CAAC,QAAQ,GAAG,QAAQ,GAAG,CAAC,iBAAiB;YAC/C;YAEA,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,QAAQ,GAAG,CAAC,qBAAqB,EAAE;gBACvD,IAAI,CAAC,QAAQ,GAAG,QAAQ,GAAG,CAAC,qBAAqB;YACnD;YAEA,IACE,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,IAAI,QAC9C,QAAQ,GAAG,CAAC,iBAAiB,IAAI,MACjC;gBACA,IAAI,CAAC,mBAAmB,GAAG;oBACzB,GAAG,IAAI,CAAC,mBAAmB;oBAC3B,mBAAmB,QAAQ,GAAG,CAAC,iBAAiB;;YAEpD;QACF;QAEA,IAAI,IAAI,CAAC,SAAS,KAAK,YAAA,aAAa,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,aAAa,EAAE;YAC5F,IAAI,CAAC,mBAAmB,GAAG;gBACzB,GAAG,IAAI,CAAC,mBAAmB;gBAC3B,eAAe,QAAA,qBAAqB;;QAExC;QAEA,OAAO,MAAM,CAAC,IAAI,CAAC,mBAAmB;QACtC,OAAO,MAAM,CAAC,IAAI;IACpB;IAEA,8DAAA,GACA,OAAO,KAAuB,EAAA;QAC5B,OACE,IAAI,CAAC,SAAS,KAAK,MAAM,SAAS,IAClC,IAAI,CAAC,QAAQ,KAAK,MAAM,QAAQ,IAChC,IAAI,CAAC,QAAQ,KAAK,MAAM,QAAQ,IAChC,IAAI,CAAC,MAAM,KAAK,MAAM,MAAM;IAEhC;IAEA;;;;;QAMA,qBAAqB,KAAsB,EAAA;QACzC,0EAA0E;QAC1E,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,aAAa;YACpC,OAAO,IAAI,iBAAiB;gBAC1B,UAAU,IAAI,CAAC,QAAQ;gBACvB,UAAU,IAAI,CAAC,QAAQ;gBACvB,QAAQ,IAAI,CAAC,MAAM;gBACnB,WAAW,wBAAwB;gBACnC,qBAAqB,IAAI,CAAC,mBAAmB;;QAEjD;QAEA,OAAO,IAAI;IACb;IAEA,WAAQ;QACN,IACE,CAAC,IAAI,CAAC,SAAS,KAAK,YAAA,aAAa,CAAC,cAAc,IAC9C,IAAI,CAAC,SAAS,KAAK,YAAA,aAAa,CAAC,aAAa,IAC9C,IAAI,CAAC,SAAS,KAAK,YAAA,aAAa,CAAC,kBAAkB,IACnD,IAAI,CAAC,SAAS,KAAK,YAAA,aAAa,CAAC,oBAAoB,KACvD,CAAC,IAAI,CAAC,QAAQ,EACd;YACA,MAAM,IAAI,QAAA,4BAA4B,CAAC,CAAA,iCAAA,EAAoC,IAAI,CAAC,SAAS,CAAA,CAAA,CAAG;QAC9F;QAEA,IAAI,IAAI,CAAC,SAAS,KAAK,YAAA,aAAa,CAAC,YAAY,EAAE;YACjD,IACE,IAAI,CAAC,QAAQ,IACb,IAAI,CAAC,mBAAmB,CAAC,WAAW,IACpC,IAAI,CAAC,mBAAmB,CAAC,WAAW,KAAK,SACzC;gBACA,MAAM,IAAI,QAAA,yBAAyB,CACjC,CAAA,0BAAA,EAA6B,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAA,0CAAA,EAA6C,IAAI,CAAC,SAAS,CAAA,EAAA,CAAI;YAEpI;YAEA,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAClC,MAAM,IAAI,QAAA,yBAAyB,CACjC,CAAA,uCAAA,EAA0C,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAA,OAAA,EAAU,IAAI,CAAC,SAAS,CAAA,EAAA,CAAI;YAE9G;YAEA,IACE,CAAC,IAAI,CAAC,mBAAmB,CAAC,WAAW,KAAK,WACxC,IAAI,CAAC,mBAAmB,CAAC,WAAW,KAAK,KAAK,KAChD,CAAC,IAAI,CAAC,mBAAmB,CAAC,cAAc,EACxC;gBACA,MAAM,IAAI,QAAA,yBAAyB,CAAC;YACtC;YAEA,IACE,IAAI,CAAC,mBAAmB,CAAC,WAAW,IACpC,CAAC,0BAA0B,QAAQ,CAAC,IAAI,CAAC,mBAAmB,CAAC,WAAW,GACxE;gBACA,MAAM,IAAI,QAAA,yBAAyB,CACjC,CAAA,gCAAA,EAAmC,0BAA0B,IAAI,CAC/D,KACD,6BAAA,EAAgC,IAAI,CAAC,SAAS,CAAA,EAAA,CAAI;YAEvD;YAEA,IACE,CAAC,IAAI,CAAC,mBAAmB,CAAC,WAAW,IACrC,CAAC,IAAI,CAAC,mBAAmB,CAAC,aAAa,IACvC,CAAC,IAAI,CAAC,mBAAmB,CAAC,mBAAmB,EAC7C;gBACA,MAAM,IAAI,QAAA,yBAAyB,CACjC,CAAA,6FAAA,EAAgG,IAAI,CAAC,SAAS,CAAA,EAAA,CAAI;YAEtH;YAEA,IAAI,IAAI,CAAC,mBAAmB,CAAC,aAAa,EAAE;gBAC1C,MAAM,QAAQ,IAAI,CAAC,mBAAmB,CAAC,aAAa;gBACpD,IAAI,CAAC,MAAM,OAAO,CAAC,QAAQ;oBACzB,MAAM,IAAI,QAAA,yBAAyB,CAAC;gBACtC;gBACA,KAAK,MAAM,QAAQ,MAAO;oBACxB,IAAI,OAAO,SAAS,UAAU;wBAC5B,MAAM,IAAI,QAAA,yBAAyB,CAAC;oBACtC;gBACF;YACF;QACF;QAEA,IAAI,YAAA,4BAA4B,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,GAAG;YACpD,IAAI,IAAI,CAAC,MAAM,IAAI,QAAQ,IAAI,CAAC,MAAM,KAAK,aAAa;gBACtD,gEAAgE;gBAChE,MAAM,IAAI,QAAA,aAAa,CACrB,CAAA,gBAAA,EAAmB,IAAI,CAAC,MAAM,CAAA,iBAAA,EAAoB,IAAI,CAAC,SAAS,CAAA,YAAA,CAAc;YAElF;QACF;QAEA,IAAI,IAAI,CAAC,SAAS,KAAK,YAAA,aAAa,CAAC,aAAa,IAAI,IAAI,CAAC,MAAM,IAAI,MAAM;YACzE,gEAAgE;YAChE,MAAM,IAAI,QAAA,aAAa,CAAC;QAC1B;QAEA,IAAI,IAAI,CAAC,SAAS,KAAK,YAAA,aAAa,CAAC,YAAY,IAAI,IAAI,CAAC,QAAQ,IAAI,MAAM;YAC1E,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI;gBACxB,QAAQ,GAAG,CAAC,IAAI,EAAE,YAAY;gBAC9B;YACF;YACA,gEAAgE;YAChE,MAAM,IAAI,QAAA,aAAa,CAAC,CAAA,+CAAA,CAAiD;QAC3E;QAEA,MAAM,mBAAmB,IAAI,CAAC,mBAAmB,CAAC,sBAAsB,IAAI;QAC5E,IAAI,CAAC,OAAO,MAAM,CAAC,SAAA,2BAA2B,EAAE,QAAQ,CAAC,mBAAmB;YAC1E,MAAM,IAAI,QAAA,aAAa,CAAC,CAAA,sCAAA,EAAyC,iBAAgB,CAAE;QACrF;IACF;IAEA,OAAO,MACL,KAAmC,EACnC,OAAyC,EAAA;QAEzC,OAAO,IAAI,iBAAiB;YAC1B,UAAU,QAAQ,QAAQ,IAAI,OAAO,YAAY;YACjD,UAAU,QAAQ,QAAQ,IAAI,OAAO,YAAY;YACjD,WAAW,QAAQ,SAAS,IAAI,OAAO,aAAa,YAAA,aAAa,CAAC,eAAe;YACjF,qBAAqB,QAAQ,mBAAmB,IAAI,OAAO,uBAAuB,CAAA;YAClF,QAAQ,QAAQ,MAAM,IAAI,QAAQ,EAAE,IAAI,OAAO,UAAU;;IAE7D;;AAlMF,QAAA,gBAAA,GAAA"}},
    {"offset": {"line": 934, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 938, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/handshake/client_metadata.ts"],"sourcesContent":["import * as os from 'os';\nimport * as process from 'process';\n\nimport { BSON, type Document, Int32 } from '../../bson';\nimport { MongoInvalidArgumentError } from '../../error';\nimport type { MongoOptions } from '../../mongo_client';\nimport { fileIsAccessible } from '../../utils';\n\n// eslint-disable-next-line @typescript-eslint/no-require-imports\nconst NODE_DRIVER_VERSION = require('../../../package.json').version;\n\n/**\n * @public\n * @see https://github.com/mongodb/specifications/blob/master/source/mongodb-handshake/handshake.md#hello-command\n */\nexport interface ClientMetadata {\n  driver: {\n    name: string;\n    version: string;\n  };\n  os: {\n    type: string;\n    name?: NodeJS.Platform;\n    architecture?: string;\n    version?: string;\n  };\n  platform: string;\n  application?: {\n    name: string;\n  };\n  /** FaaS environment information */\n  env?: {\n    name: 'aws.lambda' | 'gcp.func' | 'azure.func' | 'vercel';\n    timeout_sec?: Int32;\n    memory_mb?: Int32;\n    region?: string;\n    url?: string;\n  };\n}\n\n/** @public */\nexport interface ClientMetadataOptions {\n  driverInfo?: {\n    name?: string;\n    version?: string;\n    platform?: string;\n  };\n  appName?: string;\n}\n\n/** @internal */\nexport class LimitedSizeDocument {\n  private document = new Map();\n  /** BSON overhead: Int32 + Null byte */\n  private documentSize = 5;\n  constructor(private maxSize: number) {}\n\n  /** Only adds key/value if the bsonByteLength is less than MAX_SIZE */\n  public ifItFitsItSits(key: string, value: Record<string, any> | string): boolean {\n    // The BSON byteLength of the new element is the same as serializing it to its own document\n    // subtracting the document size int32 and the null terminator.\n    const newElementSize = BSON.serialize(new Map().set(key, value)).byteLength - 5;\n\n    if (newElementSize + this.documentSize > this.maxSize) {\n      return false;\n    }\n\n    this.documentSize += newElementSize;\n\n    this.document.set(key, value);\n\n    return true;\n  }\n\n  toObject(): Document {\n    return BSON.deserialize(BSON.serialize(this.document), {\n      promoteLongs: false,\n      promoteBuffers: false,\n      promoteValues: false,\n      useBigInt64: false\n    });\n  }\n}\n\ntype MakeClientMetadataOptions = Pick<MongoOptions, 'appName' | 'driverInfo'>;\n/**\n * From the specs:\n * Implementors SHOULD cumulatively update fields in the following order until the document is under the size limit:\n * 1. Omit fields from `env` except `env.name`.\n * 2. Omit fields from `os` except `os.type`.\n * 3. Omit the `env` document entirely.\n * 4. Truncate `platform`. -- special we do not truncate this field\n */\nexport function makeClientMetadata(options: MakeClientMetadataOptions): ClientMetadata {\n  const metadataDocument = new LimitedSizeDocument(512);\n\n  const { appName = '' } = options;\n  // Add app name first, it must be sent\n  if (appName.length > 0) {\n    const name =\n      Buffer.byteLength(appName, 'utf8') <= 128\n        ? options.appName\n        : Buffer.from(appName, 'utf8').subarray(0, 128).toString('utf8');\n    metadataDocument.ifItFitsItSits('application', { name });\n  }\n\n  const { name = '', version = '', platform = '' } = options.driverInfo;\n\n  const driverInfo = {\n    name: name.length > 0 ? `nodejs|${name}` : 'nodejs',\n    version: version.length > 0 ? `${NODE_DRIVER_VERSION}|${version}` : NODE_DRIVER_VERSION\n  };\n\n  if (!metadataDocument.ifItFitsItSits('driver', driverInfo)) {\n    throw new MongoInvalidArgumentError(\n      'Unable to include driverInfo name and version, metadata cannot exceed 512 bytes'\n    );\n  }\n\n  let runtimeInfo = getRuntimeInfo();\n  if (platform.length > 0) {\n    runtimeInfo = `${runtimeInfo}|${platform}`;\n  }\n\n  if (!metadataDocument.ifItFitsItSits('platform', runtimeInfo)) {\n    throw new MongoInvalidArgumentError(\n      'Unable to include driverInfo platform, metadata cannot exceed 512 bytes'\n    );\n  }\n\n  // Note: order matters, os.type is last so it will be removed last if we're at maxSize\n  const osInfo = new Map()\n    .set('name', process.platform)\n    .set('architecture', process.arch)\n    .set('version', os.release())\n    .set('type', os.type());\n\n  if (!metadataDocument.ifItFitsItSits('os', osInfo)) {\n    for (const key of osInfo.keys()) {\n      osInfo.delete(key);\n      if (osInfo.size === 0) break;\n      if (metadataDocument.ifItFitsItSits('os', osInfo)) break;\n    }\n  }\n\n  const faasEnv = getFAASEnv();\n  if (faasEnv != null) {\n    if (!metadataDocument.ifItFitsItSits('env', faasEnv)) {\n      for (const key of faasEnv.keys()) {\n        faasEnv.delete(key);\n        if (faasEnv.size === 0) break;\n        if (metadataDocument.ifItFitsItSits('env', faasEnv)) break;\n      }\n    }\n  }\n  return metadataDocument.toObject() as ClientMetadata;\n}\n\nlet dockerPromise: Promise<boolean>;\n/** @internal */\nasync function getContainerMetadata() {\n  const containerMetadata: Record<string, any> = {};\n  dockerPromise ??= fileIsAccessible('/.dockerenv');\n  const isDocker = await dockerPromise;\n\n  const { KUBERNETES_SERVICE_HOST = '' } = process.env;\n  const isKubernetes = KUBERNETES_SERVICE_HOST.length > 0 ? true : false;\n\n  if (isDocker) containerMetadata.runtime = 'docker';\n  if (isKubernetes) containerMetadata.orchestrator = 'kubernetes';\n\n  return containerMetadata;\n}\n\n/**\n * @internal\n * Re-add each metadata value.\n * Attempt to add new env container metadata, but keep old data if it does not fit.\n */\nexport async function addContainerMetadata(originalMetadata: ClientMetadata) {\n  const containerMetadata = await getContainerMetadata();\n  if (Object.keys(containerMetadata).length === 0) return originalMetadata;\n\n  const extendedMetadata = new LimitedSizeDocument(512);\n\n  const extendedEnvMetadata = { ...originalMetadata?.env, container: containerMetadata };\n\n  for (const [key, val] of Object.entries(originalMetadata)) {\n    if (key !== 'env') {\n      extendedMetadata.ifItFitsItSits(key, val);\n    } else {\n      if (!extendedMetadata.ifItFitsItSits('env', extendedEnvMetadata)) {\n        // add in old data if newer / extended metadata does not fit\n        extendedMetadata.ifItFitsItSits('env', val);\n      }\n    }\n  }\n\n  if (!('env' in originalMetadata)) {\n    extendedMetadata.ifItFitsItSits('env', extendedEnvMetadata);\n  }\n\n  return extendedMetadata.toObject();\n}\n\n/**\n * Collects FaaS metadata.\n * - `name` MUST be the last key in the Map returned.\n */\nexport function getFAASEnv(): Map<string, string | Int32> | null {\n  const {\n    AWS_EXECUTION_ENV = '',\n    AWS_LAMBDA_RUNTIME_API = '',\n    FUNCTIONS_WORKER_RUNTIME = '',\n    K_SERVICE = '',\n    FUNCTION_NAME = '',\n    VERCEL = '',\n    AWS_LAMBDA_FUNCTION_MEMORY_SIZE = '',\n    AWS_REGION = '',\n    FUNCTION_MEMORY_MB = '',\n    FUNCTION_REGION = '',\n    FUNCTION_TIMEOUT_SEC = '',\n    VERCEL_REGION = ''\n  } = process.env;\n\n  const isAWSFaaS =\n    AWS_EXECUTION_ENV.startsWith('AWS_Lambda_') || AWS_LAMBDA_RUNTIME_API.length > 0;\n  const isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;\n  const isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;\n  const isVercelFaaS = VERCEL.length > 0;\n\n  // Note: order matters, name must always be the last key\n  const faasEnv = new Map();\n\n  // When isVercelFaaS is true so is isAWSFaaS; Vercel inherits the AWS env\n  if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {\n    if (VERCEL_REGION.length > 0) {\n      faasEnv.set('region', VERCEL_REGION);\n    }\n\n    faasEnv.set('name', 'vercel');\n    return faasEnv;\n  }\n\n  if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {\n    if (AWS_REGION.length > 0) {\n      faasEnv.set('region', AWS_REGION);\n    }\n\n    if (\n      AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 &&\n      Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)\n    ) {\n      faasEnv.set('memory_mb', new Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));\n    }\n\n    faasEnv.set('name', 'aws.lambda');\n    return faasEnv;\n  }\n\n  if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {\n    faasEnv.set('name', 'azure.func');\n    return faasEnv;\n  }\n\n  if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {\n    if (FUNCTION_REGION.length > 0) {\n      faasEnv.set('region', FUNCTION_REGION);\n    }\n\n    if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {\n      faasEnv.set('memory_mb', new Int32(FUNCTION_MEMORY_MB));\n    }\n\n    if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {\n      faasEnv.set('timeout_sec', new Int32(FUNCTION_TIMEOUT_SEC));\n    }\n\n    faasEnv.set('name', 'gcp.func');\n    return faasEnv;\n  }\n\n  return null;\n}\n\n/**\n * @internal\n * This type represents the global Deno object and the minimal type contract we expect it to satisfy.\n */\ndeclare const Deno: { version?: { deno?: string } } | undefined;\n\n/**\n * @internal\n * This type represents the global Bun object and the minimal type contract we expect it to satisfy.\n */\ndeclare const Bun: { (): void; version?: string } | undefined;\n\n/**\n * @internal\n * Get current JavaScript runtime platform\n *\n * NOTE: The version information fetching is intentionally written defensively\n * to avoid having a released driver version that becomes incompatible\n * with a future change to these global objects.\n */\nfunction getRuntimeInfo(): string {\n  if ('Deno' in globalThis) {\n    const version = typeof Deno?.version?.deno === 'string' ? Deno?.version?.deno : '0.0.0-unknown';\n\n    return `Deno v${version}, ${os.endianness()}`;\n  }\n\n  if ('Bun' in globalThis) {\n    const version = typeof Bun?.version === 'string' ? Bun?.version : '0.0.0-unknown';\n\n    return `Bun v${version}, ${os.endianness()}`;\n  }\n\n  return `Node.js ${process.version}, ${os.endianness()}`;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1141, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/commands.ts"],"sourcesContent":["import type { BSONSerializeOptions, Document, Long } from '../bson';\nimport * as BSON from '../bson';\nimport { MongoInvalidArgumentError, MongoRuntimeError } from '../error';\nimport { type ReadPreference } from '../read_preference';\nimport type { ClientSession } from '../sessions';\nimport type { CommandOptions } from './connection';\nimport {\n  compress,\n  Compressor,\n  type CompressorName,\n  uncompressibleCommands\n} from './wire_protocol/compression';\nimport { OP_COMPRESSED, OP_MSG, OP_QUERY } from './wire_protocol/constants';\n\n// Incrementing request id\nlet _requestId = 0;\n\n// Query flags\nconst OPTS_TAILABLE_CURSOR = 2;\nconst OPTS_SECONDARY = 4;\nconst OPTS_OPLOG_REPLAY = 8;\nconst OPTS_NO_CURSOR_TIMEOUT = 16;\nconst OPTS_AWAIT_DATA = 32;\nconst OPTS_EXHAUST = 64;\nconst OPTS_PARTIAL = 128;\n\n// Response flags\nconst CURSOR_NOT_FOUND = 1;\nconst QUERY_FAILURE = 2;\nconst SHARD_CONFIG_STALE = 4;\nconst AWAIT_CAPABLE = 8;\n\nconst encodeUTF8Into = BSON.BSON.onDemand.ByteUtils.encodeUTF8Into;\n\n/** @internal */\nexport type WriteProtocolMessageType = OpQueryRequest | OpMsgRequest;\n\n/** @internal */\nexport interface OpQueryOptions extends CommandOptions {\n  socketTimeoutMS?: number;\n  session?: ClientSession;\n  numberToSkip?: number;\n  numberToReturn?: number;\n  returnFieldSelector?: Document;\n  pre32Limit?: number;\n  serializeFunctions?: boolean;\n  ignoreUndefined?: boolean;\n  maxBsonSize?: number;\n  checkKeys?: boolean;\n  secondaryOk?: boolean;\n\n  requestId?: number;\n  moreToCome?: boolean;\n  exhaustAllowed?: boolean;\n}\n\n/** @internal */\nexport class OpQueryRequest {\n  ns: string;\n  numberToSkip: number;\n  numberToReturn: number;\n  returnFieldSelector?: Document;\n  requestId: number;\n  pre32Limit?: number;\n  serializeFunctions: boolean;\n  ignoreUndefined: boolean;\n  maxBsonSize: number;\n  checkKeys: boolean;\n  batchSize: number;\n  tailable: boolean;\n  secondaryOk: boolean;\n  oplogReplay: boolean;\n  noCursorTimeout: boolean;\n  awaitData: boolean;\n  exhaust: boolean;\n  partial: boolean;\n  /** moreToCome is an OP_MSG only concept */\n  moreToCome = false;\n\n  constructor(\n    public databaseName: string,\n    public query: Document,\n    options: OpQueryOptions\n  ) {\n    // Basic options needed to be passed in\n    // TODO(NODE-3483): Replace with MongoCommandError\n    const ns = `${databaseName}.$cmd`;\n    if (typeof databaseName !== 'string') {\n      throw new MongoRuntimeError('Database name must be a string for a query');\n    }\n    // TODO(NODE-3483): Replace with MongoCommandError\n    if (query == null) throw new MongoRuntimeError('A query document must be specified for query');\n\n    // Validate that we are not passing 0x00 in the collection name\n    if (ns.indexOf('\\x00') !== -1) {\n      // TODO(NODE-3483): Use MongoNamespace static method\n      throw new MongoRuntimeError('Namespace cannot contain a null character');\n    }\n\n    // Basic options\n    this.ns = ns;\n\n    // Additional options\n    this.numberToSkip = options.numberToSkip || 0;\n    this.numberToReturn = options.numberToReturn || 0;\n    this.returnFieldSelector = options.returnFieldSelector || undefined;\n    this.requestId = options.requestId ?? OpQueryRequest.getRequestId();\n\n    // special case for pre-3.2 find commands, delete ASAP\n    this.pre32Limit = options.pre32Limit;\n\n    // Serialization option\n    this.serializeFunctions =\n      typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    this.ignoreUndefined =\n      typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;\n    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;\n    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    this.batchSize = this.numberToReturn;\n\n    // Flags\n    this.tailable = false;\n    this.secondaryOk = typeof options.secondaryOk === 'boolean' ? options.secondaryOk : false;\n    this.oplogReplay = false;\n    this.noCursorTimeout = false;\n    this.awaitData = false;\n    this.exhaust = false;\n    this.partial = false;\n  }\n\n  /** Assign next request Id. */\n  incRequestId(): void {\n    this.requestId = _requestId++;\n  }\n\n  /** Peek next request Id. */\n  nextRequestId(): number {\n    return _requestId + 1;\n  }\n\n  /** Increment then return next request Id. */\n  static getRequestId(): number {\n    return ++_requestId;\n  }\n\n  // Uses a single allocated buffer for the process, avoiding multiple memory allocations\n  toBin(): Uint8Array[] {\n    const buffers = [];\n    let projection = null;\n\n    // Set up the flags\n    let flags = 0;\n    if (this.tailable) {\n      flags |= OPTS_TAILABLE_CURSOR;\n    }\n\n    if (this.secondaryOk) {\n      flags |= OPTS_SECONDARY;\n    }\n\n    if (this.oplogReplay) {\n      flags |= OPTS_OPLOG_REPLAY;\n    }\n\n    if (this.noCursorTimeout) {\n      flags |= OPTS_NO_CURSOR_TIMEOUT;\n    }\n\n    if (this.awaitData) {\n      flags |= OPTS_AWAIT_DATA;\n    }\n\n    if (this.exhaust) {\n      flags |= OPTS_EXHAUST;\n    }\n\n    if (this.partial) {\n      flags |= OPTS_PARTIAL;\n    }\n\n    // If batchSize is different to this.numberToReturn\n    if (this.batchSize !== this.numberToReturn) this.numberToReturn = this.batchSize;\n\n    // Allocate write protocol header buffer\n    const header = Buffer.alloc(\n      4 * 4 + // Header\n        4 + // Flags\n        Buffer.byteLength(this.ns) +\n        1 + // namespace\n        4 + // numberToSkip\n        4 // numberToReturn\n    );\n\n    // Add header to buffers\n    buffers.push(header);\n\n    // Serialize the query\n    const query = BSON.serialize(this.query, {\n      checkKeys: this.checkKeys,\n      serializeFunctions: this.serializeFunctions,\n      ignoreUndefined: this.ignoreUndefined\n    });\n\n    // Add query document\n    buffers.push(query);\n\n    if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {\n      // Serialize the projection document\n      projection = BSON.serialize(this.returnFieldSelector, {\n        checkKeys: this.checkKeys,\n        serializeFunctions: this.serializeFunctions,\n        ignoreUndefined: this.ignoreUndefined\n      });\n      // Add projection document\n      buffers.push(projection);\n    }\n\n    // Total message size\n    const totalLength = header.length + query.length + (projection ? projection.length : 0);\n\n    // Set up the index\n    let index = 4;\n\n    // Write total document length\n    header[3] = (totalLength >> 24) & 0xff;\n    header[2] = (totalLength >> 16) & 0xff;\n    header[1] = (totalLength >> 8) & 0xff;\n    header[0] = totalLength & 0xff;\n\n    // Write header information requestId\n    header[index + 3] = (this.requestId >> 24) & 0xff;\n    header[index + 2] = (this.requestId >> 16) & 0xff;\n    header[index + 1] = (this.requestId >> 8) & 0xff;\n    header[index] = this.requestId & 0xff;\n    index = index + 4;\n\n    // Write header information responseTo\n    header[index + 3] = (0 >> 24) & 0xff;\n    header[index + 2] = (0 >> 16) & 0xff;\n    header[index + 1] = (0 >> 8) & 0xff;\n    header[index] = 0 & 0xff;\n    index = index + 4;\n\n    // Write header information OP_QUERY\n    header[index + 3] = (OP_QUERY >> 24) & 0xff;\n    header[index + 2] = (OP_QUERY >> 16) & 0xff;\n    header[index + 1] = (OP_QUERY >> 8) & 0xff;\n    header[index] = OP_QUERY & 0xff;\n    index = index + 4;\n\n    // Write header information flags\n    header[index + 3] = (flags >> 24) & 0xff;\n    header[index + 2] = (flags >> 16) & 0xff;\n    header[index + 1] = (flags >> 8) & 0xff;\n    header[index] = flags & 0xff;\n    index = index + 4;\n\n    // Write collection name\n    index = index + header.write(this.ns, index, 'utf8') + 1;\n    header[index - 1] = 0;\n\n    // Write header information flags numberToSkip\n    header[index + 3] = (this.numberToSkip >> 24) & 0xff;\n    header[index + 2] = (this.numberToSkip >> 16) & 0xff;\n    header[index + 1] = (this.numberToSkip >> 8) & 0xff;\n    header[index] = this.numberToSkip & 0xff;\n    index = index + 4;\n\n    // Write header information flags numberToReturn\n    header[index + 3] = (this.numberToReturn >> 24) & 0xff;\n    header[index + 2] = (this.numberToReturn >> 16) & 0xff;\n    header[index + 1] = (this.numberToReturn >> 8) & 0xff;\n    header[index] = this.numberToReturn & 0xff;\n    index = index + 4;\n\n    // Return the buffers\n    return buffers;\n  }\n}\n\n/** @internal */\nexport interface MessageHeader {\n  length: number;\n  requestId: number;\n  responseTo: number;\n  opCode: number;\n  fromCompressed?: boolean;\n}\n\n/** @internal */\nexport class OpReply {\n  parsed: boolean;\n  raw: Buffer;\n  data: Buffer;\n  opts: BSONSerializeOptions;\n  length: number;\n  requestId: number;\n  responseTo: number;\n  opCode: number;\n  fromCompressed?: boolean;\n  responseFlags?: number;\n  cursorId?: Long;\n  startingFrom?: number;\n  numberReturned?: number;\n  cursorNotFound?: boolean;\n  queryFailure?: boolean;\n  shardConfigStale?: boolean;\n  awaitCapable?: boolean;\n  useBigInt64: boolean;\n  promoteLongs: boolean;\n  promoteValues: boolean;\n  promoteBuffers: boolean;\n  bsonRegExp?: boolean;\n  index = 0;\n  sections: Uint8Array[] = [];\n\n  /** moreToCome is an OP_MSG only concept */\n  moreToCome = false;\n\n  constructor(\n    message: Buffer,\n    msgHeader: MessageHeader,\n    msgBody: Buffer,\n    opts?: BSONSerializeOptions\n  ) {\n    this.parsed = false;\n    this.raw = message;\n    this.data = msgBody;\n    this.opts = opts ?? {\n      useBigInt64: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: false,\n      bsonRegExp: false\n    };\n\n    // Read the message header\n    this.length = msgHeader.length;\n    this.requestId = msgHeader.requestId;\n    this.responseTo = msgHeader.responseTo;\n    this.opCode = msgHeader.opCode;\n    this.fromCompressed = msgHeader.fromCompressed;\n\n    // Flag values\n    this.useBigInt64 = typeof this.opts.useBigInt64 === 'boolean' ? this.opts.useBigInt64 : false;\n    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;\n    this.promoteValues =\n      typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;\n    this.promoteBuffers =\n      typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;\n    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;\n  }\n\n  isParsed(): boolean {\n    return this.parsed;\n  }\n\n  parse(): Uint8Array {\n    // Don't parse again if not needed\n    if (this.parsed) return this.sections[0];\n\n    // Position within OP_REPLY at which documents start\n    // (See https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#wire-op-reply)\n    this.index = 20;\n\n    // Read the message body\n    this.responseFlags = this.data.readInt32LE(0);\n    this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));\n    this.startingFrom = this.data.readInt32LE(12);\n    this.numberReturned = this.data.readInt32LE(16);\n\n    if (this.numberReturned < 0 || this.numberReturned > 2 ** 32 - 1) {\n      throw new RangeError(\n        `OP_REPLY numberReturned is an invalid array length ${this.numberReturned}`\n      );\n    }\n\n    this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;\n    this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;\n    this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;\n    this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;\n\n    // Parse Body\n    for (let i = 0; i < this.numberReturned; i++) {\n      const bsonSize =\n        this.data[this.index] |\n        (this.data[this.index + 1] << 8) |\n        (this.data[this.index + 2] << 16) |\n        (this.data[this.index + 3] << 24);\n\n      const section = this.data.subarray(this.index, this.index + bsonSize);\n      this.sections.push(section);\n\n      // Adjust the index\n      this.index = this.index + bsonSize;\n    }\n\n    // Set parsed\n    this.parsed = true;\n\n    return this.sections[0];\n  }\n}\n\n// Msg Flags\nconst OPTS_CHECKSUM_PRESENT = 1;\nconst OPTS_MORE_TO_COME = 2;\nconst OPTS_EXHAUST_ALLOWED = 1 << 16;\n\n/** @internal */\nexport interface OpMsgOptions {\n  socketTimeoutMS?: number;\n  session?: ClientSession;\n  numberToSkip?: number;\n  numberToReturn?: number;\n  returnFieldSelector?: Document;\n  pre32Limit?: number;\n  serializeFunctions?: boolean;\n  ignoreUndefined?: boolean;\n  maxBsonSize?: number;\n  checkKeys?: boolean;\n  secondaryOk?: boolean;\n\n  requestId?: number;\n  moreToCome?: boolean;\n  exhaustAllowed?: boolean;\n  readPreference: ReadPreference;\n}\n\n/** @internal */\nexport class DocumentSequence {\n  field: string;\n  documents: Document[];\n  serializedDocumentsLength: number;\n  private chunks: Uint8Array[];\n  private header: Buffer;\n\n  /**\n   * Create a new document sequence for the provided field.\n   * @param field - The field it will replace.\n   */\n  constructor(field: string, documents?: Document[]) {\n    this.field = field;\n    this.documents = [];\n    this.chunks = [];\n    this.serializedDocumentsLength = 0;\n    // Document sequences starts with type 1 at the first byte.\n    // Field strings must always be UTF-8.\n    const buffer = Buffer.allocUnsafe(1 + 4 + this.field.length + 1);\n    buffer[0] = 1;\n    // Third part is the field name at offset 5 with trailing null byte.\n    encodeUTF8Into(buffer, `${this.field}\\0`, 5);\n    this.chunks.push(buffer);\n    this.header = buffer;\n    if (documents) {\n      for (const doc of documents) {\n        this.push(doc, BSON.serialize(doc));\n      }\n    }\n  }\n\n  /**\n   * Push a document to the document sequence. Will serialize the document\n   * as well and return the current serialized length of all documents.\n   * @param document - The document to add.\n   * @param buffer - The serialized document in raw BSON.\n   * @returns The new total document sequence length.\n   */\n  push(document: Document, buffer: Uint8Array): number {\n    this.serializedDocumentsLength += buffer.length;\n    // Push the document.\n    this.documents.push(document);\n    // Push the document raw bson.\n    this.chunks.push(buffer);\n    // Write the new length.\n    this.header?.writeInt32LE(4 + this.field.length + 1 + this.serializedDocumentsLength, 1);\n    return this.serializedDocumentsLength + this.header.length;\n  }\n\n  /**\n   * Get the fully serialized bytes for the document sequence section.\n   * @returns The section bytes.\n   */\n  toBin(): Uint8Array {\n    return Buffer.concat(this.chunks);\n  }\n}\n\n/** @internal */\nexport class OpMsgRequest {\n  requestId: number;\n  serializeFunctions: boolean;\n  ignoreUndefined: boolean;\n  checkKeys: boolean;\n  maxBsonSize: number;\n  checksumPresent: boolean;\n  moreToCome: boolean;\n  exhaustAllowed: boolean;\n\n  constructor(\n    public databaseName: string,\n    public command: Document,\n    public options: OpQueryOptions\n  ) {\n    // Basic options needed to be passed in\n    if (command == null)\n      throw new MongoInvalidArgumentError('Query document must be specified for query');\n\n    // Basic options\n    this.command.$db = databaseName;\n\n    // Ensure empty options\n    this.options = options ?? {};\n\n    // Additional options\n    this.requestId = options.requestId ? options.requestId : OpMsgRequest.getRequestId();\n\n    // Serialization option\n    this.serializeFunctions =\n      typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    this.ignoreUndefined =\n      typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;\n    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;\n\n    // flags\n    this.checksumPresent = false;\n    this.moreToCome = options.moreToCome ?? command.writeConcern?.w === 0;\n    this.exhaustAllowed =\n      typeof options.exhaustAllowed === 'boolean' ? options.exhaustAllowed : false;\n  }\n\n  toBin(): Buffer[] {\n    const buffers: Buffer[] = [];\n    let flags = 0;\n\n    if (this.checksumPresent) {\n      flags |= OPTS_CHECKSUM_PRESENT;\n    }\n\n    if (this.moreToCome) {\n      flags |= OPTS_MORE_TO_COME;\n    }\n\n    if (this.exhaustAllowed) {\n      flags |= OPTS_EXHAUST_ALLOWED;\n    }\n\n    const header = Buffer.alloc(\n      4 * 4 + // Header\n        4 // Flags\n    );\n\n    buffers.push(header);\n\n    let totalLength = header.length;\n    const command = this.command;\n    totalLength += this.makeSections(buffers, command);\n\n    header.writeInt32LE(totalLength, 0); // messageLength\n    header.writeInt32LE(this.requestId, 4); // requestID\n    header.writeInt32LE(0, 8); // responseTo\n    header.writeInt32LE(OP_MSG, 12); // opCode\n    header.writeUInt32LE(flags, 16); // flags\n    return buffers;\n  }\n\n  /**\n   * Add the sections to the OP_MSG request's buffers and returns the length.\n   */\n  makeSections(buffers: Uint8Array[], document: Document): number {\n    const sequencesBuffer = this.extractDocumentSequences(document);\n    const payloadTypeBuffer = Buffer.allocUnsafe(1);\n    payloadTypeBuffer[0] = 0;\n\n    const documentBuffer = this.serializeBson(document);\n    // First section, type 0\n    buffers.push(payloadTypeBuffer);\n    buffers.push(documentBuffer);\n    // Subsequent sections, type 1\n    buffers.push(sequencesBuffer);\n\n    return payloadTypeBuffer.length + documentBuffer.length + sequencesBuffer.length;\n  }\n\n  /**\n   * Extracts the document sequences from the command document and returns\n   * a buffer to be added as multiple sections after the initial type 0\n   * section in the message.\n   */\n  extractDocumentSequences(document: Document): Uint8Array {\n    // Pull out any field in the command document that's value is a document sequence.\n    const chunks = [];\n    for (const [key, value] of Object.entries(document)) {\n      if (value instanceof DocumentSequence) {\n        chunks.push(value.toBin());\n        // Why are we removing the field from the command? This is because it needs to be\n        // removed in the OP_MSG request first section, and DocumentSequence is not a\n        // BSON type and is specific to the MongoDB wire protocol so there's nothing\n        // our BSON serializer can do about this. Since DocumentSequence is not exposed\n        // in the public API and only used internally, we are never mutating an original\n        // command provided by the user, just our own, and it's cheaper to delete from\n        // our own command than copying it.\n        delete document[key];\n      }\n    }\n    if (chunks.length > 0) {\n      return Buffer.concat(chunks);\n    }\n    // If we have no document sequences we return an empty buffer for nothing to add\n    // to the payload.\n    return Buffer.alloc(0);\n  }\n\n  serializeBson(document: Document): Uint8Array {\n    return BSON.serialize(document, {\n      checkKeys: this.checkKeys,\n      serializeFunctions: this.serializeFunctions,\n      ignoreUndefined: this.ignoreUndefined\n    });\n  }\n\n  static getRequestId(): number {\n    _requestId = (_requestId + 1) & 0x7fffffff;\n    return _requestId;\n  }\n}\n\n/** @internal */\nexport class OpMsgResponse {\n  parsed: boolean;\n  raw: Buffer;\n  data: Buffer;\n  opts: BSONSerializeOptions;\n  length: number;\n  requestId: number;\n  responseTo: number;\n  opCode: number;\n  fromCompressed?: boolean;\n  responseFlags: number;\n  checksumPresent: boolean;\n  /** Indicates the server will be sending more responses on this connection */\n  moreToCome: boolean;\n  exhaustAllowed: boolean;\n  useBigInt64: boolean;\n  promoteLongs: boolean;\n  promoteValues: boolean;\n  promoteBuffers: boolean;\n  bsonRegExp: boolean;\n  index = 0;\n  sections: Uint8Array[] = [];\n\n  constructor(\n    message: Buffer,\n    msgHeader: MessageHeader,\n    msgBody: Buffer,\n    opts?: BSONSerializeOptions\n  ) {\n    this.parsed = false;\n    this.raw = message;\n    this.data = msgBody;\n    this.opts = opts ?? {\n      useBigInt64: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: false,\n      bsonRegExp: false\n    };\n\n    // Read the message header\n    this.length = msgHeader.length;\n    this.requestId = msgHeader.requestId;\n    this.responseTo = msgHeader.responseTo;\n    this.opCode = msgHeader.opCode;\n    this.fromCompressed = msgHeader.fromCompressed;\n\n    // Read response flags\n    this.responseFlags = msgBody.readInt32LE(0);\n    this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;\n    this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;\n    this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;\n    this.useBigInt64 = typeof this.opts.useBigInt64 === 'boolean' ? this.opts.useBigInt64 : false;\n    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;\n    this.promoteValues =\n      typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;\n    this.promoteBuffers =\n      typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;\n    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;\n  }\n\n  isParsed(): boolean {\n    return this.parsed;\n  }\n\n  parse(): Uint8Array {\n    // Don't parse again if not needed\n    if (this.parsed) return this.sections[0];\n\n    this.index = 4;\n\n    while (this.index < this.data.length) {\n      const payloadType = this.data.readUInt8(this.index++);\n      if (payloadType === 0) {\n        const bsonSize = this.data.readUInt32LE(this.index);\n        const bin = this.data.subarray(this.index, this.index + bsonSize);\n\n        this.sections.push(bin);\n\n        this.index += bsonSize;\n      } else if (payloadType === 1) {\n        // It was decided that no driver makes use of payload type 1\n\n        // TODO(NODE-3483): Replace with MongoDeprecationError\n        throw new MongoRuntimeError('OP_MSG Payload Type 1 detected unsupported protocol');\n      }\n    }\n\n    this.parsed = true;\n\n    return this.sections[0];\n  }\n}\n\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\n\n/**\n * @internal\n *\n * An OP_COMPRESSED request wraps either an OP_QUERY or OP_MSG message.\n */\nexport class OpCompressedRequest {\n  constructor(\n    private command: WriteProtocolMessageType,\n    private options: { zlibCompressionLevel: number; agreedCompressor: CompressorName }\n  ) {}\n\n  // Return whether a command contains an uncompressible command term\n  // Will return true if command contains no uncompressible command terms\n  static canCompress(command: WriteProtocolMessageType) {\n    const commandDoc = command instanceof OpMsgRequest ? command.command : command.query;\n    const commandName = Object.keys(commandDoc)[0];\n    return !uncompressibleCommands.has(commandName);\n  }\n\n  async toBin(): Promise<Buffer[]> {\n    const concatenatedOriginalCommandBuffer = Buffer.concat(this.command.toBin());\n    // otherwise, compress the message\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n    // Compress the message body\n    const compressedMessage = await compress(this.options, messageToBeCompressed);\n    // Create the msgHeader of OP_COMPRESSED\n    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n    msgHeader.writeInt32LE(\n      MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\n      0\n    ); // messageLength\n    msgHeader.writeInt32LE(this.command.requestId, 4); // requestID\n    msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n    msgHeader.writeInt32LE(OP_COMPRESSED, 12); // opCode\n\n    // Create the compression details of OP_COMPRESSED\n    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n    compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n    compressionDetails.writeUInt8(Compressor[this.options.agreedCompressor], 8); // compressorID\n    return [msgHeader, compressionDetails, compressedMessage];\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1644, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1648, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/wire_protocol/compression.ts"],"sourcesContent":["import { promisify } from 'util';\nimport * as zlib from 'zlib';\n\nimport { LEGACY_HELLO_COMMAND } from '../../constants';\nimport { getSnappy, getZstdLibrary, type SnappyLib, type ZStandard } from '../../deps';\nimport { MongoDecompressionError, MongoInvalidArgumentError } from '../../error';\nimport {\n  type MessageHeader,\n  OpCompressedRequest,\n  OpMsgResponse,\n  OpReply,\n  type WriteProtocolMessageType\n} from '../commands';\nimport { OP_COMPRESSED, OP_MSG } from './constants';\n\n/** @public */\nexport const Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n} as const);\n\n/** @public */\nexport type Compressor = (typeof Compressor)[CompressorName];\n\n/** @public */\nexport type CompressorName = keyof typeof Compressor;\n\nexport const uncompressibleCommands = new Set([\n  LEGACY_HELLO_COMMAND,\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'authenticate',\n  'createUser',\n  'updateUser',\n  'copydbSaslStart',\n  'copydbgetnonce',\n  'copydb'\n]);\n\nconst ZSTD_COMPRESSION_LEVEL = 3;\n\nconst zlibInflate = promisify(zlib.inflate.bind(zlib));\nconst zlibDeflate = promisify(zlib.deflate.bind(zlib));\n\nlet zstd: ZStandard;\nlet Snappy: SnappyLib | null = null;\nfunction loadSnappy() {\n  if (Snappy == null) {\n    const snappyImport = getSnappy();\n    if ('kModuleError' in snappyImport) {\n      throw snappyImport.kModuleError;\n    }\n    Snappy = snappyImport;\n  }\n  return Snappy;\n}\n\n// Facilitate compressing a message using an agreed compressor\nexport async function compress(\n  options: { zlibCompressionLevel: number; agreedCompressor: CompressorName },\n  dataToBeCompressed: Buffer\n): Promise<Buffer> {\n  const zlibOptions = {} as zlib.ZlibOptions;\n  switch (options.agreedCompressor) {\n    case 'snappy': {\n      Snappy ??= loadSnappy();\n      return await Snappy.compress(dataToBeCompressed);\n    }\n    case 'zstd': {\n      loadZstd();\n      if ('kModuleError' in zstd) {\n        throw zstd['kModuleError'];\n      }\n      return await zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);\n    }\n    case 'zlib': {\n      if (options.zlibCompressionLevel) {\n        zlibOptions.level = options.zlibCompressionLevel;\n      }\n      return await zlibDeflate(dataToBeCompressed, zlibOptions);\n    }\n    default: {\n      throw new MongoInvalidArgumentError(\n        `Unknown compressor ${options.agreedCompressor} failed to compress`\n      );\n    }\n  }\n}\n\n// Decompress a message using the given compressor\nexport async function decompress(compressorID: number, compressedData: Buffer): Promise<Buffer> {\n  if (\n    compressorID !== Compressor.snappy &&\n    compressorID !== Compressor.zstd &&\n    compressorID !== Compressor.zlib &&\n    compressorID !== Compressor.none\n  ) {\n    throw new MongoDecompressionError(\n      `Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`\n    );\n  }\n\n  switch (compressorID) {\n    case Compressor.snappy: {\n      Snappy ??= loadSnappy();\n      return await Snappy.uncompress(compressedData, { asBuffer: true });\n    }\n    case Compressor.zstd: {\n      loadZstd();\n      if ('kModuleError' in zstd) {\n        throw zstd['kModuleError'];\n      }\n      return await zstd.decompress(compressedData);\n    }\n    case Compressor.zlib: {\n      return await zlibInflate(compressedData);\n    }\n    default: {\n      return compressedData;\n    }\n  }\n}\n\n/**\n * Load ZStandard if it is not already set.\n */\nfunction loadZstd() {\n  if (!zstd) {\n    zstd = getZstdLibrary();\n  }\n}\n\nconst MESSAGE_HEADER_SIZE = 16;\n\n/**\n * @internal\n *\n * Compresses an OP_MSG or OP_QUERY message, if compression is configured.  This method\n * also serializes the command to BSON.\n */\nexport async function compressCommand(\n  command: WriteProtocolMessageType,\n  description: { agreedCompressor?: CompressorName; zlibCompressionLevel?: number }\n): Promise<Buffer> {\n  const finalCommand =\n    description.agreedCompressor === 'none' || !OpCompressedRequest.canCompress(command)\n      ? command\n      : new OpCompressedRequest(command, {\n          agreedCompressor: description.agreedCompressor ?? 'none',\n          zlibCompressionLevel: description.zlibCompressionLevel ?? 0\n        });\n  const data = await finalCommand.toBin();\n  return Buffer.concat(data);\n}\n\n/**\n * @internal\n *\n * Decompresses an OP_MSG or OP_QUERY response from the server, if compression is configured.\n *\n * This method does not parse the response's BSON.\n */\nexport async function decompressResponse(message: Buffer): Promise<OpMsgResponse | OpReply> {\n  const messageHeader: MessageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const ResponseType = messageHeader.opCode === OP_MSG ? OpMsgResponse : OpReply;\n    const messageBody = message.subarray(MESSAGE_HEADER_SIZE);\n    return new ResponseType(message, messageHeader, messageBody);\n  }\n\n  const header: MessageHeader = {\n    ...messageHeader,\n    fromCompressed: true,\n    opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),\n    length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)\n  };\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n\n  // recalculate based on wrapped opcode\n  const ResponseType = header.opCode === OP_MSG ? OpMsgResponse : OpReply;\n  const messageBody = await decompress(compressorID, compressedBuffer);\n  if (messageBody.length !== header.length) {\n    throw new MongoDecompressionError('Message body and message header must be the same length');\n  }\n  return new ResponseType(message, header, messageBody);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1813, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1817, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/aws_temporary_credentials.ts"],"sourcesContent":["import { type AWSCredentials, getAwsCredentialProvider } from '../../deps';\nimport { MongoAWSError } from '../../error';\nimport { request } from '../../utils';\n\nconst AWS_RELATIVE_URI = 'http://169.254.170.2';\nconst AWS_EC2_URI = 'http://169.254.169.254';\nconst AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';\n\n/**\n * @internal\n * This interface matches the final result of fetching temporary credentials manually, outlined\n * in the spec [here](https://github.com/mongodb/specifications/blob/master/source/auth/auth.md#ec2-endpoint).\n *\n * When we use the AWS SDK, we map the response from the SDK to conform to this interface.\n */\nexport interface AWSTempCredentials {\n  AccessKeyId?: string;\n  SecretAccessKey?: string;\n  Token?: string;\n  RoleArn?: string;\n  Expiration?: Date;\n}\n\n/** @public **/\nexport type AWSCredentialProvider = () => Promise<AWSCredentials>;\n\n/**\n * @internal\n *\n * Fetches temporary AWS credentials.\n */\nexport abstract class AWSTemporaryCredentialProvider {\n  abstract getCredentials(): Promise<AWSTempCredentials>;\n  private static _awsSDK: ReturnType<typeof getAwsCredentialProvider>;\n  protected static get awsSDK() {\n    AWSTemporaryCredentialProvider._awsSDK ??= getAwsCredentialProvider();\n    return AWSTemporaryCredentialProvider._awsSDK;\n  }\n\n  static get isAWSSDKInstalled(): boolean {\n    return !('kModuleError' in AWSTemporaryCredentialProvider.awsSDK);\n  }\n}\n\n/** @internal */\nexport class AWSSDKCredentialProvider extends AWSTemporaryCredentialProvider {\n  private _provider?: AWSCredentialProvider;\n\n  /**\n   * Create the SDK credentials provider.\n   * @param credentialsProvider - The credentials provider.\n   */\n  constructor(credentialsProvider?: AWSCredentialProvider) {\n    super();\n\n    if (credentialsProvider) {\n      this._provider = credentialsProvider;\n    }\n  }\n\n  /**\n   * The AWS SDK caches credentials automatically and handles refresh when the credentials have expired.\n   * To ensure this occurs, we need to cache the `provider` returned by the AWS sdk and re-use it when fetching credentials.\n   */\n  private get provider(): () => Promise<AWSCredentials> {\n    if ('kModuleError' in AWSTemporaryCredentialProvider.awsSDK) {\n      throw AWSTemporaryCredentialProvider.awsSDK.kModuleError;\n    }\n    if (this._provider) {\n      return this._provider;\n    }\n    let { AWS_STS_REGIONAL_ENDPOINTS = '', AWS_REGION = '' } = process.env;\n    AWS_STS_REGIONAL_ENDPOINTS = AWS_STS_REGIONAL_ENDPOINTS.toLowerCase();\n    AWS_REGION = AWS_REGION.toLowerCase();\n\n    /** The option setting should work only for users who have explicit settings in their environment, the driver should not encode \"defaults\" */\n    const awsRegionSettingsExist =\n      AWS_REGION.length !== 0 && AWS_STS_REGIONAL_ENDPOINTS.length !== 0;\n\n    /**\n     * The following regions use the global AWS STS endpoint, sts.amazonaws.com, by default\n     * https://docs.aws.amazon.com/sdkref/latest/guide/feature-sts-regionalized-endpoints.html\n     */\n    const LEGACY_REGIONS = new Set([\n      'ap-northeast-1',\n      'ap-south-1',\n      'ap-southeast-1',\n      'ap-southeast-2',\n      'aws-global',\n      'ca-central-1',\n      'eu-central-1',\n      'eu-north-1',\n      'eu-west-1',\n      'eu-west-2',\n      'eu-west-3',\n      'sa-east-1',\n      'us-east-1',\n      'us-east-2',\n      'us-west-1',\n      'us-west-2'\n    ]);\n    /**\n     * If AWS_STS_REGIONAL_ENDPOINTS is set to regional, users are opting into the new behavior of respecting the region settings\n     *\n     * If AWS_STS_REGIONAL_ENDPOINTS is set to legacy, then \"old\" regions need to keep using the global setting.\n     * Technically the SDK gets this wrong, it reaches out to 'sts.us-east-1.amazonaws.com' when it should be 'sts.amazonaws.com'.\n     * That is not our bug to fix here. We leave that up to the SDK.\n     */\n    const useRegionalSts =\n      AWS_STS_REGIONAL_ENDPOINTS === 'regional' ||\n      (AWS_STS_REGIONAL_ENDPOINTS === 'legacy' && !LEGACY_REGIONS.has(AWS_REGION));\n\n    this._provider =\n      awsRegionSettingsExist && useRegionalSts\n        ? AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain({\n            clientConfig: { region: AWS_REGION }\n          })\n        : AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain();\n\n    return this._provider;\n  }\n\n  override async getCredentials(): Promise<AWSTempCredentials> {\n    /*\n     * Creates a credential provider that will attempt to find credentials from the\n     * following sources (listed in order of precedence):\n     *\n     * - Environment variables exposed via process.env\n     * - SSO credentials from token cache\n     * - Web identity token credentials\n     * - Shared credentials and config ini files\n     * - The EC2/ECS Instance Metadata Service\n     */\n    try {\n      const creds = await this.provider();\n      return {\n        AccessKeyId: creds.accessKeyId,\n        SecretAccessKey: creds.secretAccessKey,\n        Token: creds.sessionToken,\n        Expiration: creds.expiration\n      };\n    } catch (error) {\n      throw new MongoAWSError(error.message, { cause: error });\n    }\n  }\n}\n\n/**\n * @internal\n * Fetches credentials manually (without the AWS SDK), as outlined in the [Obtaining Credentials](https://github.com/mongodb/specifications/blob/master/source/auth/auth.md#obtaining-credentials)\n * section of the Auth spec.\n */\nexport class LegacyAWSTemporaryCredentialProvider extends AWSTemporaryCredentialProvider {\n  override async getCredentials(): Promise<AWSTempCredentials> {\n    // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\n    // is set then drivers MUST assume that it was set by an AWS ECS agent\n    if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {\n      return await request(\n        `${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`\n      );\n    }\n\n    // Otherwise assume we are on an EC2 instance\n\n    // get a token\n    const token = await request(`${AWS_EC2_URI}/latest/api/token`, {\n      method: 'PUT',\n      json: false,\n      headers: { 'X-aws-ec2-metadata-token-ttl-seconds': 30 }\n    });\n\n    // get role name\n    const roleName = await request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {\n      json: false,\n      headers: { 'X-aws-ec2-metadata-token': token }\n    });\n\n    // get temp credentials\n    const creds = await request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {\n      headers: { 'X-aws-ec2-metadata-token': token }\n    });\n\n    return creds;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1964, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1968, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/metrics.ts"],"sourcesContent":["/** @internal */\nexport class ConnectionPoolMetrics {\n  static readonly TXN = 'txn' as const;\n  static readonly CURSOR = 'cursor' as const;\n  static readonly OTHER = 'other' as const;\n\n  txnConnections = 0;\n  cursorConnections = 0;\n  otherConnections = 0;\n\n  /**\n   * Mark a connection as pinned for a specific operation.\n   */\n  markPinned(pinType: string): void {\n    if (pinType === ConnectionPoolMetrics.TXN) {\n      this.txnConnections += 1;\n    } else if (pinType === ConnectionPoolMetrics.CURSOR) {\n      this.cursorConnections += 1;\n    } else {\n      this.otherConnections += 1;\n    }\n  }\n\n  /**\n   * Unmark a connection as pinned for an operation.\n   */\n  markUnpinned(pinType: string): void {\n    if (pinType === ConnectionPoolMetrics.TXN) {\n      this.txnConnections -= 1;\n    } else if (pinType === ConnectionPoolMetrics.CURSOR) {\n      this.cursorConnections -= 1;\n    } else {\n      this.otherConnections -= 1;\n    }\n  }\n\n  /**\n   * Return information about the cmap metrics as a string.\n   */\n  info(maxPoolSize: number): string {\n    return (\n      'Timed out while checking out a connection from connection pool: ' +\n      `maxPoolSize: ${maxPoolSize}, ` +\n      `connections in use by cursors: ${this.cursorConnections}, ` +\n      `connections in use by transactions: ${this.txnConnections}, ` +\n      `connections in use by other operations: ${this.otherConnections}`\n    );\n  }\n\n  /**\n   * Reset the metrics to the initial values.\n   */\n  reset(): void {\n    this.txnConnections = 0;\n    this.cursorConnections = 0;\n    this.otherConnections = 0;\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,cAAA,GACA,MAAa;IAAb,aAAA;QAKE,IAAA,CAAA,cAAc,GAAG;QACjB,IAAA,CAAA,iBAAiB,GAAG;QACpB,IAAA,CAAA,gBAAgB,GAAG;IAiDrB;IA/CE;;QAGA,WAAW,OAAe,EAAA;QACxB,IAAI,YAAY,sBAAsB,GAAG,EAAE;YACzC,IAAI,CAAC,cAAc,IAAI;QACzB,OAAO,IAAI,YAAY,sBAAsB,MAAM,EAAE;YACnD,IAAI,CAAC,iBAAiB,IAAI;QAC5B,OAAO;YACL,IAAI,CAAC,gBAAgB,IAAI;QAC3B;IACF;IAEA;;QAGA,aAAa,OAAe,EAAA;QAC1B,IAAI,YAAY,sBAAsB,GAAG,EAAE;YACzC,IAAI,CAAC,cAAc,IAAI;QACzB,OAAO,IAAI,YAAY,sBAAsB,MAAM,EAAE;YACnD,IAAI,CAAC,iBAAiB,IAAI;QAC5B,OAAO;YACL,IAAI,CAAC,gBAAgB,IAAI;QAC3B;IACF;IAEA;;QAGA,KAAK,WAAmB,EAAA;QACtB,OACE,qEACA,CAAA,aAAA,EAAgB,YAAW,EAAA,CAAI,GAC/B,CAAA,+BAAA,EAAkC,IAAI,CAAC,iBAAiB,CAAA,EAAA,CAAI,GAC5D,CAAA,oCAAA,EAAuC,IAAI,CAAC,cAAc,CAAA,EAAA,CAAI,GAC9D,CAAA,wCAAA,EAA2C,IAAI,CAAC,gBAAgB,CAAA,CAAE;IAEtE;IAEA;;QAGA,QAAK;QACH,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,gBAAgB,GAAG;IAC1B;;AAvDF,QAAA,qBAAA,GAAA;AACkB,sBAAA,GAAG,GAAG;AACN,sBAAA,MAAM,GAAG;AACT,sBAAA,KAAK,GAAG"}},
    {"offset": {"line": 2018, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2022, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/wire_protocol/shared.ts"],"sourcesContent":["import { MongoInvalidArgumentError } from '../../error';\nimport { ReadPreference, type ReadPreferenceLike } from '../../read_preference';\nimport { ServerType } from '../../sdam/common';\nimport type { Server } from '../../sdam/server';\nimport type { ServerDescription } from '../../sdam/server_description';\nimport type { Topology } from '../../sdam/topology';\nimport { TopologyDescription } from '../../sdam/topology_description';\nimport type { Connection } from '../connection';\n\nexport interface ReadPreferenceOption {\n  readPreference?: ReadPreferenceLike;\n}\n\nexport function getReadPreference(options?: ReadPreferenceOption): ReadPreference {\n  // Default to command version of the readPreference.\n  let readPreference = options?.readPreference ?? ReadPreference.primary;\n\n  if (typeof readPreference === 'string') {\n    readPreference = ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof ReadPreference)) {\n    throw new MongoInvalidArgumentError(\n      'Option \"readPreference\" must be a ReadPreference instance'\n    );\n  }\n\n  return readPreference;\n}\n\nexport function isSharded(topologyOrServer?: Topology | Server | Connection): boolean {\n  if (topologyOrServer == null) {\n    return false;\n  }\n\n  if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {\n    return true;\n  }\n\n  // NOTE: This is incredibly inefficient, and should be removed once command construction\n  // happens based on `Server` not `Topology`.\n  if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {\n    const servers: ServerDescription[] = Array.from(topologyOrServer.description.servers.values());\n    return servers.some((server: ServerDescription) => server.type === ServerType.Mongos);\n  }\n\n  return false;\n}\n"],"names":[],"mappings":";;;;AAaA,QAAA,iBAAA,GAAA;AAiBA,QAAA,SAAA,GAAA;AA9BA,MAAA;AACA,MAAA;AACA,MAAA;AAIA,MAAA;AAOA,SAAgB,kBAAkB,OAA8B;IAC9D,oDAAoD;IACpD,IAAI,iBAAiB,SAAS,kBAAkB,kBAAA,cAAc,CAAC,OAAO;IAEtE,IAAI,OAAO,mBAAmB,UAAU;QACtC,iBAAiB,kBAAA,cAAc,CAAC,UAAU,CAAC;IAC7C;IAEA,IAAI,CAAC,CAAC,0BAA0B,kBAAA,cAAc,GAAG;QAC/C,MAAM,IAAI,QAAA,yBAAyB,CACjC;IAEJ;IAEA,OAAO;AACT;AAEA,SAAgB,UAAU,gBAAiD;IACzE,IAAI,oBAAoB,MAAM;QAC5B,OAAO;IACT;IAEA,IAAI,iBAAiB,WAAW,IAAI,iBAAiB,WAAW,CAAC,IAAI,KAAK,SAAA,UAAU,CAAC,MAAM,EAAE;QAC3F,OAAO;IACT;IAEA,wFAAwF;IACxF,4CAA4C;IAC5C,IAAI,iBAAiB,WAAW,IAAI,iBAAiB,WAAW,YAAY,uBAAA,mBAAmB,EAAE;QAC/F,MAAM,UAA+B,MAAM,IAAI,CAAC,iBAAiB,WAAW,CAAC,OAAO,CAAC,MAAM;QAC3F,OAAO,QAAQ,IAAI,CAAC,CAAC,SAA8B,OAAO,IAAI,KAAK,SAAA,UAAU,CAAC,MAAM;IACtF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 2058, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2062, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/command_monitoring_events.ts"],"sourcesContent":["import { type Document, type ObjectId } from '../bson';\nimport {\n  COMMAND_FAILED,\n  COMMAND_STARTED,\n  COMMAND_SUCCEEDED,\n  LEGACY_HELLO_COMMAND,\n  LEGACY_HELLO_COMMAND_CAMEL_CASE\n} from '../constants';\nimport { calculateDurationInMs } from '../utils';\nimport {\n  DocumentSequence,\n  OpMsgRequest,\n  type OpQueryRequest,\n  type WriteProtocolMessageType\n} from './commands';\nimport type { Connection } from './connection';\n\n/**\n * An event indicating the start of a given command\n * @public\n * @category Event\n */\nexport class CommandStartedEvent {\n  commandObj?: Document;\n  requestId: number;\n  databaseName: string;\n  commandName: string;\n  command: Document;\n  address: string;\n  /** Driver generated connection id */\n  connectionId?: string | number;\n  /**\n   * Server generated connection id\n   * Distinct from the connection id and is returned by the hello or legacy hello response as \"connectionId\"\n   * from the server on 4.2+.\n   */\n  serverConnectionId: bigint | null;\n  serviceId?: ObjectId;\n  /** @internal */\n  name = COMMAND_STARTED;\n\n  /**\n   * Create a started event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   */\n  constructor(\n    connection: Connection,\n    command: WriteProtocolMessageType,\n    serverConnectionId: bigint | null\n  ) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n\n    // TODO: remove in major revision, this is not spec behavior\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.databaseName = command.databaseName;\n    this.commandName = commandName;\n    this.command = maybeRedact(commandName, cmd, cmd);\n    this.serverConnectionId = serverConnectionId;\n  }\n\n  /* @internal */\n  get hasServiceId(): boolean {\n    return !!this.serviceId;\n  }\n}\n\n/**\n * An event indicating the success of a given command\n * @public\n * @category Event\n */\nexport class CommandSucceededEvent {\n  address: string;\n  /** Driver generated connection id */\n  connectionId?: string | number;\n  /**\n   * Server generated connection id\n   * Distinct from the connection id and is returned by the hello or legacy hello response as \"connectionId\" from the server on 4.2+.\n   */\n  serverConnectionId: bigint | null;\n  requestId: number;\n  duration: number;\n  commandName: string;\n  reply: unknown;\n  serviceId?: ObjectId;\n  /** @internal */\n  name = COMMAND_SUCCEEDED;\n\n  /**\n   * Create a succeeded event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   * @param reply - the reply for this command from the server\n   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(\n    connection: Connection,\n    command: WriteProtocolMessageType,\n    reply: Document | undefined,\n    started: number,\n    serverConnectionId: bigint | null\n  ) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.commandName = commandName;\n    this.duration = calculateDurationInMs(started);\n    this.reply = maybeRedact(commandName, cmd, extractReply(reply));\n    this.serverConnectionId = serverConnectionId;\n  }\n\n  /* @internal */\n  get hasServiceId(): boolean {\n    return !!this.serviceId;\n  }\n}\n\n/**\n * An event indicating the failure of a given command\n * @public\n * @category Event\n */\nexport class CommandFailedEvent {\n  address: string;\n  /** Driver generated connection id */\n  connectionId?: string | number;\n  /**\n   * Server generated connection id\n   * Distinct from the connection id and is returned by the hello or legacy hello response as \"connectionId\" from the server on 4.2+.\n   */\n  serverConnectionId: bigint | null;\n  requestId: number;\n  duration: number;\n  commandName: string;\n  failure: Error;\n  serviceId?: ObjectId;\n  /** @internal */\n  name = COMMAND_FAILED;\n\n  /**\n   * Create a failure event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   * @param error - the generated error or a server error response\n   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(\n    connection: Connection,\n    command: WriteProtocolMessageType,\n    error: Error | Document,\n    started: number,\n    serverConnectionId: bigint | null\n  ) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n\n    this.requestId = command.requestId;\n    this.commandName = commandName;\n    this.duration = calculateDurationInMs(started);\n    this.failure = maybeRedact(commandName, cmd, error) as Error;\n    this.serverConnectionId = serverConnectionId;\n  }\n\n  /* @internal */\n  get hasServiceId(): boolean {\n    return !!this.serviceId;\n  }\n}\n\n/**\n * Commands that we want to redact because of the sensitive nature of their contents\n * @internal\n */\nexport const SENSITIVE_COMMANDS = new Set([\n  'authenticate',\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'createUser',\n  'updateUser',\n  'copydbgetnonce',\n  'copydbsaslstart',\n  'copydb'\n]);\n\nconst HELLO_COMMANDS = new Set(['hello', LEGACY_HELLO_COMMAND, LEGACY_HELLO_COMMAND_CAMEL_CASE]);\n\n// helper methods\nconst extractCommandName = (commandDoc: Document) => Object.keys(commandDoc)[0];\nconst collectionName = (command: OpQueryRequest) => command.ns.split('.')[1];\nconst maybeRedact = (commandName: string, commandDoc: Document, result: Error | Document) =>\n  SENSITIVE_COMMANDS.has(commandName) ||\n  (HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate)\n    ? {}\n    : result;\n\nconst LEGACY_FIND_QUERY_MAP: { [key: string]: string } = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\n\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldSelector: 'projection'\n} as const;\n\n/** Extract the actual command from the query, possibly up-converting if it's a legacy format */\nfunction extractCommand(command: WriteProtocolMessageType): Document {\n  if (command instanceof OpMsgRequest) {\n    const cmd = { ...command.command };\n    // For OP_MSG with payload type 1 we need to pull the documents\n    // array out of the document sequence for monitoring.\n    if (cmd.ops instanceof DocumentSequence) {\n      cmd.ops = cmd.ops.documents;\n    }\n    if (cmd.nsInfo instanceof DocumentSequence) {\n      cmd.nsInfo = cmd.nsInfo.documents;\n    }\n    return cmd;\n  }\n\n  if (command.query?.$query) {\n    let result: Document;\n    if (command.ns === 'admin.$cmd') {\n      // up-convert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // up-convert legacy find command\n      result = { find: collectionName(command) };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (command.query[key] != null) {\n          result[LEGACY_FIND_QUERY_MAP[key]] = { ...command.query[key] };\n        }\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      const legacyKey = key as keyof typeof LEGACY_FIND_OPTIONS_MAP;\n      if (command[legacyKey] != null) {\n        result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = command[legacyKey];\n      }\n    });\n\n    return result;\n  }\n\n  let clonedQuery: Record<string, unknown> = {};\n  const clonedCommand: Record<string, unknown> = { ...command };\n  if (command.query) {\n    clonedQuery = { ...command.query };\n    clonedCommand.query = clonedQuery;\n  }\n\n  return command.query ? clonedQuery : clonedCommand;\n}\n\nfunction extractReply(reply?: Document) {\n  if (!reply) {\n    return reply;\n  }\n\n  return reply.result ? reply.result : reply;\n}\n\nfunction extractConnectionDetails(connection: Connection) {\n  let connectionId;\n  if ('id' in connection) {\n    connectionId = connection.id;\n  }\n  return {\n    address: connection.address,\n    serviceId: connection.serviceId,\n    connectionId\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2280, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2284, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/stream_description.ts"],"sourcesContent":["import { type Document, type Double, Long } from '../bson';\nimport { ServerType } from '../sdam/common';\nimport { parseServerType } from '../sdam/server_description';\nimport type { CompressorName } from './wire_protocol/compression';\n\nconst RESPONSE_FIELDS = [\n  'minWireVersion',\n  'maxWireVersion',\n  'maxBsonObjectSize',\n  'maxMessageSizeBytes',\n  'maxWriteBatchSize',\n  'logicalSessionTimeoutMinutes'\n] as const;\n\n/** @public */\nexport interface StreamDescriptionOptions {\n  compressors?: CompressorName[];\n  logicalSessionTimeoutMinutes?: number;\n  loadBalanced: boolean;\n}\n\n/** @public */\nexport class StreamDescription {\n  address: string;\n  type: ServerType;\n  minWireVersion?: number;\n  maxWireVersion?: number;\n  maxBsonObjectSize: number;\n  maxMessageSizeBytes: number;\n  maxWriteBatchSize: number;\n  compressors: CompressorName[];\n  compressor?: CompressorName;\n  logicalSessionTimeoutMinutes?: number;\n  loadBalanced: boolean;\n\n  __nodejs_mock_server__?: boolean;\n\n  zlibCompressionLevel?: number;\n  serverConnectionId: bigint | null;\n\n  public hello: Document | null = null;\n\n  constructor(address: string, options?: StreamDescriptionOptions) {\n    this.address = address;\n    this.type = ServerType.Unknown;\n    this.minWireVersion = undefined;\n    this.maxWireVersion = undefined;\n    this.maxBsonObjectSize = 16777216;\n    this.maxMessageSizeBytes = 48000000;\n    this.maxWriteBatchSize = 100000;\n    this.logicalSessionTimeoutMinutes = options?.logicalSessionTimeoutMinutes;\n    this.loadBalanced = !!options?.loadBalanced;\n    this.compressors =\n      options && options.compressors && Array.isArray(options.compressors)\n        ? options.compressors\n        : [];\n    this.serverConnectionId = null;\n  }\n\n  receiveResponse(response: Document | null): void {\n    if (response == null) {\n      return;\n    }\n    this.hello = response;\n    this.type = parseServerType(response);\n    if ('connectionId' in response) {\n      this.serverConnectionId = this.parseServerConnectionID(response.connectionId);\n    } else {\n      this.serverConnectionId = null;\n    }\n    for (const field of RESPONSE_FIELDS) {\n      if (response[field] != null) {\n        this[field] = response[field];\n      }\n\n      // testing case\n      if ('__nodejs_mock_server__' in response) {\n        this.__nodejs_mock_server__ = response['__nodejs_mock_server__'];\n      }\n    }\n\n    if (response.compression) {\n      this.compressor = this.compressors.filter(c => response.compression?.includes(c))[0];\n    }\n  }\n\n  /* @internal */\n  parseServerConnectionID(serverConnectionId: number | Double | bigint | Long): bigint {\n    // Connection ids are always integral, so it's safe to coerce doubles as well as\n    // any integral type.\n    return Long.isLong(serverConnectionId)\n      ? serverConnectionId.toBigInt()\n      : // @ts-expect-error: Doubles are coercible to number\n        BigInt(serverConnectionId);\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AACA,MAAA;AAGA,MAAM,kBAAkB;IACtB;IACA;IACA;IACA;IACA;IACA;CACQ;AASV,YAAA,GACA,MAAa;IAoBX,YAAY,OAAe,EAAE,OAAkC,CAAA;QAFxD,IAAA,CAAA,KAAK,GAAoB;QAG9B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,IAAI,GAAG,SAAA,UAAU,CAAC,OAAO;QAC9B,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,mBAAmB,GAAG;QAC3B,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,4BAA4B,GAAG,SAAS;QAC7C,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,SAAS;QAC/B,IAAI,CAAC,WAAW,GACd,WAAW,QAAQ,WAAW,IAAI,MAAM,OAAO,CAAC,QAAQ,WAAW,IAC/D,QAAQ,WAAW,GACnB,EAAE;QACR,IAAI,CAAC,kBAAkB,GAAG;IAC5B;IAEA,gBAAgB,QAAyB,EAAA;QACvC,IAAI,YAAY,MAAM;YACpB;QACF;QACA,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,IAAI,GAAG,CAAA,GAAA,qBAAA,eAAe,EAAC;QAC5B,IAAI,kBAAkB,UAAU;YAC9B,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,uBAAuB,CAAC,SAAS,YAAY;QAC9E,OAAO;YACL,IAAI,CAAC,kBAAkB,GAAG;QAC5B;QACA,KAAK,MAAM,SAAS,gBAAiB;YACnC,IAAI,QAAQ,CAAC,MAAM,IAAI,MAAM;gBAC3B,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM;YAC/B;YAEA,eAAe;YACf,IAAI,4BAA4B,UAAU;gBACxC,IAAI,CAAC,sBAAsB,GAAG,QAAQ,CAAC,yBAAyB;YAClE;QACF;QAEA,IAAI,SAAS,WAAW,EAAE;YACxB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAA,IAAK,SAAS,WAAW,EAAE,SAAS,GAAG,CAAC,EAAE;QACtF;IACF;IAEA,aAAA,GACA,wBAAwB,kBAAmD,EAAA;QACzE,gFAAgF;QAChF,qBAAqB;QACrB,OAAO,OAAA,IAAI,CAAC,MAAM,CAAC,sBACf,mBAAmB,QAAQ,KAE3B,OAAO;IACb;;AAxEF,QAAA,iBAAA,GAAA"}},
    {"offset": {"line": 2346, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2350, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/wire_protocol/on_data.ts"],"sourcesContent":["import { type EventEmitter } from 'events';\n\nimport { type Abortable } from '../../mongo_types';\nimport { type TimeoutContext } from '../../timeout';\nimport { addAbortListener, kDispose, List, promiseWithResolvers } from '../../utils';\n\n/**\n * @internal\n * An object holding references to a promise's resolve and reject functions.\n */\ntype PendingPromises = Omit<\n  ReturnType<typeof promiseWithResolvers<IteratorResult<Buffer>>>,\n  'promise'\n>;\n\n/**\n * onData is adapted from Node.js' events.on helper\n * https://nodejs.org/api/events.html#eventsonemitter-eventname-options\n *\n * Returns an AsyncIterator that iterates each 'data' event emitted from emitter.\n * It will reject upon an error event.\n */\nexport function onData(\n  emitter: EventEmitter,\n  { timeoutContext, signal }: { timeoutContext?: TimeoutContext } & Abortable\n) {\n  signal?.throwIfAborted();\n\n  // Setup pending events and pending promise lists\n  /**\n   * When the caller has not yet called .next(), we store the\n   * value from the event in this list. Next time they call .next()\n   * we pull the first value out of this list and resolve a promise with it.\n   */\n  const unconsumedEvents = new List<Buffer>();\n  /**\n   * When there has not yet been an event, a new promise will be created\n   * and implicitly stored in this list. When an event occurs we take the first\n   * promise in this list and resolve it.\n   */\n  const unconsumedPromises = new List<PendingPromises>();\n\n  /**\n   * Stored an error created by an error event.\n   * This error will turn into a rejection for the subsequent .next() call\n   */\n  let error: Error | null = null;\n\n  /** Set to true only after event listeners have been removed. */\n  let finished = false;\n\n  const iterator: AsyncGenerator<Buffer> = {\n    next() {\n      // First, we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value != null) {\n        return Promise.resolve({ value, done: false });\n      }\n\n      // Then we error, if an error happened\n      // This happens one time if at all, because after 'error'\n      // we stop listening\n      if (error != null) {\n        const p = Promise.reject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished, resolve to done\n      if (finished) return closeHandler();\n\n      // Wait until an event happens\n      const { promise, resolve, reject } = promiseWithResolvers<IteratorResult<Buffer>>();\n      unconsumedPromises.push({ resolve, reject });\n      return promise;\n    },\n\n    return() {\n      return closeHandler();\n    },\n\n    throw(err: Error) {\n      errorHandler(err);\n      return Promise.resolve({ value: undefined, done: true });\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n\n  // Adding event handlers\n  emitter.on('data', eventHandler);\n  emitter.on('error', errorHandler);\n  const abortListener = addAbortListener(signal, function () {\n    errorHandler(this.reason);\n  });\n\n  const timeoutForSocketRead = timeoutContext?.timeoutForSocketRead;\n  timeoutForSocketRead?.throwIfExpired();\n  timeoutForSocketRead?.then(undefined, errorHandler);\n\n  return iterator;\n\n  function eventHandler(value: Buffer) {\n    const promise = unconsumedPromises.shift();\n    if (promise != null) promise.resolve({ value, done: false });\n    else unconsumedEvents.push(value);\n  }\n\n  function errorHandler(err: Error) {\n    const promise = unconsumedPromises.shift();\n\n    if (promise != null) promise.reject(err);\n    else error = err;\n    void closeHandler();\n  }\n\n  function closeHandler() {\n    // Adding event handlers\n    emitter.off('data', eventHandler);\n    emitter.off('error', errorHandler);\n    abortListener?.[kDispose]();\n    finished = true;\n    timeoutForSocketRead?.clear();\n    const doneResult = { value: undefined, done: finished } as const;\n\n    for (const promise of unconsumedPromises) {\n      promise.resolve(doneResult);\n    }\n\n    return Promise.resolve(doneResult);\n  }\n}\n"],"names":[],"mappings":";;;;AAsBA,QAAA,MAAA,GAAA;AAlBA,MAAA;AAWA;;;;;;IAOA,SAAgB,OACd,OAAqB,EACrB,EAAE,cAAc,EAAE,MAAM,EAAmD;IAE3E,QAAQ;IAER,iDAAiD;IACjD;;;;QAKA,MAAM,mBAAmB,IAAI,QAAA,IAAI;IACjC;;;;QAKA,MAAM,qBAAqB,IAAI,QAAA,IAAI;IAEnC;;;QAIA,IAAI,QAAsB;IAE1B,8DAAA,GACA,IAAI,WAAW;IAEf,MAAM,WAAmC;QACvC;YACE,sCAAsC;YACtC,MAAM,QAAQ,iBAAiB,KAAK;YACpC,IAAI,SAAS,MAAM;gBACjB,OAAO,QAAQ,OAAO,CAAC;oBAAE;oBAAO,MAAM;gBAAK;YAC7C;YAEA,sCAAsC;YACtC,yDAAyD;YACzD,oBAAoB;YACpB,IAAI,SAAS,MAAM;gBACjB,MAAM,IAAI,QAAQ,MAAM,CAAC;gBACzB,gCAAgC;gBAChC,QAAQ;gBACR,OAAO;YACT;YAEA,+CAA+C;YAC/C,IAAI,UAAU,OAAO;YAErB,8BAA8B;YAC9B,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,CAAA,GAAA,QAAA,oBAAoB;YACzD,mBAAmB,IAAI,CAAC;gBAAE;gBAAS;YAAM;YACzC,OAAO;QACT;QAEA;YACE,OAAO;QACT;QAEA,OAAM,GAAU;YACd,aAAa;YACb,OAAO,QAAQ,OAAO,CAAC;gBAAE,OAAO;gBAAW,MAAM;YAAI;QACvD;QAEA,CAAC,OAAO,aAAa,CAAC;YACpB,OAAO,IAAI;QACb;;IAGF,wBAAwB;IACxB,QAAQ,EAAE,CAAC,QAAQ;IACnB,QAAQ,EAAE,CAAC,SAAS;IACpB,MAAM,gBAAgB,CAAA,GAAA,QAAA,gBAAgB,EAAC,QAAQ;QAC7C,aAAa,IAAI,CAAC,MAAM;IAC1B;IAEA,MAAM,uBAAuB,gBAAgB;IAC7C,sBAAsB;IACtB,sBAAsB,KAAK,WAAW;IAEtC,OAAO;IAEP,SAAS,aAAa,KAAa;QACjC,MAAM,UAAU,mBAAmB,KAAK;QACxC,IAAI,WAAW,MAAM,QAAQ,OAAO,CAAC;YAAE;YAAO,MAAM;QAAK;aACpD,iBAAiB,IAAI,CAAC;IAC7B;IAEA,SAAS,aAAa,GAAU;QAC9B,MAAM,UAAU,mBAAmB,KAAK;QAExC,IAAI,WAAW,MAAM,QAAQ,MAAM,CAAC;aAC/B,QAAQ;QACb,KAAK;IACP;IAEA,SAAS;QACP,wBAAwB;QACxB,QAAQ,GAAG,CAAC,QAAQ;QACpB,QAAQ,GAAG,CAAC,SAAS;QACrB,eAAe,CAAC,QAAA,QAAQ,CAAC;QACzB,WAAW;QACX,sBAAsB;QACtB,MAAM,aAAa;YAAE,OAAO;YAAW,MAAM;QAAQ;QAErD,KAAK,MAAM,WAAW,mBAAoB;YACxC,QAAQ,OAAO,CAAC;QAClB;QAEA,OAAO,QAAQ,OAAO,CAAC;IACzB;AACF"}},
    {"offset": {"line": 2464, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2468, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/connection.ts"],"sourcesContent":["import { type Readable, Transform, type TransformCallback } from 'stream';\nimport { clearTimeout, setTimeout } from 'timers';\n\nimport {\n  type BSONSerializeOptions,\n  deserialize,\n  type DeserializeOptions,\n  type Document,\n  type ObjectId\n} from '../bson';\nimport { type AutoEncrypter } from '../client-side-encryption/auto_encrypter';\nimport {\n  CLOSE,\n  CLUSTER_TIME_RECEIVED,\n  COMMAND_FAILED,\n  COMMAND_STARTED,\n  COMMAND_SUCCEEDED,\n  kDecorateResult,\n  PINNED,\n  UNPINNED\n} from '../constants';\nimport {\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoMissingDependencyError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoOperationTimeoutError,\n  MongoParseError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\nimport { type MongoClientAuthProviders } from '../mongo_client_auth_providers';\nimport { MongoLoggableComponent, type MongoLogger, SeverityLevel } from '../mongo_logger';\nimport { type Abortable, type CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport { ServerType } from '../sdam/common';\nimport { applySession, type ClientSession, updateSessionFromResponse } from '../sessions';\nimport { type TimeoutContext, TimeoutError } from '../timeout';\nimport {\n  BufferPool,\n  calculateDurationInMs,\n  type Callback,\n  decorateDecryptionResult,\n  HostAddress,\n  maxWireVersion,\n  type MongoDBNamespace,\n  noop,\n  now,\n  once,\n  squashError,\n  uuidV4\n} from '../utils';\nimport type { WriteConcern } from '../write_concern';\nimport type { AuthContext } from './auth/auth_provider';\nimport type { MongoCredentials } from './auth/mongo_credentials';\nimport {\n  CommandFailedEvent,\n  CommandStartedEvent,\n  CommandSucceededEvent\n} from './command_monitoring_events';\nimport {\n  OpCompressedRequest,\n  OpMsgRequest,\n  type OpMsgResponse,\n  OpQueryRequest,\n  type OpReply,\n  type WriteProtocolMessageType\n} from './commands';\nimport type { Stream } from './connect';\nimport type { ClientMetadata } from './handshake/client_metadata';\nimport { StreamDescription, type StreamDescriptionOptions } from './stream_description';\nimport { type CompressorName, decompressResponse } from './wire_protocol/compression';\nimport { onData } from './wire_protocol/on_data';\nimport {\n  CursorResponse,\n  MongoDBResponse,\n  type MongoDBResponseConstructor\n} from './wire_protocol/responses';\nimport { getReadPreference, isSharded } from './wire_protocol/shared';\n\n/** @internal */\nexport interface CommandOptions extends BSONSerializeOptions {\n  secondaryOk?: boolean;\n  /** Specify read preference if command supports it */\n  readPreference?: ReadPreferenceLike;\n  monitoring?: boolean;\n  socketTimeoutMS?: number;\n  /** Session to use for the operation */\n  session?: ClientSession;\n  documentsReturnedIn?: string;\n  noResponse?: boolean;\n  omitReadPreference?: boolean;\n  omitMaxTimeMS?: boolean;\n\n  // TODO(NODE-2802): Currently the CommandOptions take a property willRetryWrite which is a hint\n  // from executeOperation that the txnNum should be applied to this command.\n  // Applying a session to a command should happen as part of command construction,\n  // most likely in the CommandOperation#executeCommand method, where we have access to\n  // the details we need to determine if a txnNum should also be applied.\n  willRetryWrite?: boolean;\n\n  writeConcern?: WriteConcern;\n\n  directConnection?: boolean;\n\n  /** @internal */\n  timeoutContext?: TimeoutContext;\n}\n\n/** @public */\nexport interface ProxyOptions {\n  proxyHost?: string;\n  proxyPort?: number;\n  proxyUsername?: string;\n  proxyPassword?: string;\n}\n\n/** @public */\nexport interface ConnectionOptions\n  extends SupportedNodeConnectionOptions,\n    StreamDescriptionOptions,\n    ProxyOptions {\n  // Internal creation info\n  id: number | '<monitor>';\n  generation: number;\n  hostAddress: HostAddress;\n  /** @internal */\n  autoEncrypter?: AutoEncrypter;\n  serverApi?: ServerApi;\n  monitorCommands: boolean;\n  /** @internal */\n  connectionType?: any;\n  credentials?: MongoCredentials;\n  /** @internal */\n  authProviders: MongoClientAuthProviders;\n  connectTimeoutMS?: number;\n  tls: boolean;\n  noDelay?: boolean;\n  socketTimeoutMS?: number;\n  cancellationToken?: CancellationToken;\n  metadata: ClientMetadata;\n  /** @internal */\n  extendedMetadata: Promise<Document>;\n  /** @internal */\n  mongoLogger?: MongoLogger | undefined;\n}\n\n/** @public */\nexport type ConnectionEvents = {\n  commandStarted(event: CommandStartedEvent): void;\n  commandSucceeded(event: CommandSucceededEvent): void;\n  commandFailed(event: CommandFailedEvent): void;\n  clusterTimeReceived(clusterTime: Document): void;\n  close(): void;\n  pinned(pinType: string): void;\n  unpinned(pinType: string): void;\n};\n\n/** @internal */\nexport function hasSessionSupport(conn: Connection): boolean {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null;\n}\n\nfunction streamIdentifier(stream: Stream, options: ConnectionOptions): string {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  const { remoteAddress, remotePort } = stream;\n  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\n    return HostAddress.fromHostPort(remoteAddress, remotePort).toString();\n  }\n\n  return uuidV4().toString('hex');\n}\n\n/** @internal */\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\n  public id: number | '<monitor>';\n  public address: string;\n  public lastHelloMS = -1;\n  public serverApi?: ServerApi;\n  public helloOk = false;\n  public authContext?: AuthContext;\n  public delayedTimeoutId: NodeJS.Timeout | null = null;\n  public generation: number;\n  public accessToken?: string;\n  public readonly description: Readonly<StreamDescription>;\n  /**\n   * Represents if the connection has been established:\n   *  - TCP handshake\n   *  - TLS negotiated\n   *  - mongodb handshake (saslStart, saslContinue), includes authentication\n   *\n   * Once connection is established, command logging can log events (if enabled)\n   */\n  public established: boolean;\n  /** Indicates that the connection (including underlying TCP socket) has been closed. */\n  public closed = false;\n\n  private lastUseTime: number;\n  private clusterTime: Document | null = null;\n  private error: Error | null = null;\n  private dataEvents: AsyncGenerator<Buffer, void, void> | null = null;\n\n  private readonly socketTimeoutMS: number;\n  private readonly monitorCommands: boolean;\n  private readonly socket: Stream;\n  private readonly messageStream: Readable;\n\n  /** @event */\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\n  /** @event */\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\n  /** @event */\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\n  /** @event */\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly PINNED = PINNED;\n  /** @event */\n  static readonly UNPINNED = UNPINNED;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super();\n    this.on('error', noop);\n\n    this.socket = stream;\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.mongoLogger = options.mongoLogger;\n    this.established = false;\n\n    this.description = new StreamDescription(this.address, options);\n    this.generation = options.generation;\n    this.lastUseTime = now();\n\n    this.messageStream = this.socket\n      .on('error', this.onSocketError.bind(this))\n      .pipe(new SizedMessageTransform({ connection: this }))\n      .on('error', this.onTransformError.bind(this));\n    this.socket.on('close', this.onClose.bind(this));\n    this.socket.on('timeout', this.onTimeout.bind(this));\n\n    this.messageStream.pause();\n  }\n\n  public get hello() {\n    return this.description.hello;\n  }\n\n  // the `connect` method stores the result of the handshake hello on the connection\n  public set hello(response: Document | null) {\n    this.description.receiveResponse(response);\n    Object.freeze(this.description);\n  }\n\n  public get serviceId(): ObjectId | undefined {\n    return this.hello?.serviceId;\n  }\n\n  public get loadBalanced(): boolean {\n    return this.description.loadBalanced;\n  }\n\n  public get idleTime(): number {\n    return calculateDurationInMs(this.lastUseTime);\n  }\n\n  private get hasSessionSupport(): boolean {\n    return this.description.logicalSessionTimeoutMinutes != null;\n  }\n\n  private get supportsOpMsg(): boolean {\n    return (\n      this.description != null &&\n      maxWireVersion(this) >= 6 &&\n      !this.description.__nodejs_mock_server__\n    );\n  }\n\n  private get shouldEmitAndLogCommand(): boolean {\n    return (\n      (this.monitorCommands ||\n        (this.established &&\n          !this.authContext?.reauthenticating &&\n          this.mongoLogger?.willLog(MongoLoggableComponent.COMMAND, SeverityLevel.DEBUG))) ??\n      false\n    );\n  }\n\n  public markAvailable(): void {\n    this.lastUseTime = now();\n  }\n\n  private onSocketError(cause: Error) {\n    this.onError(new MongoNetworkError(cause.message, { cause }));\n  }\n\n  private onTransformError(error: Error) {\n    this.onError(error);\n  }\n\n  public onError(error: Error) {\n    this.cleanup(error);\n  }\n\n  private onClose() {\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(new MongoNetworkError(message));\n  }\n\n  private onTimeout() {\n    this.delayedTimeoutId = setTimeout(() => {\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      this.cleanup(new MongoNetworkTimeoutError(message, { beforeHandshake }));\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  public destroy(): void {\n    if (this.closed) {\n      return;\n    }\n\n    // load balanced mode requires that these listeners remain on the connection\n    // after cleanup on timeouts, errors or close so we remove them before calling\n    // cleanup.\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(new MongoNetworkError(message));\n  }\n\n  /**\n   * A method that cleans up the connection.  When `force` is true, this method\n   * forcibly destroys the socket.\n   *\n   * If an error is provided, any in-flight operations will be closed with the error.\n   *\n   * This method does nothing if the connection is already closed.\n   */\n  private cleanup(error: Error): void {\n    if (this.closed) {\n      return;\n    }\n\n    this.socket.destroy();\n    this.error = error;\n\n    this.dataEvents?.throw(error).then(undefined, squashError);\n    this.closed = true;\n    this.emit(Connection.CLOSE);\n  }\n\n  private prepareCommand(db: string, command: Document, options: CommandOptions) {\n    let cmd = { ...command };\n\n    const readPreference = getReadPreference(options);\n    const session = options?.session;\n\n    let clusterTime = this.clusterTime;\n\n    if (this.serverApi) {\n      const { version, strict, deprecationErrors } = this.serverApi;\n      cmd.apiVersion = version;\n      if (strict != null) cmd.apiStrict = strict;\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (this.hasSessionSupport && session) {\n      if (\n        session.clusterTime &&\n        clusterTime &&\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n      ) {\n        clusterTime = session.clusterTime;\n      }\n\n      const sessionError = applySession(session, cmd, options);\n      if (sessionError) throw sessionError;\n    } else if (session?.explicit) {\n      throw new MongoCompatibilityError('Current topology does not support sessions');\n    }\n\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      cmd.$clusterTime = clusterTime;\n    }\n\n    // For standalone, drivers MUST NOT set $readPreference.\n    if (this.description.type !== ServerType.Standalone) {\n      if (\n        !isSharded(this) &&\n        !this.description.loadBalanced &&\n        this.supportsOpMsg &&\n        options.directConnection === true &&\n        readPreference?.mode === 'primary'\n      ) {\n        // For mongos and load balancers with 'primary' mode, drivers MUST NOT set $readPreference.\n        // For all other types with a direct connection, if the read preference is 'primary'\n        // (driver sets 'primary' as default if no read preference is configured),\n        // the $readPreference MUST be set to 'primaryPreferred'\n        // to ensure that any server type can handle the request.\n        cmd.$readPreference = ReadPreference.primaryPreferred.toJSON();\n      } else if (isSharded(this) && !this.supportsOpMsg && readPreference?.mode !== 'primary') {\n        // When sending a read operation via OP_QUERY and the $readPreference modifier,\n        // the query MUST be provided using the $query modifier.\n        cmd = {\n          $query: cmd,\n          $readPreference: readPreference.toJSON()\n        };\n      } else if (readPreference?.mode !== 'primary') {\n        // For mode 'primary', drivers MUST NOT set $readPreference.\n        // For all other read preference modes (i.e. 'secondary', 'primaryPreferred', ...),\n        // drivers MUST set $readPreference\n        cmd.$readPreference = readPreference.toJSON();\n      }\n    }\n\n    const commandOptions = {\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk(),\n      ...options\n    };\n\n    options.timeoutContext?.addMaxTimeMSToCommand(cmd, options);\n\n    const message = this.supportsOpMsg\n      ? new OpMsgRequest(db, cmd, commandOptions)\n      : new OpQueryRequest(db, cmd, commandOptions);\n\n    return message;\n  }\n\n  private async *sendWire(\n    message: WriteProtocolMessageType,\n    options: CommandOptions & Abortable,\n    responseType?: MongoDBResponseConstructor\n  ): AsyncGenerator<MongoDBResponse> {\n    this.throwIfAborted();\n\n    const timeout =\n      options.socketTimeoutMS ??\n      options?.timeoutContext?.getSocketTimeoutMS() ??\n      this.socketTimeoutMS;\n    this.socket.setTimeout(timeout);\n\n    try {\n      await this.writeCommand(message, {\n        agreedCompressor: this.description.compressor ?? 'none',\n        zlibCompressionLevel: this.description.zlibCompressionLevel,\n        timeoutContext: options.timeoutContext,\n        signal: options.signal\n      });\n\n      if (options.noResponse || message.moreToCome) {\n        yield MongoDBResponse.empty;\n        return;\n      }\n\n      this.throwIfAborted();\n\n      if (\n        options.timeoutContext?.csotEnabled() &&\n        options.timeoutContext.minRoundTripTime != null &&\n        options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime\n      ) {\n        throw new MongoOperationTimeoutError(\n          'Server roundtrip time is greater than the time remaining'\n        );\n      }\n\n      for await (const response of this.readMany(options)) {\n        this.socket.setTimeout(0);\n        const bson = response.parse();\n\n        const document = (responseType ?? MongoDBResponse).make(bson);\n\n        yield document;\n        this.throwIfAborted();\n\n        this.socket.setTimeout(timeout);\n      }\n    } finally {\n      this.socket.setTimeout(0);\n    }\n  }\n\n  private async *sendCommand(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions & Abortable,\n    responseType?: MongoDBResponseConstructor\n  ) {\n    options?.signal?.throwIfAborted();\n\n    const message = this.prepareCommand(ns.db, command, options);\n    let started = 0;\n    if (this.shouldEmitAndLogCommand) {\n      started = now();\n      this.emitAndLogCommand(\n        this.monitorCommands,\n        Connection.COMMAND_STARTED,\n        message.databaseName,\n        this.established,\n        new CommandStartedEvent(this, message, this.description.serverConnectionId)\n      );\n    }\n\n    // If `documentsReturnedIn` not set or raw is not enabled, use input bson options\n    // Otherwise, support raw flag. Raw only works for cursors that hardcode firstBatch/nextBatch fields\n    const bsonOptions: DeserializeOptions =\n      options.documentsReturnedIn == null || !options.raw\n        ? options\n        : {\n            ...options,\n            raw: false,\n            fieldsAsRaw: { [options.documentsReturnedIn]: true }\n          };\n\n    /** MongoDBResponse instance or subclass */\n    let document: MongoDBResponse | undefined = undefined;\n    /** Cached result of a toObject call */\n    let object: Document | undefined = undefined;\n    try {\n      this.throwIfAborted();\n      for await (document of this.sendWire(message, options, responseType)) {\n        object = undefined;\n        if (options.session != null) {\n          updateSessionFromResponse(options.session, document);\n        }\n\n        if (document.$clusterTime) {\n          this.clusterTime = document.$clusterTime;\n          this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n        }\n\n        if (document.ok === 0) {\n          if (options.timeoutContext?.csotEnabled() && document.isMaxTimeExpiredError) {\n            throw new MongoOperationTimeoutError('Server reported a timeout error', {\n              cause: new MongoServerError((object ??= document.toObject(bsonOptions)))\n            });\n          }\n          throw new MongoServerError((object ??= document.toObject(bsonOptions)));\n        }\n\n        if (this.shouldEmitAndLogCommand) {\n          this.emitAndLogCommand(\n            this.monitorCommands,\n            Connection.COMMAND_SUCCEEDED,\n            message.databaseName,\n            this.established,\n            new CommandSucceededEvent(\n              this,\n              message,\n              options.noResponse\n                ? undefined\n                : message.moreToCome\n                  ? { ok: 1 }\n                  : (object ??= document.toObject(bsonOptions)),\n              started,\n              this.description.serverConnectionId\n            )\n          );\n        }\n\n        if (responseType == null) {\n          yield (object ??= document.toObject(bsonOptions));\n        } else {\n          yield document;\n        }\n\n        this.throwIfAborted();\n      }\n    } catch (error) {\n      if (this.shouldEmitAndLogCommand) {\n        this.emitAndLogCommand(\n          this.monitorCommands,\n          Connection.COMMAND_FAILED,\n          message.databaseName,\n          this.established,\n          new CommandFailedEvent(this, message, error, started, this.description.serverConnectionId)\n        );\n      }\n      throw error;\n    }\n  }\n\n  public async command<T extends MongoDBResponseConstructor>(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions | undefined,\n    responseType: T\n  ): Promise<InstanceType<T>>;\n\n  public async command<T extends MongoDBResponseConstructor>(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions | undefined,\n    responseType: T | undefined\n  ): Promise<typeof responseType extends undefined ? Document : InstanceType<T>>;\n\n  public async command(\n    ns: MongoDBNamespace,\n    command: Document,\n    options?: CommandOptions\n  ): Promise<Document>;\n\n  public async command(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions & Abortable = {},\n    responseType?: MongoDBResponseConstructor\n  ): Promise<Document> {\n    this.throwIfAborted();\n    options.signal?.throwIfAborted();\n\n    for await (const document of this.sendCommand(ns, command, options, responseType)) {\n      if (options.timeoutContext?.csotEnabled()) {\n        if (MongoDBResponse.is(document)) {\n          if (document.isMaxTimeExpiredError) {\n            throw new MongoOperationTimeoutError('Server reported a timeout error', {\n              cause: new MongoServerError(document.toObject())\n            });\n          }\n        } else {\n          if (\n            (Array.isArray(document?.writeErrors) &&\n              document.writeErrors.some(\n                error => error?.code === MONGODB_ERROR_CODES.MaxTimeMSExpired\n              )) ||\n            document?.writeConcernError?.code === MONGODB_ERROR_CODES.MaxTimeMSExpired\n          ) {\n            throw new MongoOperationTimeoutError('Server reported a timeout error', {\n              cause: new MongoServerError(document)\n            });\n          }\n        }\n      }\n\n      return document;\n    }\n    throw new MongoUnexpectedServerResponseError('Unable to get response from server');\n  }\n\n  public exhaustCommand(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions,\n    replyListener: Callback\n  ) {\n    const exhaustLoop = async () => {\n      this.throwIfAborted();\n      for await (const reply of this.sendCommand(ns, command, options)) {\n        replyListener(undefined, reply);\n        this.throwIfAborted();\n      }\n      throw new MongoUnexpectedServerResponseError('Server ended moreToCome unexpectedly');\n    };\n\n    exhaustLoop().then(undefined, replyListener);\n  }\n\n  private throwIfAborted() {\n    if (this.error) throw this.error;\n  }\n\n  /**\n   * @internal\n   *\n   * Writes an OP_MSG or OP_QUERY request to the socket, optionally compressing the command. This method\n   * waits until the socket's buffer has emptied (the Nodejs socket `drain` event has fired).\n   */\n  private async writeCommand(\n    command: WriteProtocolMessageType,\n    options: {\n      agreedCompressor?: CompressorName;\n      zlibCompressionLevel?: number;\n      timeoutContext?: TimeoutContext;\n    } & Abortable\n  ): Promise<void> {\n    const finalCommand =\n      options.agreedCompressor === 'none' || !OpCompressedRequest.canCompress(command)\n        ? command\n        : new OpCompressedRequest(command, {\n            agreedCompressor: options.agreedCompressor ?? 'none',\n            zlibCompressionLevel: options.zlibCompressionLevel ?? 0\n          });\n\n    const buffer = Buffer.concat(await finalCommand.toBin());\n\n    if (options.timeoutContext?.csotEnabled()) {\n      if (\n        options.timeoutContext.minRoundTripTime != null &&\n        options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime\n      ) {\n        throw new MongoOperationTimeoutError(\n          'Server roundtrip time is greater than the time remaining'\n        );\n      }\n    }\n\n    if (this.socket.write(buffer)) return;\n\n    const drainEvent = once<void>(this.socket, 'drain', options);\n    const timeout = options?.timeoutContext?.timeoutForSocketWrite;\n    const drained = timeout ? Promise.race([drainEvent, timeout]) : drainEvent;\n    try {\n      return await drained;\n    } catch (writeError) {\n      if (TimeoutError.is(writeError)) {\n        const timeoutError = new MongoOperationTimeoutError('Timed out at socket write');\n        this.onError(timeoutError);\n        throw timeoutError;\n      } else if (writeError === options.signal?.reason) {\n        this.onError(writeError);\n      }\n      throw writeError;\n    } finally {\n      timeout?.clear();\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Returns an async generator that yields full wire protocol messages from the underlying socket.  This function\n   * yields messages until `moreToCome` is false or not present in a response, or the caller cancels the request\n   * by calling `return` on the generator.\n   *\n   * Note that `for-await` loops call `return` automatically when the loop is exited.\n   */\n  private async *readMany(\n    options: {\n      timeoutContext?: TimeoutContext;\n    } & Abortable\n  ): AsyncGenerator<OpMsgResponse | OpReply> {\n    try {\n      this.dataEvents = onData(this.messageStream, options);\n      this.messageStream.resume();\n\n      for await (const message of this.dataEvents) {\n        const response = await decompressResponse(message);\n        yield response;\n\n        if (!response.moreToCome) {\n          return;\n        }\n      }\n    } catch (readError) {\n      if (TimeoutError.is(readError)) {\n        const timeoutError = new MongoOperationTimeoutError(\n          `Timed out during socket read (${readError.duration}ms)`\n        );\n        this.dataEvents = null;\n        this.onError(timeoutError);\n        throw timeoutError;\n      } else if (readError === options.signal?.reason) {\n        this.onError(readError);\n      }\n      throw readError;\n    } finally {\n      this.dataEvents = null;\n      this.messageStream.pause();\n    }\n  }\n}\n\n/** @internal */\nexport class SizedMessageTransform extends Transform {\n  bufferPool: BufferPool;\n  connection: Connection;\n\n  constructor({ connection }: { connection: Connection }) {\n    super({ writableObjectMode: false, readableObjectMode: true });\n    this.bufferPool = new BufferPool();\n    this.connection = connection;\n  }\n\n  override _transform(chunk: Buffer, encoding: unknown, callback: TransformCallback): void {\n    if (this.connection.delayedTimeoutId != null) {\n      clearTimeout(this.connection.delayedTimeoutId);\n      this.connection.delayedTimeoutId = null;\n    }\n\n    this.bufferPool.append(chunk);\n\n    while (this.bufferPool.length) {\n      // While there are any bytes in the buffer\n\n      // Try to fetch a size from the top 4 bytes\n      const sizeOfMessage = this.bufferPool.getInt32();\n\n      if (sizeOfMessage == null) {\n        // Not even an int32 worth of data. Stop the loop, we need more chunks.\n        break;\n      }\n\n      if (sizeOfMessage < 0) {\n        // The size in the message has a negative value, this is probably corruption, throw:\n        return callback(new MongoParseError(`Message size cannot be negative: ${sizeOfMessage}`));\n      }\n\n      if (sizeOfMessage > this.bufferPool.length) {\n        // We do not have enough bytes to make a sizeOfMessage chunk\n        break;\n      }\n\n      // Add a message to the stream\n      const message = this.bufferPool.read(sizeOfMessage);\n\n      if (!this.push(message)) {\n        // We only subscribe to data events so we should never get backpressure\n        // if we do, we do not have the handling for it.\n        return callback(\n          new MongoRuntimeError(`SizedMessageTransform does not support backpressure`)\n        );\n      }\n    }\n\n    callback();\n  }\n}\n\n/** @internal */\nexport class CryptoConnection extends Connection {\n  /** @internal */\n  autoEncrypter?: AutoEncrypter;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super(stream, options);\n    this.autoEncrypter = options.autoEncrypter;\n  }\n\n  public override async command<T extends MongoDBResponseConstructor>(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions | undefined,\n    responseType: T\n  ): Promise<InstanceType<T>>;\n\n  public override async command(\n    ns: MongoDBNamespace,\n    command: Document,\n    options?: CommandOptions\n  ): Promise<Document>;\n\n  override async command<T extends MongoDBResponseConstructor>(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options?: CommandOptions,\n    responseType?: T\n  ): Promise<Document> {\n    const { autoEncrypter } = this;\n    if (!autoEncrypter) {\n      // TODO(NODE-6065): throw a MongoRuntimeError in Node V7\n      // @ts-expect-error No cause provided because there is no underlying error.\n      throw new MongoMissingDependencyError('No AutoEncrypter available for encryption', {\n        dependencyName: 'n/a'\n      });\n    }\n\n    const serverWireVersion = maxWireVersion(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return await super.command<T>(ns, cmd, options, responseType);\n    }\n\n    if (serverWireVersion < 8) {\n      throw new MongoCompatibilityError(\n        'Auto-encryption requires a minimum MongoDB version of 4.2'\n      );\n    }\n\n    // Save sort or indexKeys based on the command being run\n    // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n    // and then deserializes the encrypted result, the protocol level components\n    // of the command (ex. sort) are then converted to JS objects potentially losing\n    // import key order information. These fields are never encrypted so we can save the values\n    // from before the encryption and replace them after encryption has been performed\n    const sort: Map<string, number> | null = cmd.find || cmd.findAndModify ? cmd.sort : null;\n    const indexKeys: Map<string, number>[] | null = cmd.createIndexes\n      ? cmd.indexes.map((index: { key: Map<string, number> }) => index.key)\n      : null;\n\n    const encrypted = await autoEncrypter.encrypt(ns.toString(), cmd, options);\n\n    // Replace the saved values\n    if (sort != null && (cmd.find || cmd.findAndModify)) {\n      encrypted.sort = sort;\n    }\n\n    if (indexKeys != null && cmd.createIndexes) {\n      for (const [offset, index] of indexKeys.entries()) {\n        // @ts-expect-error `encrypted` is a generic \"command\", but we've narrowed for only `createIndexes` commands here\n        encrypted.indexes[offset].key = index;\n      }\n    }\n\n    const encryptedResponse = await super.command(\n      ns,\n      encrypted,\n      options,\n      // Eventually we want to require `responseType` which means we would satisfy `T` as the return type.\n      // In the meantime, we want encryptedResponse to always be _at least_ a MongoDBResponse if not a more specific subclass\n      // So that we can ensure we have access to the on-demand APIs for decorate response\n      responseType ?? MongoDBResponse\n    );\n\n    const result = await autoEncrypter.decrypt(encryptedResponse.toBytes(), options);\n\n    const decryptedResponse = responseType?.make(result) ?? deserialize(result, options);\n\n    if (autoEncrypter[kDecorateResult]) {\n      if (responseType == null) {\n        decorateDecryptionResult(decryptedResponse, encryptedResponse.toObject(), true);\n      } else if (decryptedResponse instanceof CursorResponse) {\n        decryptedResponse.encryptedResponse = encryptedResponse;\n      }\n    }\n\n    return decryptedResponse;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2986, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2990, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/connect.ts"],"sourcesContent":["import type { Socket, SocketConnectOpts } from 'net';\nimport * as net from 'net';\nimport type { ConnectionOptions as TLSConnectionOpts, TLSSocket } from 'tls';\nimport * as tls from 'tls';\n\nimport type { Document } from '../bson';\nimport { LEGACY_HELLO_COMMAND } from '../constants';\nimport { getSocks, type SocksLib } from '../deps';\nimport {\n  MongoCompatibilityError,\n  MongoError,\n  MongoErrorLabel,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  needsRetryableWriteLabel\n} from '../error';\nimport { HostAddress, ns, promiseWithResolvers } from '../utils';\nimport { AuthContext } from './auth/auth_provider';\nimport { AuthMechanism } from './auth/providers';\nimport {\n  type CommandOptions,\n  Connection,\n  type ConnectionOptions,\n  CryptoConnection\n} from './connection';\nimport {\n  MAX_SUPPORTED_SERVER_VERSION,\n  MAX_SUPPORTED_WIRE_VERSION,\n  MIN_SUPPORTED_SERVER_VERSION,\n  MIN_SUPPORTED_WIRE_VERSION\n} from './wire_protocol/constants';\n\n/** @public */\nexport type Stream = Socket | TLSSocket;\n\nexport async function connect(options: ConnectionOptions): Promise<Connection> {\n  let connection: Connection | null = null;\n  try {\n    const socket = await makeSocket(options);\n    connection = makeConnection(options, socket);\n    await performInitialHandshake(connection, options);\n    return connection;\n  } catch (error) {\n    connection?.destroy();\n    throw error;\n  }\n}\n\nexport function makeConnection(options: ConnectionOptions, socket: Stream): Connection {\n  let ConnectionType = options.connectionType ?? Connection;\n  if (options.autoEncrypter) {\n    ConnectionType = CryptoConnection;\n  }\n\n  return new ConnectionType(socket, options);\n}\n\nfunction checkSupportedServer(hello: Document, options: ConnectionOptions) {\n  const maxWireVersion = Number(hello.maxWireVersion);\n  const minWireVersion = Number(hello.minWireVersion);\n  const serverVersionHighEnough =\n    !Number.isNaN(maxWireVersion) && maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    !Number.isNaN(minWireVersion) && minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(\n      hello.minWireVersion\n    )}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${\n    JSON.stringify(hello.maxWireVersion) ?? 0\n  }, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoCompatibilityError(message);\n}\n\nexport async function performInitialHandshake(\n  conn: Connection,\n  options: ConnectionOptions\n): Promise<void> {\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (\n      !(credentials.mechanism === AuthMechanism.MONGODB_DEFAULT) &&\n      !options.authProviders.getOrCreateProvider(\n        credentials.mechanism,\n        credentials.mechanismProperties\n      )\n    ) {\n      throw new MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  conn.authContext = authContext;\n\n  const handshakeDoc = await prepareHandshakeDocument(authContext);\n\n  // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options\n  const handshakeOptions: CommandOptions = { ...options, raw: false };\n  if (typeof options.connectTimeoutMS === 'number') {\n    // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n    handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n  }\n\n  const start = new Date().getTime();\n\n  const response = await executeHandshake(handshakeDoc, handshakeOptions);\n\n  if (!('isWritablePrimary' in response)) {\n    // Provide hello-style response document.\n    response.isWritablePrimary = response[LEGACY_HELLO_COMMAND];\n  }\n\n  if (response.helloOk) {\n    conn.helloOk = true;\n  }\n\n  const supportedServerErr = checkSupportedServer(response, options);\n  if (supportedServerErr) {\n    throw supportedServerErr;\n  }\n\n  if (options.loadBalanced) {\n    if (!response.serviceId) {\n      throw new MongoCompatibilityError(\n        'Driver attempted to initialize in load balancing mode, ' +\n          'but the server does not support this mode.'\n      );\n    }\n  }\n\n  // NOTE: This is metadata attached to the connection while porting away from\n  //       handshake being done in the `Server` class. Likely, it should be\n  //       relocated, or at very least restructured.\n  conn.hello = response;\n  conn.lastHelloMS = new Date().getTime() - start;\n\n  if (!response.arbiterOnly && credentials) {\n    // store the response on auth context\n    authContext.response = response;\n\n    const resolvedCredentials = credentials.resolveAuthMechanism(response);\n    const provider = options.authProviders.getOrCreateProvider(\n      resolvedCredentials.mechanism,\n      resolvedCredentials.mechanismProperties\n    );\n    if (!provider) {\n      throw new MongoInvalidArgumentError(\n        `No AuthProvider for ${resolvedCredentials.mechanism} defined.`\n      );\n    }\n\n    try {\n      await provider.auth(authContext);\n    } catch (error) {\n      if (error instanceof MongoError) {\n        error.addErrorLabel(MongoErrorLabel.HandshakeError);\n        if (needsRetryableWriteLabel(error, response.maxWireVersion, conn.description.type)) {\n          error.addErrorLabel(MongoErrorLabel.RetryableWriteError);\n        }\n      }\n      throw error;\n    }\n  }\n\n  // Connection establishment is socket creation (tcp handshake, tls handshake, MongoDB handshake (saslStart, saslContinue))\n  // Once connection is established, command logging can log events (if enabled)\n  conn.established = true;\n\n  async function executeHandshake(handshakeDoc: Document, handshakeOptions: CommandOptions) {\n    try {\n      const handshakeResponse = await conn.command(\n        ns('admin.$cmd'),\n        handshakeDoc,\n        handshakeOptions\n      );\n      return handshakeResponse;\n    } catch (error) {\n      if (error instanceof MongoError) {\n        error.addErrorLabel(MongoErrorLabel.HandshakeError);\n      }\n      throw error;\n    }\n  }\n}\n\n/**\n * HandshakeDocument used during authentication.\n * @internal\n */\nexport interface HandshakeDocument extends Document {\n  /**\n   * @deprecated Use hello instead\n   */\n  ismaster?: boolean;\n  hello?: boolean;\n  helloOk?: boolean;\n  client: Document;\n  compression: string[];\n  saslSupportedMechs?: string;\n  loadBalanced?: boolean;\n}\n\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\nexport async function prepareHandshakeDocument(\n  authContext: AuthContext\n): Promise<HandshakeDocument> {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const { serverApi } = authContext.connection;\n  const clientMetadata: Document = await options.extendedMetadata;\n\n  const handshakeDoc: HandshakeDocument = {\n    [serverApi?.version || options.loadBalanced === true ? 'hello' : LEGACY_HELLO_COMMAND]: 1,\n    helloOk: true,\n    client: clientMetadata,\n    compression: compressors\n  };\n\n  if (options.loadBalanced === true) {\n    handshakeDoc.loadBalanced = true;\n  }\n\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n\n      const provider = authContext.options.authProviders.getOrCreateProvider(\n        AuthMechanism.MONGODB_SCRAM_SHA256,\n        credentials.mechanismProperties\n      );\n      if (!provider) {\n        // This auth mechanism is always present.\n        throw new MongoInvalidArgumentError(\n          `No AuthProvider for ${AuthMechanism.MONGODB_SCRAM_SHA256} defined.`\n        );\n      }\n      return await provider.prepare(handshakeDoc, authContext);\n    }\n    const provider = authContext.options.authProviders.getOrCreateProvider(\n      credentials.mechanism,\n      credentials.mechanismProperties\n    );\n    if (!provider) {\n      throw new MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);\n    }\n    return await provider.prepare(handshakeDoc, authContext);\n  }\n  return handshakeDoc;\n}\n\n/** @public */\nexport const LEGAL_TLS_SOCKET_OPTIONS = [\n  'allowPartialTrustChain',\n  'ALPNProtocols',\n  'ca',\n  'cert',\n  'checkServerIdentity',\n  'ciphers',\n  'crl',\n  'ecdhCurve',\n  'key',\n  'minDHSize',\n  'passphrase',\n  'pfx',\n  'rejectUnauthorized',\n  'secureContext',\n  'secureProtocol',\n  'servername',\n  'session'\n] as const;\n\n/** @public */\nexport const LEGAL_TCP_SOCKET_OPTIONS = [\n  'autoSelectFamily',\n  'autoSelectFamilyAttemptTimeout',\n  'keepAliveInitialDelay',\n  'family',\n  'hints',\n  'localAddress',\n  'localPort',\n  'lookup'\n] as const;\n\nfunction parseConnectOptions(options: ConnectionOptions): SocketConnectOpts {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new MongoInvalidArgumentError('Option \"hostAddress\" is required');\n\n  const result: Partial<net.TcpNetConnectOpts & net.IpcNetConnectOpts> = {};\n  for (const name of LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n  result.keepAliveInitialDelay ??= 120000;\n  result.keepAlive = true;\n  result.noDelay = options.noDelay ?? true;\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result as net.IpcNetConnectOpts;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result as net.TcpNetConnectOpts;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\ntype MakeConnectionOptions = ConnectionOptions & { existingSocket?: Stream };\n\nfunction parseSslOptions(options: MakeConnectionOptions): TLSConnectionOpts {\n  const result: TLSConnectionOpts = parseConnectOptions(options);\n  // Merge in valid SSL options\n  for (const name of LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nexport async function makeSocket(options: MakeConnectionOptions): Promise<Stream> {\n  const useTLS = options.tls ?? false;\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\n  const existingSocket = options.existingSocket;\n\n  let socket: Stream;\n\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return await makeSocks5Connection({\n      ...options,\n      connectTimeoutMS // Should always be present for Socks5\n    });\n  }\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setTimeout(connectTimeoutMS);\n\n  let cancellationHandler: ((err: Error) => void) | null = null;\n\n  const { promise: connectedSocket, resolve, reject } = promiseWithResolvers<Stream>();\n  if (existingSocket) {\n    resolve(socket);\n  } else {\n    const start = performance.now();\n    const connectEvent = useTLS ? 'secureConnect' : 'connect';\n    socket\n      .once(connectEvent, () => resolve(socket))\n      .once('error', cause =>\n        reject(new MongoNetworkError(MongoError.buildErrorMessage(cause), { cause }))\n      )\n      .once('timeout', () => {\n        reject(\n          new MongoNetworkTimeoutError(\n            `Socket '${connectEvent}' timed out after ${(performance.now() - start) | 0}ms (connectTimeoutMS: ${connectTimeoutMS})`\n          )\n        );\n      })\n      .once('close', () =>\n        reject(\n          new MongoNetworkError(\n            `Socket closed after ${(performance.now() - start) | 0} during connection establishment`\n          )\n        )\n      );\n\n    if (options.cancellationToken != null) {\n      cancellationHandler = () =>\n        reject(\n          new MongoNetworkError(\n            `Socket connection establishment was cancelled after ${(performance.now() - start) | 0}`\n          )\n        );\n      options.cancellationToken.once('cancel', cancellationHandler);\n    }\n  }\n\n  try {\n    socket = await connectedSocket;\n    return socket;\n  } catch (error) {\n    socket.destroy();\n    throw error;\n  } finally {\n    socket.setTimeout(0);\n    if (cancellationHandler != null) {\n      options.cancellationToken?.removeListener('cancel', cancellationHandler);\n    }\n  }\n}\n\nlet socks: SocksLib | null = null;\nfunction loadSocks() {\n  if (socks == null) {\n    const socksImport = getSocks();\n    if ('kModuleError' in socksImport) {\n      throw socksImport.kModuleError;\n    }\n    socks = socksImport;\n  }\n  return socks;\n}\n\nasync function makeSocks5Connection(options: MakeConnectionOptions): Promise<Stream> {\n  const hostAddress = HostAddress.fromHostPort(\n    options.proxyHost ?? '', // proxyHost is guaranteed to set here\n    options.proxyPort ?? 1080\n  );\n\n  // First, connect to the proxy server itself:\n  const rawSocket = await makeSocket({\n    ...options,\n    hostAddress,\n    tls: false,\n    proxyHost: undefined\n  });\n\n  const destination = parseConnectOptions(options) as net.TcpNetConnectOpts;\n  if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n    throw new MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts');\n  }\n\n  socks ??= loadSocks();\n\n  let existingSocket: Stream;\n\n  try {\n    // Then, establish the Socks5 proxy connection:\n    const connection = await socks.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    });\n    existingSocket = connection.socket;\n  } catch (cause) {\n    throw new MongoNetworkError(MongoError.buildErrorMessage(cause), { cause });\n  }\n\n  // Finally, now treat the resulting duplex stream as the\n  // socket over which we send and receive wire protocol messages:\n  return await makeSocket({ ...options, existingSocket, proxyHost: undefined });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3346, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3350, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/connection_pool_events.ts"],"sourcesContent":["import type { ObjectId } from '../bson';\nimport {\n  CONNECTION_CHECK_OUT_FAILED,\n  CONNECTION_CHECK_OUT_STARTED,\n  CONNECTION_CHECKED_IN,\n  CONNECTION_CHECKED_OUT,\n  CONNECTION_CLOSED,\n  CONNECTION_CREATED,\n  CONNECTION_POOL_CLEARED,\n  CONNECTION_POOL_CLOSED,\n  CONNECTION_POOL_CREATED,\n  CONNECTION_POOL_READY,\n  CONNECTION_READY\n} from '../constants';\nimport type { MongoError } from '../error';\nimport { now } from '../utils';\nimport type { Connection } from './connection';\nimport type { ConnectionPool, ConnectionPoolOptions } from './connection_pool';\n\n/**\n * The base export class for all monitoring events published from the connection pool\n * @public\n * @category Event\n */\nexport abstract class ConnectionPoolMonitoringEvent {\n  /** A timestamp when the event was created  */\n  time: Date;\n  /** The address (host/port pair) of the pool */\n  address: string;\n  /** @internal */\n  abstract name:\n    | typeof CONNECTION_CHECK_OUT_FAILED\n    | typeof CONNECTION_CHECK_OUT_STARTED\n    | typeof CONNECTION_CHECKED_IN\n    | typeof CONNECTION_CHECKED_OUT\n    | typeof CONNECTION_CLOSED\n    | typeof CONNECTION_CREATED\n    | typeof CONNECTION_POOL_CLEARED\n    | typeof CONNECTION_POOL_CLOSED\n    | typeof CONNECTION_POOL_CREATED\n    | typeof CONNECTION_POOL_READY\n    | typeof CONNECTION_READY;\n\n  /** @internal */\n  constructor(pool: ConnectionPool) {\n    this.time = new Date();\n    this.address = pool.address;\n  }\n}\n\n/**\n * An event published when a connection pool is created\n * @public\n * @category Event\n */\nexport class ConnectionPoolCreatedEvent extends ConnectionPoolMonitoringEvent {\n  /** The options used to create this connection pool */\n  options: Pick<\n    ConnectionPoolOptions,\n    'maxPoolSize' | 'minPoolSize' | 'maxConnecting' | 'maxIdleTimeMS' | 'waitQueueTimeoutMS'\n  >;\n  /** @internal */\n  name = CONNECTION_POOL_CREATED;\n\n  /** @internal */\n  constructor(pool: ConnectionPool) {\n    super(pool);\n    const { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS } =\n      pool.options;\n    this.options = { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS };\n  }\n}\n\n/**\n * An event published when a connection pool is ready\n * @public\n * @category Event\n */\nexport class ConnectionPoolReadyEvent extends ConnectionPoolMonitoringEvent {\n  /** @internal */\n  name = CONNECTION_POOL_READY;\n\n  /** @internal */\n  constructor(pool: ConnectionPool) {\n    super(pool);\n  }\n}\n\n/**\n * An event published when a connection pool is closed\n * @public\n * @category Event\n */\nexport class ConnectionPoolClosedEvent extends ConnectionPoolMonitoringEvent {\n  /** @internal */\n  name = CONNECTION_POOL_CLOSED;\n\n  /** @internal */\n  constructor(pool: ConnectionPool) {\n    super(pool);\n  }\n}\n\n/**\n * An event published when a connection pool creates a new connection\n * @public\n * @category Event\n */\nexport class ConnectionCreatedEvent extends ConnectionPoolMonitoringEvent {\n  /** A monotonically increasing, per-pool id for the newly created connection */\n  connectionId: number | '<monitor>';\n  /** @internal */\n  name = CONNECTION_CREATED;\n\n  /** @internal */\n  constructor(pool: ConnectionPool, connection: { id: number | '<monitor>' }) {\n    super(pool);\n    this.connectionId = connection.id;\n  }\n}\n\n/**\n * An event published when a connection is ready for use\n * @public\n * @category Event\n */\nexport class ConnectionReadyEvent extends ConnectionPoolMonitoringEvent {\n  /** The id of the connection */\n  connectionId: number | '<monitor>';\n  /**\n   * The time it took to establish the connection.\n   * In accordance with the definition of establishment of a connection\n   * specified by `ConnectionPoolOptions.maxConnecting`,\n   * it is the time elapsed between emitting a `ConnectionCreatedEvent`\n   * and emitting this event as part of the same checking out.\n   *\n   * Naturally, when establishing a connection is part of checking out,\n   * this duration is not greater than\n   * `ConnectionCheckedOutEvent.duration`.\n   */\n  durationMS: number;\n  /** @internal */\n  name = CONNECTION_READY;\n\n  /** @internal */\n  constructor(pool: ConnectionPool, connection: Connection, connectionCreatedEventTime: number) {\n    super(pool);\n    this.durationMS = now() - connectionCreatedEventTime;\n    this.connectionId = connection.id;\n  }\n}\n\n/**\n * An event published when a connection is closed\n * @public\n * @category Event\n */\nexport class ConnectionClosedEvent extends ConnectionPoolMonitoringEvent {\n  /** The id of the connection */\n  connectionId: number | '<monitor>';\n  /** The reason the connection was closed */\n  reason: string;\n  serviceId?: ObjectId;\n  /** @internal */\n  name = CONNECTION_CLOSED;\n  /** @internal */\n  error: MongoError | null;\n\n  /** @internal */\n  constructor(\n    pool: ConnectionPool,\n    connection: Pick<Connection, 'id' | 'serviceId'>,\n    reason: 'idle' | 'stale' | 'poolClosed' | 'error',\n    error?: MongoError\n  ) {\n    super(pool);\n    this.connectionId = connection.id;\n    this.reason = reason;\n    this.serviceId = connection.serviceId;\n    this.error = error ?? null;\n  }\n}\n\n/**\n * An event published when a request to check a connection out begins\n * @public\n * @category Event\n */\nexport class ConnectionCheckOutStartedEvent extends ConnectionPoolMonitoringEvent {\n  /** @internal */\n  name = CONNECTION_CHECK_OUT_STARTED;\n\n  /** @internal */\n  constructor(pool: ConnectionPool) {\n    super(pool);\n  }\n}\n\n/**\n * An event published when a request to check a connection out fails\n * @public\n * @category Event\n */\nexport class ConnectionCheckOutFailedEvent extends ConnectionPoolMonitoringEvent {\n  /** The reason the attempt to check out failed */\n  reason: string;\n  /** @internal */\n  error?: MongoError;\n  /** @internal */\n  name = CONNECTION_CHECK_OUT_FAILED;\n  /**\n   * The time it took to check out the connection.\n   * More specifically, the time elapsed between\n   * emitting a `ConnectionCheckOutStartedEvent`\n   * and emitting this event as part of the same check out.\n   */\n  durationMS: number;\n\n  /** @internal */\n  constructor(\n    pool: ConnectionPool,\n    reason: 'poolClosed' | 'timeout' | 'connectionError',\n    checkoutTime: number,\n    error?: MongoError\n  ) {\n    super(pool);\n    this.durationMS = now() - checkoutTime;\n    this.reason = reason;\n    this.error = error;\n  }\n}\n\n/**\n * An event published when a connection is checked out of the connection pool\n * @public\n * @category Event\n */\nexport class ConnectionCheckedOutEvent extends ConnectionPoolMonitoringEvent {\n  /** The id of the connection */\n  connectionId: number | '<monitor>';\n  /** @internal */\n  name = CONNECTION_CHECKED_OUT;\n  /**\n   * The time it took to check out the connection.\n   * More specifically, the time elapsed between\n   * emitting a `ConnectionCheckOutStartedEvent`\n   * and emitting this event as part of the same checking out.\n   *\n   */\n  durationMS: number;\n\n  /** @internal */\n  constructor(pool: ConnectionPool, connection: Connection, checkoutTime: number) {\n    super(pool);\n    this.durationMS = now() - checkoutTime;\n    this.connectionId = connection.id;\n  }\n}\n\n/**\n * An event published when a connection is checked into the connection pool\n * @public\n * @category Event\n */\nexport class ConnectionCheckedInEvent extends ConnectionPoolMonitoringEvent {\n  /** The id of the connection */\n  connectionId: number | '<monitor>';\n  /** @internal */\n  name = CONNECTION_CHECKED_IN;\n\n  /** @internal */\n  constructor(pool: ConnectionPool, connection: Connection) {\n    super(pool);\n    this.connectionId = connection.id;\n  }\n}\n\n/**\n * An event published when a connection pool is cleared\n * @public\n * @category Event\n */\nexport class ConnectionPoolClearedEvent extends ConnectionPoolMonitoringEvent {\n  /** @internal */\n  serviceId?: ObjectId;\n\n  interruptInUseConnections?: boolean;\n  /** @internal */\n  name = CONNECTION_POOL_CLEARED;\n\n  /** @internal */\n  constructor(\n    pool: ConnectionPool,\n    options: { serviceId?: ObjectId; interruptInUseConnections?: boolean } = {}\n  ) {\n    super(pool);\n    this.serviceId = options.serviceId;\n    this.interruptInUseConnections = options.interruptInUseConnections;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3512, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3516, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/errors.ts"],"sourcesContent":["import { MongoDriverError, MongoErrorLabel, MongoNetworkError } from '../error';\nimport type { ConnectionPool } from './connection_pool';\n\n/**\n * An error indicating a connection pool is closed\n * @category Error\n */\nexport class PoolClosedError extends MongoDriverError {\n  /** The address of the connection pool */\n  address: string;\n\n  /**\n   * **Do not use this constructor!**\n   *\n   * Meant for internal use only.\n   *\n   * @remarks\n   * This class is only meant to be constructed within the driver. This constructor is\n   * not subject to semantic versioning compatibility guarantees and may change at any time.\n   *\n   * @public\n   **/\n  constructor(pool: ConnectionPool) {\n    super('Attempted to check out a connection from closed connection pool');\n    this.address = pool.address;\n  }\n\n  override get name(): string {\n    return 'MongoPoolClosedError';\n  }\n}\n\n/**\n * An error indicating a connection pool is currently paused\n * @category Error\n */\nexport class PoolClearedError extends MongoNetworkError {\n  /** The address of the connection pool */\n  address: string;\n\n  /**\n   * **Do not use this constructor!**\n   *\n   * Meant for internal use only.\n   *\n   * @remarks\n   * This class is only meant to be constructed within the driver. This constructor is\n   * not subject to semantic versioning compatibility guarantees and may change at any time.\n   *\n   * @public\n   **/\n  constructor(pool: ConnectionPool, message?: string) {\n    const errorMessage = message\n      ? message\n      : `Connection pool for ${pool.address} was cleared because another operation failed with: \"${pool.serverError?.message}\"`;\n    super(errorMessage, pool.serverError ? { cause: pool.serverError } : undefined);\n    this.address = pool.address;\n\n    this.addErrorLabel(MongoErrorLabel.PoolRequstedRetry);\n  }\n\n  override get name(): string {\n    return 'MongoPoolClearedError';\n  }\n}\n\n/**\n * An error indicating that a connection pool has been cleared after the monitor for that server timed out.\n * @category Error\n */\nexport class PoolClearedOnNetworkError extends PoolClearedError {\n  /**\n   * **Do not use this constructor!**\n   *\n   * Meant for internal use only.\n   *\n   * @remarks\n   * This class is only meant to be constructed within the driver. This constructor is\n   * not subject to semantic versioning compatibility guarantees and may change at any time.\n   *\n   * @public\n   **/\n  constructor(pool: ConnectionPool) {\n    super(pool, `Connection to ${pool.address} interrupted due to server monitor timeout`);\n  }\n\n  override get name(): string {\n    return 'PoolClearedOnNetworkError';\n  }\n}\n\n/**\n * An error thrown when a request to check out a connection times out\n * @category Error\n */\nexport class WaitQueueTimeoutError extends MongoDriverError {\n  /** The address of the connection pool */\n  address: string;\n\n  /**\n   * **Do not use this constructor!**\n   *\n   * Meant for internal use only.\n   *\n   * @remarks\n   * This class is only meant to be constructed within the driver. This constructor is\n   * not subject to semantic versioning compatibility guarantees and may change at any time.\n   *\n   * @public\n   **/\n  constructor(message: string, address: string) {\n    super(message);\n    this.address = address;\n  }\n\n  override get name(): string {\n    return 'MongoWaitQueueTimeoutError';\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAGA;;;IAIA,MAAa,wBAAwB,QAAA,gBAAgB;IAInD;;;;;;;;;;SAWA,YAAY,IAAoB,CAAA;QAC9B,KAAK,CAAC;QACN,IAAI,CAAC,OAAO,GAAG,KAAK,OAAO;IAC7B;IAEA,IAAa,OAAI;QACf,OAAO;IACT;;AAtBF,QAAA,eAAA,GAAA;AAyBA;;;IAIA,MAAa,yBAAyB,QAAA,iBAAiB;IAIrD;;;;;;;;;;SAWA,YAAY,IAAoB,EAAE,OAAgB,CAAA;QAChD,MAAM,eAAe,UACjB,UACA,CAAA,oBAAA,EAAuB,KAAK,OAAO,CAAA,qDAAA,EAAwD,KAAK,WAAW,EAAE,QAAO,CAAA,CAAG;QAC3H,KAAK,CAAC,cAAc,KAAK,WAAW,GAAG;YAAE,OAAO,KAAK,WAAW;QAAA,IAAK;QACrE,IAAI,CAAC,OAAO,GAAG,KAAK,OAAO;QAE3B,IAAI,CAAC,aAAa,CAAC,QAAA,eAAe,CAAC,iBAAiB;IACtD;IAEA,IAAa,OAAI;QACf,OAAO;IACT;;AA3BF,QAAA,gBAAA,GAAA;AA8BA;;;IAIA,MAAa,kCAAkC;IAC7C;;;;;;;;;;SAWA,YAAY,IAAoB,CAAA;QAC9B,KAAK,CAAC,MAAM,CAAA,cAAA,EAAiB,KAAK,OAAO,CAAA,0CAAA,CAA4C;IACvF;IAEA,IAAa,OAAI;QACf,OAAO;IACT;;AAlBF,QAAA,yBAAA,GAAA;AAqBA;;;IAIA,MAAa,8BAA8B,QAAA,gBAAgB;IAIzD;;;;;;;;;;SAWA,YAAY,OAAe,EAAE,OAAe,CAAA;QAC1C,KAAK,CAAC;QACN,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,IAAa,OAAI;QACf,OAAO;IACT;;AAtBF,QAAA,qBAAA,GAAA"}},
    {"offset": {"line": 3617, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3621, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/connection_pool.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\n\nimport type { ObjectId } from '../bson';\nimport {\n  APM_EVENTS,\n  CONNECTION_CHECK_OUT_FAILED,\n  CONNECTION_CHECK_OUT_STARTED,\n  CONNECTION_CHECKED_IN,\n  CONNECTION_CHECKED_OUT,\n  CONNECTION_CLOSED,\n  CONNECTION_CREATED,\n  CONNECTION_POOL_CLEARED,\n  CONNECTION_POOL_CLOSED,\n  CONNECTION_POOL_CREATED,\n  CONNECTION_POOL_READY,\n  CONNECTION_READY\n} from '../constants';\nimport {\n  type AnyError,\n  MongoClientClosedError,\n  type MongoError,\n  MongoInvalidArgumentError,\n  MongoMissingCredentialsError,\n  MongoNetworkError,\n  MongoOperationTimeoutError,\n  MongoRuntimeError,\n  MongoServerError\n} from '../error';\nimport { type Abortable, CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport { type TimeoutContext, TimeoutError } from '../timeout';\nimport {\n  addAbortListener,\n  type Callback,\n  kDispose,\n  List,\n  makeCounter,\n  noop,\n  now,\n  promiseWithResolvers\n} from '../utils';\nimport { connect } from './connect';\nimport { Connection, type ConnectionEvents, type ConnectionOptions } from './connection';\nimport {\n  ConnectionCheckedInEvent,\n  ConnectionCheckedOutEvent,\n  ConnectionCheckOutFailedEvent,\n  ConnectionCheckOutStartedEvent,\n  ConnectionClosedEvent,\n  ConnectionCreatedEvent,\n  ConnectionPoolClearedEvent,\n  ConnectionPoolClosedEvent,\n  ConnectionPoolCreatedEvent,\n  ConnectionPoolReadyEvent,\n  ConnectionReadyEvent\n} from './connection_pool_events';\nimport {\n  PoolClearedError,\n  PoolClearedOnNetworkError,\n  PoolClosedError,\n  WaitQueueTimeoutError\n} from './errors';\nimport { ConnectionPoolMetrics } from './metrics';\n\n/** @public */\nexport interface ConnectionPoolOptions extends Omit<ConnectionOptions, 'id' | 'generation'> {\n  /** The maximum number of connections that may be associated with a pool at a given time. This includes in use and available connections. */\n  maxPoolSize: number;\n  /** The minimum number of connections that MUST exist at any moment in a single connection pool. */\n  minPoolSize: number;\n  /** The maximum number of connections that may be in the process of being established concurrently by the connection pool. */\n  maxConnecting: number;\n  /** The maximum amount of time a connection should remain idle in the connection pool before being marked idle. */\n  maxIdleTimeMS: number;\n  /** The maximum amount of time operation execution should wait for a connection to become available. The default is 0 which means there is no limit. */\n  waitQueueTimeoutMS: number;\n  /** If we are in load balancer mode. */\n  loadBalanced: boolean;\n  /** @internal */\n  minPoolSizeCheckFrequencyMS?: number;\n}\n\n/** @internal */\nexport interface WaitQueueMember {\n  resolve: (conn: Connection) => void;\n  reject: (err: AnyError) => void;\n  cancelled: boolean;\n  checkoutTime: number;\n}\n\n/** @internal */\nexport const PoolState = Object.freeze({\n  paused: 'paused',\n  ready: 'ready',\n  closed: 'closed'\n} as const);\n\ntype PoolState = (typeof PoolState)[keyof typeof PoolState];\n\n/**\n * @public\n * @deprecated This interface is deprecated and will be removed in a future release as it is not used\n * in the driver\n */\nexport interface CloseOptions {\n  force?: boolean;\n}\n\n/** @public */\nexport type ConnectionPoolEvents = {\n  connectionPoolCreated(event: ConnectionPoolCreatedEvent): void;\n  connectionPoolReady(event: ConnectionPoolReadyEvent): void;\n  connectionPoolClosed(event: ConnectionPoolClosedEvent): void;\n  connectionPoolCleared(event: ConnectionPoolClearedEvent): void;\n  connectionCreated(event: ConnectionCreatedEvent): void;\n  connectionReady(event: ConnectionReadyEvent): void;\n  connectionClosed(event: ConnectionClosedEvent): void;\n  connectionCheckOutStarted(event: ConnectionCheckOutStartedEvent): void;\n  connectionCheckOutFailed(event: ConnectionCheckOutFailedEvent): void;\n  connectionCheckedOut(event: ConnectionCheckedOutEvent): void;\n  connectionCheckedIn(event: ConnectionCheckedInEvent): void;\n} & Omit<ConnectionEvents, 'close' | 'message'>;\n\n/**\n * A pool of connections which dynamically resizes, and emit events related to pool activity\n * @internal\n */\nexport class ConnectionPool extends TypedEventEmitter<ConnectionPoolEvents> {\n  public options: Readonly<ConnectionPoolOptions>;\n  /**  An integer representing the SDAM generation of the pool */\n  public generation: number;\n  /** A map of generations to service ids */\n  public serviceGenerations: Map<string, number>;\n\n  private poolState: PoolState;\n  private server: Server;\n  private connections: List<Connection>;\n  private pending: number;\n  private checkedOut: Set<Connection>;\n  private minPoolSizeTimer?: NodeJS.Timeout;\n  private connectionCounter: Generator<number>;\n  private cancellationToken: CancellationToken;\n  private waitQueue: List<WaitQueueMember>;\n  private metrics: ConnectionPoolMetrics;\n  private processingWaitQueue: boolean;\n\n  /**\n   * Emitted when the connection pool is created.\n   * @event\n   */\n  static readonly CONNECTION_POOL_CREATED = CONNECTION_POOL_CREATED;\n  /**\n   * Emitted once when the connection pool is closed\n   * @event\n   */\n  static readonly CONNECTION_POOL_CLOSED = CONNECTION_POOL_CLOSED;\n  /**\n   * Emitted each time the connection pool is cleared and it's generation incremented\n   * @event\n   */\n  static readonly CONNECTION_POOL_CLEARED = CONNECTION_POOL_CLEARED;\n  /**\n   * Emitted each time the connection pool is marked ready\n   * @event\n   */\n  static readonly CONNECTION_POOL_READY = CONNECTION_POOL_READY;\n  /**\n   * Emitted when a connection is created.\n   * @event\n   */\n  static readonly CONNECTION_CREATED = CONNECTION_CREATED;\n  /**\n   * Emitted when a connection becomes established, and is ready to use\n   * @event\n   */\n  static readonly CONNECTION_READY = CONNECTION_READY;\n  /**\n   * Emitted when a connection is closed\n   * @event\n   */\n  static readonly CONNECTION_CLOSED = CONNECTION_CLOSED;\n  /**\n   * Emitted when an attempt to check out a connection begins\n   * @event\n   */\n  static readonly CONNECTION_CHECK_OUT_STARTED = CONNECTION_CHECK_OUT_STARTED;\n  /**\n   * Emitted when an attempt to check out a connection fails\n   * @event\n   */\n  static readonly CONNECTION_CHECK_OUT_FAILED = CONNECTION_CHECK_OUT_FAILED;\n  /**\n   * Emitted each time a connection is successfully checked out of the connection pool\n   * @event\n   */\n  static readonly CONNECTION_CHECKED_OUT = CONNECTION_CHECKED_OUT;\n  /**\n   * Emitted each time a connection is successfully checked into the connection pool\n   * @event\n   */\n  static readonly CONNECTION_CHECKED_IN = CONNECTION_CHECKED_IN;\n\n  constructor(server: Server, options: ConnectionPoolOptions) {\n    super();\n    this.on('error', noop);\n\n    this.options = Object.freeze({\n      connectionType: Connection,\n      ...options,\n      maxPoolSize: options.maxPoolSize ?? 100,\n      minPoolSize: options.minPoolSize ?? 0,\n      maxConnecting: options.maxConnecting ?? 2,\n      maxIdleTimeMS: options.maxIdleTimeMS ?? 0,\n      waitQueueTimeoutMS: options.waitQueueTimeoutMS ?? 0,\n      minPoolSizeCheckFrequencyMS: options.minPoolSizeCheckFrequencyMS ?? 100,\n      autoEncrypter: options.autoEncrypter\n    });\n\n    if (this.options.minPoolSize > this.options.maxPoolSize) {\n      throw new MongoInvalidArgumentError(\n        'Connection pool minimum size must not be greater than maximum pool size'\n      );\n    }\n\n    this.poolState = PoolState.paused;\n    this.server = server;\n    this.connections = new List();\n    this.pending = 0;\n    this.checkedOut = new Set();\n    this.minPoolSizeTimer = undefined;\n    this.generation = 0;\n    this.serviceGenerations = new Map();\n    this.connectionCounter = makeCounter(1);\n    this.cancellationToken = new CancellationToken();\n    this.cancellationToken.setMaxListeners(Infinity);\n    this.waitQueue = new List();\n    this.metrics = new ConnectionPoolMetrics();\n    this.processingWaitQueue = false;\n\n    this.mongoLogger = this.server.topology.client?.mongoLogger;\n    this.component = 'connection';\n\n    process.nextTick(() => {\n      this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new ConnectionPoolCreatedEvent(this));\n    });\n  }\n\n  /** The address of the endpoint the pool is connected to */\n  get address(): string {\n    return this.options.hostAddress.toString();\n  }\n\n  /**\n   * Check if the pool has been closed\n   *\n   * TODO(NODE-3263): We can remove this property once shell no longer needs it\n   */\n  get closed(): boolean {\n    return this.poolState === PoolState.closed;\n  }\n\n  /** An integer expressing how many total connections (available + pending + in use) the pool currently has */\n  get totalConnectionCount(): number {\n    return (\n      this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount\n    );\n  }\n\n  /** An integer expressing how many connections are currently available in the pool. */\n  get availableConnectionCount(): number {\n    return this.connections.length;\n  }\n\n  get pendingConnectionCount(): number {\n    return this.pending;\n  }\n\n  get currentCheckedOutCount(): number {\n    return this.checkedOut.size;\n  }\n\n  get waitQueueSize(): number {\n    return this.waitQueue.length;\n  }\n\n  get loadBalanced(): boolean {\n    return this.options.loadBalanced;\n  }\n\n  get serverError() {\n    return this.server.description.error;\n  }\n\n  /**\n   * This is exposed ONLY for use in mongosh, to enable\n   * killing all connections if a user quits the shell with\n   * operations in progress.\n   *\n   * This property may be removed as a part of NODE-3263.\n   */\n  get checkedOutConnections() {\n    return this.checkedOut;\n  }\n\n  /**\n   * Get the metrics information for the pool when a wait queue timeout occurs.\n   */\n  private waitQueueErrorMetrics(): string {\n    return this.metrics.info(this.options.maxPoolSize);\n  }\n\n  /**\n   * Set the pool state to \"ready\"\n   */\n  ready(): void {\n    if (this.poolState !== PoolState.paused) {\n      return;\n    }\n    this.poolState = PoolState.ready;\n    this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new ConnectionPoolReadyEvent(this));\n    clearTimeout(this.minPoolSizeTimer);\n    this.ensureMinPoolSize();\n  }\n\n  /**\n   * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it\n   * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or\n   * explicitly destroyed by the new owner.\n   */\n  async checkOut(options: { timeoutContext: TimeoutContext } & Abortable): Promise<Connection> {\n    const checkoutTime = now();\n    this.emitAndLog(\n      ConnectionPool.CONNECTION_CHECK_OUT_STARTED,\n      new ConnectionCheckOutStartedEvent(this)\n    );\n\n    const { promise, resolve, reject } = promiseWithResolvers<Connection>();\n\n    const timeout = options.timeoutContext.connectionCheckoutTimeout;\n\n    const waitQueueMember: WaitQueueMember = {\n      resolve,\n      reject,\n      cancelled: false,\n      checkoutTime\n    };\n\n    const abortListener = addAbortListener(options.signal, function () {\n      waitQueueMember.cancelled = true;\n      reject(this.reason);\n    });\n\n    this.waitQueue.push(waitQueueMember);\n    process.nextTick(() => this.processWaitQueue());\n\n    try {\n      timeout?.throwIfExpired();\n      return await (timeout ? Promise.race([promise, timeout]) : promise);\n    } catch (error) {\n      if (TimeoutError.is(error)) {\n        timeout?.clear();\n        waitQueueMember.cancelled = true;\n\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_CHECK_OUT_FAILED,\n          new ConnectionCheckOutFailedEvent(this, 'timeout', waitQueueMember.checkoutTime)\n        );\n        const timeoutError = new WaitQueueTimeoutError(\n          this.loadBalanced\n            ? this.waitQueueErrorMetrics()\n            : 'Timed out while checking out a connection from connection pool',\n          this.address\n        );\n        if (options.timeoutContext.csotEnabled()) {\n          throw new MongoOperationTimeoutError('Timed out during connection checkout', {\n            cause: timeoutError\n          });\n        }\n        throw timeoutError;\n      }\n      throw error;\n    } finally {\n      abortListener?.[kDispose]();\n      timeout?.clear();\n    }\n  }\n\n  /**\n   * Check a connection into the pool.\n   *\n   * @param connection - The connection to check in\n   */\n  checkIn(connection: Connection): void {\n    if (!this.checkedOut.has(connection)) {\n      return;\n    }\n    const poolClosed = this.closed;\n    const stale = this.connectionIsStale(connection);\n    const willDestroy = !!(poolClosed || stale || connection.closed);\n\n    if (!willDestroy) {\n      connection.markAvailable();\n      this.connections.unshift(connection);\n    }\n\n    this.checkedOut.delete(connection);\n    this.emitAndLog(\n      ConnectionPool.CONNECTION_CHECKED_IN,\n      new ConnectionCheckedInEvent(this, connection)\n    );\n\n    if (willDestroy) {\n      const reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';\n      this.destroyConnection(connection, reason);\n    }\n\n    process.nextTick(() => this.processWaitQueue());\n  }\n\n  /**\n   * Clear the pool\n   *\n   * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a\n   * previous generation will eventually be pruned during subsequent checkouts.\n   */\n  clear(options: { serviceId?: ObjectId; interruptInUseConnections?: boolean } = {}): void {\n    if (this.closed) {\n      return;\n    }\n\n    // handle load balanced case\n    if (this.loadBalanced) {\n      const { serviceId } = options;\n      if (!serviceId) {\n        throw new MongoRuntimeError(\n          'ConnectionPool.clear() called in load balanced mode with no serviceId.'\n        );\n      }\n      const sid = serviceId.toHexString();\n      const generation = this.serviceGenerations.get(sid);\n      // Only need to worry if the generation exists, since it should\n      // always be there but typescript needs the check.\n      if (generation == null) {\n        throw new MongoRuntimeError('Service generations are required in load balancer mode.');\n      } else {\n        // Increment the generation for the service id.\n        this.serviceGenerations.set(sid, generation + 1);\n      }\n      this.emitAndLog(\n        ConnectionPool.CONNECTION_POOL_CLEARED,\n        new ConnectionPoolClearedEvent(this, { serviceId })\n      );\n      return;\n    }\n    // handle non load-balanced case\n    const interruptInUseConnections = options.interruptInUseConnections ?? false;\n    const oldGeneration = this.generation;\n    this.generation += 1;\n    const alreadyPaused = this.poolState === PoolState.paused;\n    this.poolState = PoolState.paused;\n\n    this.clearMinPoolSizeTimer();\n    if (!alreadyPaused) {\n      this.emitAndLog(\n        ConnectionPool.CONNECTION_POOL_CLEARED,\n        new ConnectionPoolClearedEvent(this, {\n          interruptInUseConnections\n        })\n      );\n    }\n\n    if (interruptInUseConnections) {\n      process.nextTick(() => this.interruptInUseConnections(oldGeneration));\n    }\n\n    this.processWaitQueue();\n  }\n\n  /**\n   * Closes all stale in-use connections in the pool with a resumable PoolClearedOnNetworkError.\n   *\n   * Only connections where `connection.generation <= minGeneration` are killed.\n   */\n  private interruptInUseConnections(minGeneration: number) {\n    for (const connection of this.checkedOut) {\n      if (connection.generation <= minGeneration) {\n        connection.onError(new PoolClearedOnNetworkError(this));\n      }\n    }\n  }\n\n  /** For MongoClient.close() procedures */\n  public closeCheckedOutConnections() {\n    for (const conn of this.checkedOut) {\n      conn.onError(new MongoClientClosedError());\n    }\n  }\n\n  /** Close the pool */\n  close(): void {\n    if (this.closed) {\n      return;\n    }\n\n    // immediately cancel any in-flight connections\n    this.cancellationToken.emit('cancel');\n\n    // end the connection counter\n    if (typeof this.connectionCounter.return === 'function') {\n      this.connectionCounter.return(undefined);\n    }\n\n    this.poolState = PoolState.closed;\n    this.clearMinPoolSizeTimer();\n    this.processWaitQueue();\n\n    for (const conn of this.connections) {\n      this.emitAndLog(\n        ConnectionPool.CONNECTION_CLOSED,\n        new ConnectionClosedEvent(this, conn, 'poolClosed')\n      );\n      conn.destroy();\n    }\n    this.connections.clear();\n    this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new ConnectionPoolClosedEvent(this));\n  }\n\n  /**\n   * @internal\n   * Reauthenticate a connection\n   */\n  async reauthenticate(connection: Connection): Promise<void> {\n    const authContext = connection.authContext;\n    if (!authContext) {\n      throw new MongoRuntimeError('No auth context found on connection.');\n    }\n    const credentials = authContext.credentials;\n    if (!credentials) {\n      throw new MongoMissingCredentialsError(\n        'Connection is missing credentials when asked to reauthenticate'\n      );\n    }\n\n    const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello);\n    const provider = this.server.topology.client.s.authProviders.getOrCreateProvider(\n      resolvedCredentials.mechanism,\n      resolvedCredentials.mechanismProperties\n    );\n\n    if (!provider) {\n      throw new MongoMissingCredentialsError(\n        `Reauthenticate failed due to no auth provider for ${credentials.mechanism}`\n      );\n    }\n\n    await provider.reauth(authContext);\n\n    return;\n  }\n\n  /** Clear the min pool size timer */\n  private clearMinPoolSizeTimer(): void {\n    const minPoolSizeTimer = this.minPoolSizeTimer;\n    if (minPoolSizeTimer) {\n      clearTimeout(minPoolSizeTimer);\n    }\n  }\n\n  private destroyConnection(\n    connection: Connection,\n    reason: 'error' | 'idle' | 'stale' | 'poolClosed'\n  ) {\n    this.emitAndLog(\n      ConnectionPool.CONNECTION_CLOSED,\n      new ConnectionClosedEvent(this, connection, reason)\n    );\n    // destroy the connection\n    connection.destroy();\n  }\n\n  private connectionIsStale(connection: Connection) {\n    const serviceId = connection.serviceId;\n    if (this.loadBalanced && serviceId) {\n      const sid = serviceId.toHexString();\n      const generation = this.serviceGenerations.get(sid);\n      return connection.generation !== generation;\n    }\n\n    return connection.generation !== this.generation;\n  }\n\n  private connectionIsIdle(connection: Connection) {\n    return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);\n  }\n\n  /**\n   * Destroys a connection if the connection is perished.\n   *\n   * @returns `true` if the connection was destroyed, `false` otherwise.\n   */\n  private destroyConnectionIfPerished(connection: Connection): boolean {\n    const isStale = this.connectionIsStale(connection);\n    const isIdle = this.connectionIsIdle(connection);\n    if (!isStale && !isIdle && !connection.closed) {\n      return false;\n    }\n    const reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';\n    this.destroyConnection(connection, reason);\n    return true;\n  }\n\n  private createConnection(callback: Callback<Connection>) {\n    const connectOptions: ConnectionOptions = {\n      ...this.options,\n      id: this.connectionCounter.next().value,\n      generation: this.generation,\n      cancellationToken: this.cancellationToken,\n      mongoLogger: this.mongoLogger,\n      authProviders: this.server.topology.client.s.authProviders\n    };\n\n    this.pending++;\n    // This is our version of a \"virtual\" no-I/O connection as the spec requires\n    const connectionCreatedTime = now();\n    this.emitAndLog(\n      ConnectionPool.CONNECTION_CREATED,\n      new ConnectionCreatedEvent(this, { id: connectOptions.id })\n    );\n\n    connect(connectOptions).then(\n      connection => {\n        // The pool might have closed since we started trying to create a connection\n        if (this.poolState !== PoolState.ready) {\n          this.pending--;\n          connection.destroy();\n          callback(this.closed ? new PoolClosedError(this) : new PoolClearedError(this));\n          return;\n        }\n\n        // forward all events from the connection to the pool\n        for (const event of [...APM_EVENTS, Connection.CLUSTER_TIME_RECEIVED]) {\n          connection.on(event, (e: any) => this.emit(event, e));\n        }\n\n        if (this.loadBalanced) {\n          connection.on(Connection.PINNED, pinType => this.metrics.markPinned(pinType));\n          connection.on(Connection.UNPINNED, pinType => this.metrics.markUnpinned(pinType));\n\n          const serviceId = connection.serviceId;\n          if (serviceId) {\n            let generation;\n            const sid = serviceId.toHexString();\n            if ((generation = this.serviceGenerations.get(sid))) {\n              connection.generation = generation;\n            } else {\n              this.serviceGenerations.set(sid, 0);\n              connection.generation = 0;\n            }\n          }\n        }\n\n        connection.markAvailable();\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_READY,\n          new ConnectionReadyEvent(this, connection, connectionCreatedTime)\n        );\n\n        this.pending--;\n        callback(undefined, connection);\n      },\n      error => {\n        this.pending--;\n        this.server.handleError(error);\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_CLOSED,\n          new ConnectionClosedEvent(\n            this,\n            { id: connectOptions.id, serviceId: undefined },\n            'error',\n            // TODO(NODE-5192): Remove this cast\n            error as MongoError\n          )\n        );\n        if (error instanceof MongoNetworkError || error instanceof MongoServerError) {\n          error.connectionGeneration = connectOptions.generation;\n        }\n        callback(error ?? new MongoRuntimeError('Connection creation failed without error'));\n      }\n    );\n  }\n\n  private ensureMinPoolSize() {\n    const minPoolSize = this.options.minPoolSize;\n    if (this.poolState !== PoolState.ready || minPoolSize === 0) {\n      return;\n    }\n\n    this.connections.prune(connection => this.destroyConnectionIfPerished(connection));\n\n    if (\n      this.totalConnectionCount < minPoolSize &&\n      this.pendingConnectionCount < this.options.maxConnecting\n    ) {\n      // NOTE: ensureMinPoolSize should not try to get all the pending\n      // connection permits because that potentially delays the availability of\n      // the connection to a checkout request\n      this.createConnection((err, connection) => {\n        if (!err && connection) {\n          this.connections.push(connection);\n          process.nextTick(() => this.processWaitQueue());\n        }\n        if (this.poolState === PoolState.ready) {\n          clearTimeout(this.minPoolSizeTimer);\n          this.minPoolSizeTimer = setTimeout(\n            () => this.ensureMinPoolSize(),\n            this.options.minPoolSizeCheckFrequencyMS\n          );\n        }\n      });\n    } else {\n      clearTimeout(this.minPoolSizeTimer);\n      this.minPoolSizeTimer = setTimeout(\n        () => this.ensureMinPoolSize(),\n        this.options.minPoolSizeCheckFrequencyMS\n      );\n    }\n  }\n\n  private processWaitQueue() {\n    if (this.processingWaitQueue) {\n      return;\n    }\n    this.processingWaitQueue = true;\n\n    while (this.waitQueueSize) {\n      const waitQueueMember = this.waitQueue.first();\n      if (!waitQueueMember) {\n        this.waitQueue.shift();\n        continue;\n      }\n\n      if (waitQueueMember.cancelled) {\n        this.waitQueue.shift();\n        continue;\n      }\n\n      if (this.poolState !== PoolState.ready) {\n        const reason = this.closed ? 'poolClosed' : 'connectionError';\n        const error = this.closed ? new PoolClosedError(this) : new PoolClearedError(this);\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_CHECK_OUT_FAILED,\n          new ConnectionCheckOutFailedEvent(this, reason, waitQueueMember.checkoutTime, error)\n        );\n        this.waitQueue.shift();\n        waitQueueMember.reject(error);\n        continue;\n      }\n\n      if (!this.availableConnectionCount) {\n        break;\n      }\n\n      const connection = this.connections.shift();\n      if (!connection) {\n        break;\n      }\n\n      if (!this.destroyConnectionIfPerished(connection)) {\n        this.checkedOut.add(connection);\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_CHECKED_OUT,\n          new ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime)\n        );\n\n        this.waitQueue.shift();\n        waitQueueMember.resolve(connection);\n      }\n    }\n\n    const { maxPoolSize, maxConnecting } = this.options;\n    while (\n      this.waitQueueSize > 0 &&\n      this.pendingConnectionCount < maxConnecting &&\n      (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)\n    ) {\n      const waitQueueMember = this.waitQueue.shift();\n      if (!waitQueueMember || waitQueueMember.cancelled) {\n        continue;\n      }\n      this.createConnection((err, connection) => {\n        if (waitQueueMember.cancelled) {\n          if (!err && connection) {\n            this.connections.push(connection);\n          }\n        } else {\n          if (err) {\n            this.emitAndLog(\n              ConnectionPool.CONNECTION_CHECK_OUT_FAILED,\n              // TODO(NODE-5192): Remove this cast\n              new ConnectionCheckOutFailedEvent(\n                this,\n                'connectionError',\n                waitQueueMember.checkoutTime,\n                err as MongoError\n              )\n            );\n            waitQueueMember.reject(err);\n          } else if (connection) {\n            this.checkedOut.add(connection);\n            this.emitAndLog(\n              ConnectionPool.CONNECTION_CHECKED_OUT,\n              new ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime)\n            );\n            waitQueueMember.resolve(connection);\n          }\n        }\n        process.nextTick(() => this.processWaitQueue());\n      });\n    }\n    this.processingWaitQueue = false;\n  }\n}\n\n/**\n * A callback provided to `withConnection`\n * @internal\n *\n * @param error - An error instance representing the error during the execution.\n * @param connection - The managed connection which was checked out of the pool.\n * @param callback - A function to call back after connection management is complete\n */\nexport type WithConnectionCallback = (\n  error: MongoError | undefined,\n  connection: Connection | undefined,\n  callback: Callback<Connection>\n) => void;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4146, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4150, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_aws.ts"],"sourcesContent":["import type { Binary, BSONSerializeOptions } from '../../bson';\nimport * as BSON from '../../bson';\nimport { aws4 } from '../../deps';\nimport {\n  MongoCompatibilityError,\n  MongoMissingCredentialsError,\n  MongoRuntimeError\n} from '../../error';\nimport { ByteUtils, maxWireVersion, ns, randomBytes } from '../../utils';\nimport { type AuthContext, AuthProvider } from './auth_provider';\nimport {\n  type AWSCredentialProvider,\n  AWSSDKCredentialProvider,\n  type AWSTempCredentials,\n  AWSTemporaryCredentialProvider,\n  LegacyAWSTemporaryCredentialProvider\n} from './aws_temporary_credentials';\nimport { MongoCredentials } from './mongo_credentials';\nimport { AuthMechanism } from './providers';\n\nconst ASCII_N = 110;\nconst bsonOptions: BSONSerializeOptions = {\n  useBigInt64: false,\n  promoteLongs: true,\n  promoteValues: true,\n  promoteBuffers: false,\n  bsonRegExp: false\n};\n\ninterface AWSSaslContinuePayload {\n  a: string;\n  d: string;\n  t?: string;\n}\n\nexport class MongoDBAWS extends AuthProvider {\n  private credentialFetcher: AWSTemporaryCredentialProvider;\n  private credentialProvider?: AWSCredentialProvider;\n\n  constructor(credentialProvider?: AWSCredentialProvider) {\n    super();\n\n    this.credentialProvider = credentialProvider;\n    this.credentialFetcher = AWSTemporaryCredentialProvider.isAWSSDKInstalled\n      ? new AWSSDKCredentialProvider(credentialProvider)\n      : new LegacyAWSTemporaryCredentialProvider();\n  }\n\n  override async auth(authContext: AuthContext): Promise<void> {\n    const { connection } = authContext;\n    if (!authContext.credentials) {\n      throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n\n    if ('kModuleError' in aws4) {\n      throw aws4['kModuleError'];\n    }\n    const { sign } = aws4;\n\n    if (maxWireVersion(connection) < 9) {\n      throw new MongoCompatibilityError(\n        'MONGODB-AWS authentication requires MongoDB version 4.4 or later'\n      );\n    }\n\n    if (!authContext.credentials.username) {\n      authContext.credentials = await makeTempCredentials(\n        authContext.credentials,\n        this.credentialFetcher\n      );\n    }\n\n    const { credentials } = authContext;\n\n    const accessKeyId = credentials.username;\n    const secretAccessKey = credentials.password;\n    // Allow the user to specify an AWS session token for authentication with temporary credentials.\n    const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;\n\n    // If all three defined, include sessionToken, else include username and pass, else no credentials\n    const awsCredentials =\n      accessKeyId && secretAccessKey && sessionToken\n        ? { accessKeyId, secretAccessKey, sessionToken }\n        : accessKeyId && secretAccessKey\n          ? { accessKeyId, secretAccessKey }\n          : undefined;\n\n    const db = credentials.source;\n    const nonce = await randomBytes(32);\n\n    // All messages between MongoDB clients and servers are sent as BSON objects\n    // in the payload field of saslStart and saslContinue.\n    const saslStart = {\n      saslStart: 1,\n      mechanism: 'MONGODB-AWS',\n      payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)\n    };\n\n    const saslStartResponse = await connection.command(ns(`${db}.$cmd`), saslStart, undefined);\n\n    const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions) as {\n      s: Binary;\n      h: string;\n    };\n    const host = serverResponse.h;\n    const serverNonce = serverResponse.s.buffer;\n    if (serverNonce.length !== 64) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);\n    }\n\n    if (!ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {\n      // throw because the serverNonce's leading 32 bytes must equal the client nonce's 32 bytes\n      // https://github.com/mongodb/specifications/blob/master/source/auth/auth.md#conversation-5\n\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('Server nonce does not begin with client nonce');\n    }\n\n    if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError(`Server returned an invalid host: \"${host}\"`);\n    }\n\n    const body = 'Action=GetCallerIdentity&Version=2011-06-15';\n    const options = sign(\n      {\n        method: 'POST',\n        host,\n        region: deriveRegion(serverResponse.h),\n        service: 'sts',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Content-Length': body.length,\n          'X-MongoDB-Server-Nonce': ByteUtils.toBase64(serverNonce),\n          'X-MongoDB-GS2-CB-Flag': 'n'\n        },\n        path: '/',\n        body\n      },\n      awsCredentials\n    );\n\n    const payload: AWSSaslContinuePayload = {\n      a: options.headers.Authorization,\n      d: options.headers['X-Amz-Date']\n    };\n\n    if (sessionToken) {\n      payload.t = sessionToken;\n    }\n\n    const saslContinue = {\n      saslContinue: 1,\n      conversationId: saslStartResponse.conversationId,\n      payload: BSON.serialize(payload, bsonOptions)\n    };\n\n    await connection.command(ns(`${db}.$cmd`), saslContinue, undefined);\n  }\n}\n\nasync function makeTempCredentials(\n  credentials: MongoCredentials,\n  awsCredentialFetcher: AWSTemporaryCredentialProvider\n): Promise<MongoCredentials> {\n  function makeMongoCredentialsFromAWSTemp(creds: AWSTempCredentials) {\n    // The AWS session token (creds.Token) may or may not be set.\n    if (!creds.AccessKeyId || !creds.SecretAccessKey) {\n      throw new MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials');\n    }\n\n    return new MongoCredentials({\n      username: creds.AccessKeyId,\n      password: creds.SecretAccessKey,\n      source: credentials.source,\n      mechanism: AuthMechanism.MONGODB_AWS,\n      mechanismProperties: {\n        AWS_SESSION_TOKEN: creds.Token\n      }\n    });\n  }\n  const temporaryCredentials = await awsCredentialFetcher.getCredentials();\n\n  return makeMongoCredentialsFromAWSTemp(temporaryCredentials);\n}\n\nfunction deriveRegion(host: string) {\n  const parts = host.split('.');\n  if (parts.length === 1 || parts[1] === 'amazonaws') {\n    return 'us-east-1';\n  }\n\n  return parts[1];\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4293, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4297, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc/command_builders.ts"],"sourcesContent":["import { Binary, BSON, type Document } from '../../../bson';\nimport { type MongoCredentials } from '../mongo_credentials';\nimport { AuthMechanism } from '../providers';\n\n/** @internal */\nexport interface OIDCCommand {\n  saslStart?: number;\n  saslContinue?: number;\n  conversationId?: number;\n  mechanism?: string;\n  autoAuthorize?: number;\n  db?: string;\n  payload: Binary;\n}\n\n/**\n * Generate the finishing command document for authentication. Will be a\n * saslStart or saslContinue depending on the presence of a conversation id.\n */\nexport function finishCommandDocument(token: string, conversationId?: number): OIDCCommand {\n  if (conversationId != null) {\n    return {\n      saslContinue: 1,\n      conversationId: conversationId,\n      payload: new Binary(BSON.serialize({ jwt: token }))\n    };\n  }\n  // saslContinue requires a conversationId in the command to be valid so in this\n  // case the server allows \"step two\" to actually be a saslStart with the token\n  // as the jwt since the use of the cached value has no correlating conversating\n  // on the particular connection.\n  return {\n    saslStart: 1,\n    mechanism: AuthMechanism.MONGODB_OIDC,\n    payload: new Binary(BSON.serialize({ jwt: token }))\n  };\n}\n\n/**\n * Generate the saslStart command document.\n */\nexport function startCommandDocument(credentials: MongoCredentials): OIDCCommand {\n  const payload: Document = {};\n  if (credentials.username) {\n    payload.n = credentials.username;\n  }\n  return {\n    saslStart: 1,\n    autoAuthorize: 1,\n    mechanism: AuthMechanism.MONGODB_OIDC,\n    payload: new Binary(BSON.serialize(payload))\n  };\n}\n"],"names":[],"mappings":";;;;AAmBA,QAAA,qBAAA,GAAA;AAsBA,QAAA,oBAAA,GAAA;AAzCA,MAAA;AAEA,MAAA;AAaA;;;IAIA,SAAgB,sBAAsB,KAAa,EAAE,cAAuB;IAC1E,IAAI,kBAAkB,MAAM;QAC1B,OAAO;YACL,cAAc;YACd,gBAAgB;YAChB,SAAS,IAAI,OAAA,MAAM,CAAC,OAAA,IAAI,CAAC,SAAS,CAAC;gBAAE,KAAK;YAAK;;IAEnD;IACA,+EAA+E;IAC/E,8EAA8E;IAC9E,+EAA+E;IAC/E,gCAAgC;IAChC,OAAO;QACL,WAAW;QACX,WAAW,YAAA,aAAa,CAAC,YAAY;QACrC,SAAS,IAAI,OAAA,MAAM,CAAC,OAAA,IAAI,CAAC,SAAS,CAAC;YAAE,KAAK;QAAK;;AAEnD;AAEA;;IAGA,SAAgB,qBAAqB,WAA6B;IAChE,MAAM,UAAoB,CAAA;IAC1B,IAAI,YAAY,QAAQ,EAAE;QACxB,QAAQ,CAAC,GAAG,YAAY,QAAQ;IAClC;IACA,OAAO;QACL,WAAW;QACX,eAAe;QACf,WAAW,YAAA,aAAa,CAAC,YAAY;QACrC,SAAS,IAAI,OAAA,MAAM,CAAC,OAAA,IAAI,CAAC,SAAS,CAAC;;AAEvC"}},
    {"offset": {"line": 4344, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4348, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc/callback_workflow.ts"],"sourcesContent":["import { setTimeout } from 'timers/promises';\n\nimport { type Document } from '../../../bson';\nimport { MongoMissingCredentialsError } from '../../../error';\nimport { ns } from '../../../utils';\nimport type { Connection } from '../../connection';\nimport type { MongoCredentials } from '../mongo_credentials';\nimport {\n  type OIDCCallbackFunction,\n  type OIDCCallbackParams,\n  type OIDCResponse,\n  type Workflow\n} from '../mongodb_oidc';\nimport { finishCommandDocument, startCommandDocument } from './command_builders';\nimport { type TokenCache } from './token_cache';\n\n/** 5 minutes in milliseconds */\nexport const HUMAN_TIMEOUT_MS = 300000;\n/** 1 minute in milliseconds */\nexport const AUTOMATED_TIMEOUT_MS = 60000;\n\n/** Properties allowed on results of callbacks. */\nconst RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];\n\n/** Error message when the callback result is invalid. */\nconst CALLBACK_RESULT_ERROR =\n  'User provided OIDC callbacks must return a valid object with an accessToken.';\n\n/** The time to throttle callback calls. */\nconst THROTTLE_MS = 100;\n\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\nexport abstract class CallbackWorkflow implements Workflow {\n  cache: TokenCache;\n  callback: OIDCCallbackFunction;\n  lastExecutionTime: number;\n\n  /**\n   * Instantiate the callback workflow.\n   */\n  constructor(cache: TokenCache, callback: OIDCCallbackFunction) {\n    this.cache = cache;\n    this.callback = this.withLock(callback);\n    this.lastExecutionTime = Date.now() - THROTTLE_MS;\n  }\n\n  /**\n   * Get the document to add for speculative authentication. This also needs\n   * to add a db field from the credentials source.\n   */\n  async speculativeAuth(connection: Connection, credentials: MongoCredentials): Promise<Document> {\n    // Check if the Client Cache has an access token.\n    // If it does, cache the access token in the Connection Cache and send a JwtStepRequest\n    // with the cached access token in the speculative authentication SASL payload.\n    if (this.cache.hasAccessToken) {\n      const accessToken = this.cache.getAccessToken();\n      connection.accessToken = accessToken;\n      const document = finishCommandDocument(accessToken);\n      document.db = credentials.source;\n      return { speculativeAuthenticate: document };\n    }\n    return {};\n  }\n\n  /**\n   * Reauthenticate the callback workflow. For this we invalidated the access token\n   * in the cache and run the authentication steps again. No initial handshake needs\n   * to be sent.\n   */\n  async reauthenticate(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    if (this.cache.hasAccessToken) {\n      // Reauthentication implies the token has expired.\n      if (connection.accessToken === this.cache.getAccessToken()) {\n        // If connection's access token is the same as the cache's, remove\n        // the token from the cache and connection.\n        this.cache.removeAccessToken();\n        delete connection.accessToken;\n      } else {\n        // If the connection's access token is different from the cache's, set\n        // the cache's token on the connection and do not remove from the\n        // cache.\n        connection.accessToken = this.cache.getAccessToken();\n      }\n    }\n    await this.execute(connection, credentials);\n  }\n\n  /**\n   * Execute the OIDC callback workflow.\n   */\n  abstract execute(\n    connection: Connection,\n    credentials: MongoCredentials,\n    response?: Document\n  ): Promise<void>;\n\n  /**\n   * Starts the callback authentication process. If there is a speculative\n   * authentication document from the initial handshake, then we will use that\n   * value to get the issuer, otherwise we will send the saslStart command.\n   */\n  protected async startAuthentication(\n    connection: Connection,\n    credentials: MongoCredentials,\n    response?: Document\n  ): Promise<Document> {\n    let result;\n    if (response?.speculativeAuthenticate) {\n      result = response.speculativeAuthenticate;\n    } else {\n      result = await connection.command(\n        ns(credentials.source),\n        startCommandDocument(credentials),\n        undefined\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Finishes the callback authentication process.\n   */\n  protected async finishAuthentication(\n    connection: Connection,\n    credentials: MongoCredentials,\n    token: string,\n    conversationId?: number\n  ): Promise<void> {\n    await connection.command(\n      ns(credentials.source),\n      finishCommandDocument(token, conversationId),\n      undefined\n    );\n  }\n\n  /**\n   * Executes the callback and validates the output.\n   */\n  protected async executeAndValidateCallback(params: OIDCCallbackParams): Promise<OIDCResponse> {\n    const result = await this.callback(params);\n    // Validate that the result returned by the callback is acceptable. If it is not\n    // we must clear the token result from the cache.\n    if (isCallbackResultInvalid(result)) {\n      throw new MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);\n    }\n    return result;\n  }\n\n  /**\n   * Ensure the callback is only executed one at a time and throttles the calls\n   * to every 100ms.\n   */\n  protected withLock(callback: OIDCCallbackFunction): OIDCCallbackFunction {\n    let lock: Promise<any> = Promise.resolve();\n    return async (params: OIDCCallbackParams): Promise<OIDCResponse> => {\n      // We do this to ensure that we would never return the result of the\n      // previous lock, only the current callback's value would get returned.\n      await lock;\n      lock = lock\n\n        .catch(() => null)\n\n        .then(async () => {\n          const difference = Date.now() - this.lastExecutionTime;\n          if (difference <= THROTTLE_MS) {\n            await setTimeout(THROTTLE_MS - difference, { signal: params.timeoutContext });\n          }\n          this.lastExecutionTime = Date.now();\n          return await callback(params);\n        });\n      return await lock;\n    };\n  }\n}\n\n/**\n * Determines if a result returned from a request or refresh callback\n * function is invalid. This means the result is nullish, doesn't contain\n * the accessToken required field, and does not contain extra fields.\n */\nfunction isCallbackResultInvalid(tokenResult: unknown): boolean {\n  if (tokenResult == null || typeof tokenResult !== 'object') return true;\n  if (!('accessToken' in tokenResult)) return true;\n  return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4478, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4482, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc/automated_callback_workflow.ts"],"sourcesContent":["import { MONGODB_ERROR_CODES, MongoError, MongoOIDCError } from '../../../error';\nimport { Timeout, TimeoutError } from '../../../timeout';\nimport { type Connection } from '../../connection';\nimport { type MongoCredentials } from '../mongo_credentials';\nimport {\n  OIDC_VERSION,\n  type OIDCCallbackFunction,\n  type OIDCCallbackParams,\n  type OIDCResponse\n} from '../mongodb_oidc';\nimport { AUTOMATED_TIMEOUT_MS, CallbackWorkflow } from './callback_workflow';\nimport { type TokenCache } from './token_cache';\n\n/**\n * Class implementing behaviour for the non human callback workflow.\n * @internal\n */\nexport class AutomatedCallbackWorkflow extends CallbackWorkflow {\n  /**\n   * Instantiate the human callback workflow.\n   */\n  constructor(cache: TokenCache, callback: OIDCCallbackFunction) {\n    super(cache, callback);\n  }\n\n  /**\n   * Execute the OIDC callback workflow.\n   */\n  async execute(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    // If there is a cached access token, try to authenticate with it. If\n    // authentication fails with an Authentication error (18),\n    // invalidate the access token, fetch a new access token, and try\n    // to authenticate again.\n    // If the server fails for any other reason, do not clear the cache.\n    if (this.cache.hasAccessToken) {\n      const token = this.cache.getAccessToken();\n      if (!connection.accessToken) {\n        connection.accessToken = token;\n      }\n      try {\n        return await this.finishAuthentication(connection, credentials, token);\n      } catch (error) {\n        if (\n          error instanceof MongoError &&\n          error.code === MONGODB_ERROR_CODES.AuthenticationFailed\n        ) {\n          this.cache.removeAccessToken();\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n    const response = await this.fetchAccessToken(credentials);\n    this.cache.put(response);\n    connection.accessToken = response.accessToken;\n    await this.finishAuthentication(connection, credentials, response.accessToken);\n  }\n\n  /**\n   * Fetches the access token using the callback.\n   */\n  protected async fetchAccessToken(credentials: MongoCredentials): Promise<OIDCResponse> {\n    const controller = new AbortController();\n    const params: OIDCCallbackParams = {\n      timeoutContext: controller.signal,\n      version: OIDC_VERSION\n    };\n    if (credentials.username) {\n      params.username = credentials.username;\n    }\n    if (credentials.mechanismProperties.TOKEN_RESOURCE) {\n      params.tokenAudience = credentials.mechanismProperties.TOKEN_RESOURCE;\n    }\n    const timeout = Timeout.expires(AUTOMATED_TIMEOUT_MS);\n    try {\n      return await Promise.race([this.executeAndValidateCallback(params), timeout]);\n    } catch (error) {\n      if (TimeoutError.is(error)) {\n        controller.abort();\n        throw new MongoOIDCError(`OIDC callback timed out after ${AUTOMATED_TIMEOUT_MS}ms.`);\n      }\n      throw error;\n    } finally {\n      timeout.clear();\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AAGA,MAAA;AAMA,MAAA;AAGA;;;IAIA,MAAa,kCAAkC,oBAAA,gBAAgB;IAC7D;;QAGA,YAAY,KAAiB,EAAE,QAA8B,CAAA;QAC3D,KAAK,CAAC,OAAO;IACf;IAEA;;QAGA,MAAM,QAAQ,UAAsB,EAAE,WAA6B,EAAA;QACjE,qEAAqE;QACrE,0DAA0D;QAC1D,iEAAiE;QACjE,yBAAyB;QACzB,oEAAoE;QACpE,IAAI,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;YAC7B,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,cAAc;YACvC,IAAI,CAAC,WAAW,WAAW,EAAE;gBAC3B,WAAW,WAAW,GAAG;YAC3B;YACA,IAAI;gBACF,OAAO,MAAM,IAAI,CAAC,oBAAoB,CAAC,YAAY,aAAa;YAClE,EAAE,OAAO,OAAO;gBACd,IACE,iBAAiB,QAAA,UAAU,IAC3B,MAAM,IAAI,KAAK,QAAA,mBAAmB,CAAC,oBAAoB,EACvD;oBACA,IAAI,CAAC,KAAK,CAAC,iBAAiB;oBAC5B,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,YAAY;gBACxC,OAAO;oBACL,MAAM;gBACR;YACF;QACF;QACA,MAAM,WAAW,MAAM,IAAI,CAAC,gBAAgB,CAAC;QAC7C,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;QACf,WAAW,WAAW,GAAG,SAAS,WAAW;QAC7C,MAAM,IAAI,CAAC,oBAAoB,CAAC,YAAY,aAAa,SAAS,WAAW;IAC/E;IAEA;;QAGU,MAAM,iBAAiB,WAA6B,EAAA;QAC5D,MAAM,aAAa,IAAI;QACvB,MAAM,SAA6B;YACjC,gBAAgB,WAAW,MAAM;YACjC,SAAS,eAAA,YAAY;;QAEvB,IAAI,YAAY,QAAQ,EAAE;YACxB,OAAO,QAAQ,GAAG,YAAY,QAAQ;QACxC;QACA,IAAI,YAAY,mBAAmB,CAAC,cAAc,EAAE;YAClD,OAAO,aAAa,GAAG,YAAY,mBAAmB,CAAC,cAAc;QACvE;QACA,MAAM,UAAU,UAAA,OAAO,CAAC,OAAO,CAAC,oBAAA,oBAAoB;QACpD,IAAI;YACF,OAAO,MAAM,QAAQ,IAAI,CAAC;gBAAC,IAAI,CAAC,0BAA0B,CAAC;gBAAS;aAAQ;QAC9E,EAAE,OAAO,OAAO;YACd,IAAI,UAAA,YAAY,CAAC,EAAE,CAAC,QAAQ;gBAC1B,WAAW,KAAK;gBAChB,MAAM,IAAI,QAAA,cAAc,CAAC,CAAA,8BAAA,EAAiC,oBAAA,oBAAoB,CAAA,GAAA,CAAK;YACrF;YACA,MAAM;QACR,SAAU;YACR,QAAQ,KAAK;QACf;IACF;;AArEF,QAAA,yBAAA,GAAA"}},
    {"offset": {"line": 4561, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4565, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc/azure_machine_workflow.ts"],"sourcesContent":["import { addAzureParams, AZURE_BASE_URL } from '../../../client-side-encryption/providers/azure';\nimport { MongoAzureError } from '../../../error';\nimport { get } from '../../../utils';\nimport type { OIDCCallbackFunction, OIDCCallbackParams, OIDCResponse } from '../mongodb_oidc';\n\n/** Azure request headers. */\nconst AZURE_HEADERS = Object.freeze({ Metadata: 'true', Accept: 'application/json' });\n\n/** Invalid endpoint result error. */\nconst ENDPOINT_RESULT_ERROR =\n  'Azure endpoint did not return a value with only access_token and expires_in properties';\n\n/** Error for when the token audience is missing in the environment. */\nconst TOKEN_RESOURCE_MISSING_ERROR =\n  'TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure.';\n\n/**\n * The callback function to be used in the automated callback workflow.\n * @param params - The OIDC callback parameters.\n * @returns The OIDC response.\n */\nexport const callback: OIDCCallbackFunction = async (\n  params: OIDCCallbackParams\n): Promise<OIDCResponse> => {\n  const tokenAudience = params.tokenAudience;\n  const username = params.username;\n  if (!tokenAudience) {\n    throw new MongoAzureError(TOKEN_RESOURCE_MISSING_ERROR);\n  }\n  const response = await getAzureTokenData(tokenAudience, username);\n  if (!isEndpointResultValid(response)) {\n    throw new MongoAzureError(ENDPOINT_RESULT_ERROR);\n  }\n  return response;\n};\n\n/**\n * Hit the Azure endpoint to get the token data.\n */\nasync function getAzureTokenData(tokenAudience: string, username?: string): Promise<OIDCResponse> {\n  const url = new URL(AZURE_BASE_URL);\n  addAzureParams(url, tokenAudience, username);\n  const response = await get(url, {\n    headers: AZURE_HEADERS\n  });\n  if (response.status !== 200) {\n    throw new MongoAzureError(\n      `Status code ${response.status} returned from the Azure endpoint. Response body: ${response.body}`\n    );\n  }\n  const result = JSON.parse(response.body);\n  return {\n    accessToken: result.access_token,\n    expiresInSeconds: Number(result.expires_in)\n  };\n}\n\n/**\n * Determines if a result returned from the endpoint is valid.\n * This means the result is not nullish, contains the access_token required field\n * and the expires_in required field.\n */\nfunction isEndpointResultValid(\n  token: unknown\n): token is { access_token: unknown; expires_in: unknown } {\n  if (token == null || typeof token !== 'object') return false;\n  return (\n    'accessToken' in token &&\n    typeof token.accessToken === 'string' &&\n    'expiresInSeconds' in token &&\n    typeof token.expiresInSeconds === 'number'\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AACA,MAAA;AAGA,2BAAA,GACA,MAAM,gBAAgB,OAAO,MAAM,CAAC;IAAE,UAAU;IAAQ,QAAQ;AAAkB;AAElF,mCAAA,GACA,MAAM,wBACJ;AAEF,qEAAA,GACA,MAAM,+BACJ;AAEF;;;;IAKO,MAAM,WAAiC,OAC5C;IAEA,MAAM,gBAAgB,OAAO,aAAa;IAC1C,MAAM,WAAW,OAAO,QAAQ;IAChC,IAAI,CAAC,eAAe;QAClB,MAAM,IAAI,QAAA,eAAe,CAAC;IAC5B;IACA,MAAM,WAAW,MAAM,kBAAkB,eAAe;IACxD,IAAI,CAAC,sBAAsB,WAAW;QACpC,MAAM,IAAI,QAAA,eAAe,CAAC;IAC5B;IACA,OAAO;AACT;AAba,QAAA,QAAQ,GAAA;AAerB;;IAGA,eAAe,kBAAkB,aAAqB,EAAE,QAAiB;IACvE,MAAM,MAAM,IAAI,IAAI,QAAA,cAAc;IAClC,CAAA,GAAA,QAAA,cAAc,EAAC,KAAK,eAAe;IACnC,MAAM,WAAW,MAAM,CAAA,GAAA,QAAA,GAAG,EAAC,KAAK;QAC9B,SAAS;;IAEX,IAAI,SAAS,MAAM,KAAK,KAAK;QAC3B,MAAM,IAAI,QAAA,eAAe,CACvB,CAAA,YAAA,EAAe,SAAS,MAAM,CAAA,kDAAA,EAAqD,SAAS,IAAI,CAAA,CAAE;IAEtG;IACA,MAAM,SAAS,KAAK,KAAK,CAAC,SAAS,IAAI;IACvC,OAAO;QACL,aAAa,OAAO,YAAY;QAChC,kBAAkB,OAAO,OAAO,UAAU;;AAE9C;AAEA;;;;IAKA,SAAS,sBACP,KAAc;IAEd,IAAI,SAAS,QAAQ,OAAO,UAAU,UAAU,OAAO;IACvD,OACE,iBAAiB,SACjB,OAAO,MAAM,WAAW,KAAK,YAC7B,sBAAsB,SACtB,OAAO,MAAM,gBAAgB,KAAK;AAEtC"}},
    {"offset": {"line": 4621, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4625, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc/gcp_machine_workflow.ts"],"sourcesContent":["import { MongoGCPError } from '../../../error';\nimport { get } from '../../../utils';\nimport type { OIDCCallbackFunction, OIDCCallbackParams, OIDCResponse } from '../mongodb_oidc';\n\n/** GCP base URL. */\nconst GCP_BASE_URL =\n  'http://metadata/computeMetadata/v1/instance/service-accounts/default/identity';\n\n/** GCP request headers. */\nconst GCP_HEADERS = Object.freeze({ 'Metadata-Flavor': 'Google' });\n\n/** Error for when the token audience is missing in the environment. */\nconst TOKEN_RESOURCE_MISSING_ERROR =\n  'TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is gcp.';\n\n/**\n * The callback function to be used in the automated callback workflow.\n * @param params - The OIDC callback parameters.\n * @returns The OIDC response.\n */\nexport const callback: OIDCCallbackFunction = async (\n  params: OIDCCallbackParams\n): Promise<OIDCResponse> => {\n  const tokenAudience = params.tokenAudience;\n  if (!tokenAudience) {\n    throw new MongoGCPError(TOKEN_RESOURCE_MISSING_ERROR);\n  }\n  return await getGcpTokenData(tokenAudience);\n};\n\n/**\n * Hit the GCP endpoint to get the token data.\n */\nasync function getGcpTokenData(tokenAudience: string): Promise<OIDCResponse> {\n  const url = new URL(GCP_BASE_URL);\n  url.searchParams.append('audience', tokenAudience);\n  const response = await get(url, {\n    headers: GCP_HEADERS\n  });\n  if (response.status !== 200) {\n    throw new MongoGCPError(\n      `Status code ${response.status} returned from the GCP endpoint. Response body: ${response.body}`\n    );\n  }\n  return { accessToken: response.body };\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AAGA,kBAAA,GACA,MAAM,eACJ;AAEF,yBAAA,GACA,MAAM,cAAc,OAAO,MAAM,CAAC;IAAE,mBAAmB;AAAQ;AAE/D,qEAAA,GACA,MAAM,+BACJ;AAEF;;;;IAKO,MAAM,WAAiC,OAC5C;IAEA,MAAM,gBAAgB,OAAO,aAAa;IAC1C,IAAI,CAAC,eAAe;QAClB,MAAM,IAAI,QAAA,aAAa,CAAC;IAC1B;IACA,OAAO,MAAM,gBAAgB;AAC/B;AARa,QAAA,QAAQ,GAAA;AAUrB;;IAGA,eAAe,gBAAgB,aAAqB;IAClD,MAAM,MAAM,IAAI,IAAI;IACpB,IAAI,YAAY,CAAC,MAAM,CAAC,YAAY;IACpC,MAAM,WAAW,MAAM,CAAA,GAAA,QAAA,GAAG,EAAC,KAAK;QAC9B,SAAS;;IAEX,IAAI,SAAS,MAAM,KAAK,KAAK;QAC3B,MAAM,IAAI,QAAA,aAAa,CACrB,CAAA,YAAA,EAAe,SAAS,MAAM,CAAA,gDAAA,EAAmD,SAAS,IAAI,CAAA,CAAE;IAEpG;IACA,OAAO;QAAE,aAAa,SAAS,IAAI;IAAA;AACrC"}},
    {"offset": {"line": 4664, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4668, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc/k8s_machine_workflow.ts"],"sourcesContent":["import { readFile } from 'fs/promises';\n\nimport type { OIDCCallbackFunction, OIDCResponse } from '../mongodb_oidc';\n\n/** The fallback file name */\nconst FALLBACK_FILENAME = '/var/run/secrets/kubernetes.io/serviceaccount/token';\n\n/** The azure environment variable for the file name. */\nconst AZURE_FILENAME = 'AZURE_FEDERATED_TOKEN_FILE';\n\n/** The AWS environment variable for the file name. */\nconst AWS_FILENAME = 'AWS_WEB_IDENTITY_TOKEN_FILE';\n\n/**\n * The callback function to be used in the automated callback workflow.\n * @param params - The OIDC callback parameters.\n * @returns The OIDC response.\n */\nexport const callback: OIDCCallbackFunction = async (): Promise<OIDCResponse> => {\n  let filename: string;\n  if (process.env[AZURE_FILENAME]) {\n    filename = process.env[AZURE_FILENAME];\n  } else if (process.env[AWS_FILENAME]) {\n    filename = process.env[AWS_FILENAME];\n  } else {\n    filename = FALLBACK_FILENAME;\n  }\n  const token = await readFile(filename, 'utf8');\n  return { accessToken: token };\n};\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAIA,2BAAA,GACA,MAAM,oBAAoB;AAE1B,sDAAA,GACA,MAAM,iBAAiB;AAEvB,oDAAA,GACA,MAAM,eAAe;AAErB;;;;IAKO,MAAM,WAAiC;IAC5C,IAAI;IACJ,IAAI,QAAQ,GAAG,CAAC,eAAe,EAAE;QAC/B,WAAW,QAAQ,GAAG,CAAC,eAAe;IACxC,OAAO,IAAI,QAAQ,GAAG,CAAC,aAAa,EAAE;QACpC,WAAW,QAAQ,GAAG,CAAC,aAAa;IACtC,OAAO;QACL,WAAW;IACb;IACA,MAAM,QAAQ,MAAM,CAAA,GAAA,WAAA,QAAQ,EAAC,UAAU;IACvC,OAAO;QAAE,aAAa;IAAK;AAC7B;AAXa,QAAA,QAAQ,GAAA"}},
    {"offset": {"line": 4696, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4700, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc/token_cache.ts"],"sourcesContent":["import { MongoDriverError } from '../../../error';\nimport type { IdPInfo, OIDCResponse } from '../mongodb_oidc';\n\nclass MongoOIDCError extends MongoDriverError {}\n\n/** @internal */\nexport class TokenCache {\n  private accessToken?: string;\n  private refreshToken?: string;\n  private idpInfo?: IdPInfo;\n  private expiresInSeconds?: number;\n\n  get hasAccessToken(): boolean {\n    return !!this.accessToken;\n  }\n\n  get hasRefreshToken(): boolean {\n    return !!this.refreshToken;\n  }\n\n  get hasIdpInfo(): boolean {\n    return !!this.idpInfo;\n  }\n\n  getAccessToken(): string {\n    if (!this.accessToken) {\n      throw new MongoOIDCError('Attempted to get an access token when none exists.');\n    }\n    return this.accessToken;\n  }\n\n  getRefreshToken(): string {\n    if (!this.refreshToken) {\n      throw new MongoOIDCError('Attempted to get a refresh token when none exists.');\n    }\n    return this.refreshToken;\n  }\n\n  getIdpInfo(): IdPInfo {\n    if (!this.idpInfo) {\n      throw new MongoOIDCError('Attempted to get IDP information when none exists.');\n    }\n    return this.idpInfo;\n  }\n\n  put(response: OIDCResponse, idpInfo?: IdPInfo) {\n    this.accessToken = response.accessToken;\n    this.refreshToken = response.refreshToken;\n    this.expiresInSeconds = response.expiresInSeconds;\n    if (idpInfo) {\n      this.idpInfo = idpInfo;\n    }\n  }\n\n  removeAccessToken() {\n    this.accessToken = undefined;\n  }\n\n  removeRefreshToken() {\n    this.refreshToken = undefined;\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAGA,MAAM,uBAAuB,QAAA,gBAAgB;;AAE7C,cAAA,GACA,MAAa;IAMX,IAAI,iBAAc;QAChB,OAAO,CAAC,CAAC,IAAI,CAAC,WAAW;IAC3B;IAEA,IAAI,kBAAe;QACjB,OAAO,CAAC,CAAC,IAAI,CAAC,YAAY;IAC5B;IAEA,IAAI,aAAU;QACZ,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO;IACvB;IAEA,iBAAc;QACZ,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACrB,MAAM,IAAI,eAAe;QAC3B;QACA,OAAO,IAAI,CAAC,WAAW;IACzB;IAEA,kBAAe;QACb,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;YACtB,MAAM,IAAI,eAAe;QAC3B;QACA,OAAO,IAAI,CAAC,YAAY;IAC1B;IAEA,aAAU;QACR,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,MAAM,IAAI,eAAe;QAC3B;QACA,OAAO,IAAI,CAAC,OAAO;IACrB;IAEA,IAAI,QAAsB,EAAE,OAAiB,EAAA;QAC3C,IAAI,CAAC,WAAW,GAAG,SAAS,WAAW;QACvC,IAAI,CAAC,YAAY,GAAG,SAAS,YAAY;QACzC,IAAI,CAAC,gBAAgB,GAAG,SAAS,gBAAgB;QACjD,IAAI,SAAS;YACX,IAAI,CAAC,OAAO,GAAG;QACjB;IACF;IAEA,oBAAiB;QACf,IAAI,CAAC,WAAW,GAAG;IACrB;IAEA,qBAAkB;QAChB,IAAI,CAAC,YAAY,GAAG;IACtB;;AAtDF,QAAA,UAAA,GAAA"}},
    {"offset": {"line": 4752, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4756, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc/token_machine_workflow.ts"],"sourcesContent":["import * as fs from 'fs';\n\nimport { MongoAWSError } from '../../../error';\nimport type { OIDCCallbackFunction, OIDCResponse } from '../mongodb_oidc';\n\n/** Error for when the token is missing in the environment. */\nconst TOKEN_MISSING_ERROR = 'OIDC_TOKEN_FILE must be set in the environment.';\n\n/**\n * The callback function to be used in the automated callback workflow.\n * @param params - The OIDC callback parameters.\n * @returns The OIDC response.\n */\nexport const callback: OIDCCallbackFunction = async (): Promise<OIDCResponse> => {\n  const tokenFile = process.env.OIDC_TOKEN_FILE;\n  if (!tokenFile) {\n    throw new MongoAWSError(TOKEN_MISSING_ERROR);\n  }\n  const token = await fs.promises.readFile(tokenFile, 'utf8');\n  return { accessToken: token };\n};\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAEA,MAAA;AAGA,4DAAA,GACA,MAAM,sBAAsB;AAE5B;;;;IAKO,MAAM,WAAiC;IAC5C,MAAM,YAAY,QAAQ,GAAG,CAAC,eAAe;IAC7C,IAAI,CAAC,WAAW;QACd,MAAM,IAAI,QAAA,aAAa,CAAC;IAC1B;IACA,MAAM,QAAQ,MAAM,GAAG,QAAQ,CAAC,QAAQ,CAAC,WAAW;IACpD,OAAO;QAAE,aAAa;IAAK;AAC7B;AAPa,QAAA,QAAQ,GAAA"}},
    {"offset": {"line": 4779, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4783, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc.ts"],"sourcesContent":["import type { Document } from '../../bson';\nimport { MongoInvalidArgumentError, MongoMissingCredentialsError } from '../../error';\nimport type { HandshakeDocument } from '../connect';\nimport type { Connection } from '../connection';\nimport { type AuthContext, AuthProvider } from './auth_provider';\nimport type { MongoCredentials } from './mongo_credentials';\nimport { AutomatedCallbackWorkflow } from './mongodb_oidc/automated_callback_workflow';\nimport { callback as azureCallback } from './mongodb_oidc/azure_machine_workflow';\nimport { callback as gcpCallback } from './mongodb_oidc/gcp_machine_workflow';\nimport { callback as k8sCallback } from './mongodb_oidc/k8s_machine_workflow';\nimport { TokenCache } from './mongodb_oidc/token_cache';\nimport { callback as testCallback } from './mongodb_oidc/token_machine_workflow';\n\n/** Error when credentials are missing. */\nconst MISSING_CREDENTIALS_ERROR = 'AuthContext must provide credentials.';\n\n/**\n * The information returned by the server on the IDP server.\n * @public\n */\nexport interface IdPInfo {\n  /**\n   * A URL which describes the Authentication Server. This identifier should\n   * be the iss of provided access tokens, and be viable for RFC8414 metadata\n   * discovery and RFC9207 identification.\n   */\n  issuer: string;\n  /** A unique client ID for this OIDC client. */\n  clientId: string;\n  /** A list of additional scopes to request from IdP. */\n  requestScopes?: string[];\n}\n\n/**\n * The response from the IdP server with the access token and\n * optional expiration time and refresh token.\n * @public\n */\nexport interface IdPServerResponse {\n  /** The OIDC access token. */\n  accessToken: string;\n  /** The time when the access token expires. For future use. */\n  expiresInSeconds?: number;\n  /** The refresh token, if applicable, to be used by the callback to request a new token from the issuer. */\n  refreshToken?: string;\n}\n\n/**\n * The response required to be returned from the machine or\n * human callback workflows' callback.\n * @public\n */\nexport interface OIDCResponse {\n  /** The OIDC access token. */\n  accessToken: string;\n  /** The time when the access token expires. For future use. */\n  expiresInSeconds?: number;\n  /** The refresh token, if applicable, to be used by the callback to request a new token from the issuer. */\n  refreshToken?: string;\n}\n\n/**\n * The parameters that the driver provides to the user supplied\n * human or machine callback.\n *\n * The version number is used to communicate callback API changes that are not breaking but that\n * users may want to know about and review their implementation. Users may wish to check the version\n * number and throw an error if their expected version number and the one provided do not match.\n * @public\n */\nexport interface OIDCCallbackParams {\n  /** Optional username. */\n  username?: string;\n  /** The context in which to timeout the OIDC callback. */\n  timeoutContext: AbortSignal;\n  /** The current OIDC API version. */\n  version: 1;\n  /** The IdP information returned from the server. */\n  idpInfo?: IdPInfo;\n  /** The refresh token, if applicable, to be used by the callback to request a new token from the issuer. */\n  refreshToken?: string;\n  /** The token audience for GCP and Azure. */\n  tokenAudience?: string;\n}\n\n/**\n * The signature of the human or machine callback functions.\n * @public\n */\nexport type OIDCCallbackFunction = (params: OIDCCallbackParams) => Promise<OIDCResponse>;\n\n/** The current version of OIDC implementation. */\nexport const OIDC_VERSION = 1;\n\ntype EnvironmentName = 'test' | 'azure' | 'gcp' | 'k8s' | undefined;\n\n/** @internal */\nexport interface Workflow {\n  cache: TokenCache;\n\n  /**\n   * All device workflows must implement this method in order to get the access\n   * token and then call authenticate with it.\n   */\n  execute(\n    connection: Connection,\n    credentials: MongoCredentials,\n    response?: Document\n  ): Promise<void>;\n\n  /**\n   * Each workflow should specify the correct custom behaviour for reauthentication.\n   */\n  reauthenticate(connection: Connection, credentials: MongoCredentials): Promise<void>;\n\n  /**\n   * Get the document to add for speculative authentication.\n   */\n  speculativeAuth(connection: Connection, credentials: MongoCredentials): Promise<Document>;\n}\n\n/** @internal */\nexport const OIDC_WORKFLOWS: Map<EnvironmentName, () => Workflow> = new Map();\nOIDC_WORKFLOWS.set('test', () => new AutomatedCallbackWorkflow(new TokenCache(), testCallback));\nOIDC_WORKFLOWS.set('azure', () => new AutomatedCallbackWorkflow(new TokenCache(), azureCallback));\nOIDC_WORKFLOWS.set('gcp', () => new AutomatedCallbackWorkflow(new TokenCache(), gcpCallback));\nOIDC_WORKFLOWS.set('k8s', () => new AutomatedCallbackWorkflow(new TokenCache(), k8sCallback));\n\n/**\n * OIDC auth provider.\n */\nexport class MongoDBOIDC extends AuthProvider {\n  workflow: Workflow;\n\n  /**\n   * Instantiate the auth provider.\n   */\n  constructor(workflow?: Workflow) {\n    super();\n    if (!workflow) {\n      throw new MongoInvalidArgumentError('No workflow provided to the OIDC auth provider.');\n    }\n    this.workflow = workflow;\n  }\n\n  /**\n   * Authenticate using OIDC\n   */\n  override async auth(authContext: AuthContext): Promise<void> {\n    const { connection, reauthenticating, response } = authContext;\n    if (response?.speculativeAuthenticate?.done && !reauthenticating) {\n      return;\n    }\n    const credentials = getCredentials(authContext);\n    if (reauthenticating) {\n      await this.workflow.reauthenticate(connection, credentials);\n    } else {\n      await this.workflow.execute(connection, credentials, response);\n    }\n  }\n\n  /**\n   * Add the speculative auth for the initial handshake.\n   */\n  override async prepare(\n    handshakeDoc: HandshakeDocument,\n    authContext: AuthContext\n  ): Promise<HandshakeDocument> {\n    const { connection } = authContext;\n    const credentials = getCredentials(authContext);\n    const result = await this.workflow.speculativeAuth(connection, credentials);\n    return { ...handshakeDoc, ...result };\n  }\n}\n\n/**\n * Get credentials from the auth context, throwing if they do not exist.\n */\nfunction getCredentials(authContext: AuthContext): MongoCredentials {\n  const { credentials } = authContext;\n  if (!credentials) {\n    throw new MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);\n  }\n  return credentials;\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAGA,MAAA;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,wCAAA,GACA,MAAM,4BAA4B;AA6ElC,gDAAA,GACa,QAAA,YAAY,GAAG;AA6B5B,cAAA,GACa,QAAA,cAAc,GAAyC,IAAI;AACxE,QAAA,cAAc,CAAC,GAAG,CAAC,QAAQ,IAAM,IAAI,8BAAA,yBAAyB,CAAC,IAAI,cAAA,UAAU,IAAI,yBAAA,QAAY;AAC7F,QAAA,cAAc,CAAC,GAAG,CAAC,SAAS,IAAM,IAAI,8BAAA,yBAAyB,CAAC,IAAI,cAAA,UAAU,IAAI,yBAAA,QAAa;AAC/F,QAAA,cAAc,CAAC,GAAG,CAAC,OAAO,IAAM,IAAI,8BAAA,yBAAyB,CAAC,IAAI,cAAA,UAAU,IAAI,uBAAA,QAAW;AAC3F,QAAA,cAAc,CAAC,GAAG,CAAC,OAAO,IAAM,IAAI,8BAAA,yBAAyB,CAAC,IAAI,cAAA,UAAU,IAAI,uBAAA,QAAW;AAE3F;;IAGA,MAAa,oBAAoB,gBAAA,YAAY;IAG3C;;QAGA,YAAY,QAAmB,CAAA;QAC7B,KAAK;QACL,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,QAAA,yBAAyB,CAAC;QACtC;QACA,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA;;QAGS,MAAM,KAAK,WAAwB,EAAA;QAC1C,MAAM,EAAE,UAAU,EAAE,gBAAgB,EAAE,QAAQ,EAAE,GAAG;QACnD,IAAI,UAAU,yBAAyB,QAAQ,CAAC,kBAAkB;YAChE;QACF;QACA,MAAM,cAAc,eAAe;QACnC,IAAI,kBAAkB;YACpB,MAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY;QACjD,OAAO;YACL,MAAM,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,YAAY,aAAa;QACvD;IACF;IAEA;;QAGS,MAAM,QACb,YAA+B,EAC/B,WAAwB,EAAA;QAExB,MAAM,EAAE,UAAU,EAAE,GAAG;QACvB,MAAM,cAAc,eAAe;QACnC,MAAM,SAAS,MAAM,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,YAAY;QAC/D,OAAO;YAAE,GAAG,YAAY;YAAE,GAAG,MAAM;QAAA;IACrC;;AAzCF,QAAA,WAAA,GAAA;AA4CA;;IAGA,SAAS,eAAe,WAAwB;IAC9C,MAAM,EAAE,WAAW,EAAE,GAAG;IACxB,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,QAAA,4BAA4B,CAAC;IACzC;IACA,OAAO;AACT"}},
    {"offset": {"line": 4851, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4855, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/mongodb_oidc/human_callback_workflow.ts"],"sourcesContent":["import { BSON } from '../../../bson';\nimport { MONGODB_ERROR_CODES, MongoError, MongoOIDCError } from '../../../error';\nimport { Timeout, TimeoutError } from '../../../timeout';\nimport { type Connection } from '../../connection';\nimport { type MongoCredentials } from '../mongo_credentials';\nimport {\n  type IdPInfo,\n  OIDC_VERSION,\n  type OIDCCallbackFunction,\n  type OIDCCallbackParams,\n  type OIDCResponse\n} from '../mongodb_oidc';\nimport { CallbackWorkflow, HUMAN_TIMEOUT_MS } from './callback_workflow';\nimport { type TokenCache } from './token_cache';\n\n/**\n * Class implementing behaviour for the non human callback workflow.\n * @internal\n */\nexport class HumanCallbackWorkflow extends CallbackWorkflow {\n  /**\n   * Instantiate the human callback workflow.\n   */\n  constructor(cache: TokenCache, callback: OIDCCallbackFunction) {\n    super(cache, callback);\n  }\n\n  /**\n   * Execute the OIDC human callback workflow.\n   */\n  async execute(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    // Check if the Client Cache has an access token.\n    // If it does, cache the access token in the Connection Cache and perform a One-Step SASL conversation\n    // using the access token. If the server returns an Authentication error (18),\n    // invalidate the access token token from the Client Cache, clear the Connection Cache,\n    // and restart the authentication flow. Raise any other errors to the user. On success, exit the algorithm.\n    if (this.cache.hasAccessToken) {\n      const token = this.cache.getAccessToken();\n      connection.accessToken = token;\n      try {\n        return await this.finishAuthentication(connection, credentials, token);\n      } catch (error) {\n        if (\n          error instanceof MongoError &&\n          error.code === MONGODB_ERROR_CODES.AuthenticationFailed\n        ) {\n          this.cache.removeAccessToken();\n          delete connection.accessToken;\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n    // Check if the Client Cache has a refresh token.\n    // If it does, call the OIDC Human Callback with the cached refresh token and IdpInfo to get a\n    // new access token. Cache the new access token in the Client Cache and Connection Cache.\n    // Perform a One-Step SASL conversation using the new access token. If the the server returns\n    // an Authentication error (18), clear the refresh token, invalidate the access token from the\n    // Client Cache, clear the Connection Cache, and restart the authentication flow. Raise any other\n    // errors to the user. On success, exit the algorithm.\n    if (this.cache.hasRefreshToken) {\n      const refreshToken = this.cache.getRefreshToken();\n      const result = await this.fetchAccessToken(\n        this.cache.getIdpInfo(),\n        credentials,\n        refreshToken\n      );\n      this.cache.put(result);\n      connection.accessToken = result.accessToken;\n      try {\n        return await this.finishAuthentication(connection, credentials, result.accessToken);\n      } catch (error) {\n        if (\n          error instanceof MongoError &&\n          error.code === MONGODB_ERROR_CODES.AuthenticationFailed\n        ) {\n          this.cache.removeRefreshToken();\n          delete connection.accessToken;\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n\n    // Start a new Two-Step SASL conversation.\n    // Run a PrincipalStepRequest to get the IdpInfo.\n    // Call the OIDC Human Callback with the new IdpInfo to get a new access token and optional refresh\n    // token. Drivers MUST NOT pass a cached refresh token to the callback when performing\n    // a new Two-Step conversation. Cache the new IdpInfo and refresh token in the Client Cache and the\n    // new access token in the Client Cache and Connection Cache.\n    // Attempt to authenticate using a JwtStepRequest with the new access token. Raise any errors to the user.\n    const startResponse = await this.startAuthentication(connection, credentials);\n    const conversationId = startResponse.conversationId;\n    const idpInfo = BSON.deserialize(startResponse.payload.buffer) as IdPInfo;\n    const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);\n    this.cache.put(callbackResponse, idpInfo);\n    connection.accessToken = callbackResponse.accessToken;\n    return await this.finishAuthentication(\n      connection,\n      credentials,\n      callbackResponse.accessToken,\n      conversationId\n    );\n  }\n\n  /**\n   * Fetches an access token using the callback.\n   */\n  private async fetchAccessToken(\n    idpInfo: IdPInfo,\n    credentials: MongoCredentials,\n    refreshToken?: string\n  ): Promise<OIDCResponse> {\n    const controller = new AbortController();\n    const params: OIDCCallbackParams = {\n      timeoutContext: controller.signal,\n      version: OIDC_VERSION,\n      idpInfo: idpInfo\n    };\n    if (credentials.username) {\n      params.username = credentials.username;\n    }\n    if (refreshToken) {\n      params.refreshToken = refreshToken;\n    }\n    const timeout = Timeout.expires(HUMAN_TIMEOUT_MS);\n    try {\n      return await Promise.race([this.executeAndValidateCallback(params), timeout]);\n    } catch (error) {\n      if (TimeoutError.is(error)) {\n        controller.abort();\n        throw new MongoOIDCError(`OIDC callback timed out after ${HUMAN_TIMEOUT_MS}ms.`);\n      }\n      throw error;\n    } finally {\n      timeout.clear();\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4969, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4973, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/plain.ts"],"sourcesContent":["import { Binary } from '../../bson';\nimport { MongoMissingCredentialsError } from '../../error';\nimport { ns } from '../../utils';\nimport { type AuthContext, AuthProvider } from './auth_provider';\n\nexport class Plain extends AuthProvider {\n  override async auth(authContext: AuthContext): Promise<void> {\n    const { connection, credentials } = authContext;\n    if (!credentials) {\n      throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n\n    const { username, password } = credentials;\n\n    const payload = new Binary(Buffer.from(`\\x00${username}\\x00${password}`));\n    const command = {\n      saslStart: 1,\n      mechanism: 'PLAIN',\n      payload: payload,\n      autoAuthorize: 1\n    };\n\n    await connection.command(ns('$external.$cmd'), command, undefined);\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAa,cAAc,gBAAA,YAAY;IAC5B,MAAM,KAAK,WAAwB,EAAA;QAC1C,MAAM,EAAE,UAAU,EAAE,WAAW,EAAE,GAAG;QACpC,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,QAAA,4BAA4B,CAAC;QACzC;QAEA,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG;QAE/B,MAAM,UAAU,IAAI,OAAA,MAAM,CAAC,OAAO,IAAI,CAAC,CAAA,IAAA,EAAO,SAAQ,IAAA,EAAO,SAAQ,CAAE;QACvE,MAAM,UAAU;YACd,WAAW;YACX,WAAW;YACX,SAAS;YACT,eAAe;;QAGjB,MAAM,WAAW,OAAO,CAAC,CAAA,GAAA,QAAA,EAAE,EAAC,mBAAmB,SAAS;IAC1D;;AAlBF,QAAA,KAAA,GAAA"}},
    {"offset": {"line": 5000, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5004, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/scram.ts"],"sourcesContent":["import { saslprep } from '@mongodb-js/saslprep';\nimport * as crypto from 'crypto';\n\nimport { Binary, type Document } from '../../bson';\nimport {\n  MongoInvalidArgumentError,\n  MongoMissingCredentialsError,\n  MongoRuntimeError\n} from '../../error';\nimport { ns, randomBytes } from '../../utils';\nimport type { HandshakeDocument } from '../connect';\nimport { type AuthContext, AuthProvider } from './auth_provider';\nimport type { MongoCredentials } from './mongo_credentials';\nimport { AuthMechanism } from './providers';\n\ntype CryptoMethod = 'sha1' | 'sha256';\n\nclass ScramSHA extends AuthProvider {\n  cryptoMethod: CryptoMethod;\n\n  constructor(cryptoMethod: CryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  override async prepare(\n    handshakeDoc: HandshakeDocument,\n    authContext: AuthContext\n  ): Promise<HandshakeDocument> {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n      throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n\n    const nonce = await randomBytes(24);\n    // store the nonce for later use\n    authContext.nonce = nonce;\n\n    const request = {\n      ...handshakeDoc,\n      speculativeAuthenticate: {\n        ...makeFirstMessage(cryptoMethod, credentials, nonce),\n        db: credentials.source\n      }\n    };\n\n    return request;\n  }\n\n  override async auth(authContext: AuthContext) {\n    const { reauthenticating, response } = authContext;\n    if (response?.speculativeAuthenticate && !reauthenticating) {\n      return await continueScramConversation(\n        this.cryptoMethod,\n        response.speculativeAuthenticate,\n        authContext\n      );\n    }\n    return await executeScram(this.cryptoMethod, authContext);\n  }\n}\n\nfunction cleanUsername(username: string) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username: string, nonce: Buffer) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([\n    Buffer.from('n=', 'utf8'),\n    Buffer.from(username, 'utf8'),\n    Buffer.from(',r=', 'utf8'),\n    Buffer.from(nonce.toString('base64'), 'utf8')\n  ]);\n}\n\nfunction makeFirstMessage(\n  cryptoMethod: CryptoMethod,\n  credentials: MongoCredentials,\n  nonce: Buffer\n) {\n  const username = cleanUsername(credentials.username);\n  const mechanism =\n    cryptoMethod === 'sha1' ? AuthMechanism.MONGODB_SCRAM_SHA1 : AuthMechanism.MONGODB_SCRAM_SHA256;\n\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(\n      Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])\n    ),\n    autoAuthorize: 1,\n    options: { skipEmptyExchange: true }\n  };\n}\n\nasync function executeScram(cryptoMethod: CryptoMethod, authContext: AuthContext): Promise<void> {\n  const { connection, credentials } = authContext;\n  if (!credentials) {\n    throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n  }\n  if (!authContext.nonce) {\n    throw new MongoInvalidArgumentError('AuthContext must contain a valid nonce property');\n  }\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  const response = await connection.command(ns(`${db}.$cmd`), saslStartCmd, undefined);\n  await continueScramConversation(cryptoMethod, response, authContext);\n}\n\nasync function continueScramConversation(\n  cryptoMethod: CryptoMethod,\n  response: Document,\n  authContext: AuthContext\n): Promise<void> {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  if (!credentials) {\n    throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n  }\n  if (!authContext.nonce) {\n    throw new MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce');\n  }\n  const nonce = authContext.nonce;\n\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n\n  const processedPassword =\n    cryptoMethod === 'sha256' ? saslprep(password) : passwordDigest(username, password);\n\n  const payload: Binary = Buffer.isBuffer(response.payload)\n    ? new Binary(response.payload)\n    : response.payload;\n\n  const dict = parsePayload(payload);\n\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);\n  }\n\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(\n    processedPassword,\n    Buffer.from(salt, 'base64'),\n    iterations,\n    cryptoMethod\n  );\n\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [\n    clientFirstMessageBare(username, nonce),\n    payload.toString('utf8'),\n    withoutProof\n  ].join(',');\n\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n\n  const r = await connection.command(ns(`${db}.$cmd`), saslContinueCmd, undefined);\n  const parsedResponse = parsePayload(r.payload);\n\n  if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n    throw new MongoRuntimeError('Server returned an invalid signature');\n  }\n\n  if (r.done !== false) {\n    // If the server sends r.done === true we can save one RTT\n    return;\n  }\n\n  const retrySaslContinueCmd = {\n    saslContinue: 1,\n    conversationId: r.conversationId,\n    payload: Buffer.alloc(0)\n  };\n\n  await connection.command(ns(`${db}.$cmd`), retrySaslContinueCmd, undefined);\n}\n\nfunction parsePayload(payload: Binary) {\n  const payloadStr = payload.toString('utf8');\n  const dict: Document = {};\n  const parts = payloadStr.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = (parts[i].match(/^([^=]*)=(.*)$/) ?? []).slice(1);\n    dict[valueParts[0]] = valueParts[1];\n  }\n  return dict;\n}\n\nfunction passwordDigest(username: string, password: string) {\n  if (typeof username !== 'string') {\n    throw new MongoInvalidArgumentError('Username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoInvalidArgumentError('Password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoInvalidArgumentError('Password cannot be empty');\n  }\n\n  let md5: crypto.Hash;\n  try {\n    md5 = crypto.createHash('md5');\n  } catch (err) {\n    if (crypto.getFips()) {\n      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\n      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\n      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\n    }\n    throw err;\n  }\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n\n// XOR two buffers\nfunction xor(a: Buffer, b: Buffer) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method: CryptoMethod, text: Buffer) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method: CryptoMethod, key: Buffer, text: Buffer | string) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\ninterface HICache {\n  [key: string]: Buffer;\n}\n\nlet _hiCache: HICache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data: string, salt: Buffer, iterations: number, cryptoMethod: CryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(\n    data,\n    salt,\n    iterations,\n    hiLengthMap[cryptoMethod],\n    cryptoMethod\n  );\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs: Buffer, rhs: Uint8Array) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nexport class ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n}\n\nexport class ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5268, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5272, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/cmap/auth/x509.ts"],"sourcesContent":["import type { Document } from '../../bson';\nimport { MongoMissingCredentialsError } from '../../error';\nimport { ns } from '../../utils';\nimport type { HandshakeDocument } from '../connect';\nimport { type AuthContext, AuthProvider } from './auth_provider';\nimport type { MongoCredentials } from './mongo_credentials';\n\nexport class X509 extends AuthProvider {\n  override async prepare(\n    handshakeDoc: HandshakeDocument,\n    authContext: AuthContext\n  ): Promise<HandshakeDocument> {\n    const { credentials } = authContext;\n    if (!credentials) {\n      throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n    return { ...handshakeDoc, speculativeAuthenticate: x509AuthenticateCommand(credentials) };\n  }\n\n  override async auth(authContext: AuthContext) {\n    const connection = authContext.connection;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n      throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n    const response = authContext.response;\n\n    if (response?.speculativeAuthenticate) {\n      return;\n    }\n\n    await connection.command(ns('$external.$cmd'), x509AuthenticateCommand(credentials), undefined);\n  }\n}\n\nfunction x509AuthenticateCommand(credentials: MongoCredentials) {\n  const command: Document = { authenticate: 1, mechanism: 'MONGODB-X509' };\n  if (credentials.username) {\n    command.user = credentials.username;\n  }\n\n  return command;\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AACA,MAAA;AAEA,MAAA;AAGA,MAAa,aAAa,gBAAA,YAAY;IAC3B,MAAM,QACb,YAA+B,EAC/B,WAAwB,EAAA;QAExB,MAAM,EAAE,WAAW,EAAE,GAAG;QACxB,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,QAAA,4BAA4B,CAAC;QACzC;QACA,OAAO;YAAE,GAAG,YAAY;YAAE,yBAAyB,wBAAwB;QAAY;IACzF;IAES,MAAM,KAAK,WAAwB,EAAA;QAC1C,MAAM,aAAa,YAAY,UAAU;QACzC,MAAM,cAAc,YAAY,WAAW;QAC3C,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,QAAA,4BAA4B,CAAC;QACzC;QACA,MAAM,WAAW,YAAY,QAAQ;QAErC,IAAI,UAAU,yBAAyB;YACrC;QACF;QAEA,MAAM,WAAW,OAAO,CAAC,CAAA,GAAA,QAAA,EAAE,EAAC,mBAAmB,wBAAwB,cAAc;IACvF;;AAzBF,QAAA,IAAA,GAAA;AA4BA,SAAS,wBAAwB,WAA6B;IAC5D,MAAM,UAAoB;QAAE,cAAc;QAAG,WAAW;IAAc;IACtE,IAAI,YAAY,QAAQ,EAAE;QACxB,QAAQ,IAAI,GAAG,YAAY,QAAQ;IACrC;IAEA,OAAO;AACT"}},
    {"offset": {"line": 5315, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}