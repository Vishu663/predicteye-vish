{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/operation.ts"],"sourcesContent":["import { type BSONSerializeOptions, type Document, resolveBSONOptions } from '../bson';\nimport { type Abortable } from '../mongo_types';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport type { MongoDBNamespace } from '../utils';\n\nexport const Aspect = {\n  READ_OPERATION: Symbol('READ_OPERATION'),\n  WRITE_OPERATION: Symbol('WRITE_OPERATION'),\n  RETRYABLE: Symbol('RETRYABLE'),\n  EXPLAINABLE: Symbol('EXPLAINABLE'),\n  SKIP_COLLATION: Symbol('SKIP_COLLATION'),\n  CURSOR_CREATING: Symbol('CURSOR_CREATING'),\n  MUST_SELECT_SAME_SERVER: Symbol('MUST_SELECT_SAME_SERVER'),\n  COMMAND_BATCHING: Symbol('COMMAND_BATCHING')\n} as const;\n\n/** @public */\nexport type Hint = string | Document;\n\n/** @public */\nexport interface OperationOptions extends BSONSerializeOptions {\n  /** Specify ClientSession for this command */\n  session?: ClientSession;\n  willRetryWrite?: boolean;\n\n  /** The preferred read preference (ReadPreference.primary, ReadPreference.primary_preferred, ReadPreference.secondary, ReadPreference.secondary_preferred, ReadPreference.nearest). */\n  readPreference?: ReadPreferenceLike;\n\n  /** @internal Hints to `executeOperation` that this operation should not unpin on an ended transaction */\n  bypassPinningCheck?: boolean;\n  omitReadPreference?: boolean;\n\n  /** @internal Hint to `executeOperation` to omit maxTimeMS */\n  omitMaxTimeMS?: boolean;\n\n  /**\n   * @experimental\n   * Specifies the time an operation will run until it throws a timeout error\n   */\n  timeoutMS?: number;\n}\n\n/**\n * This class acts as a parent class for any operation and is responsible for setting this.options,\n * as well as setting and getting a session.\n * Additionally, this class implements `hasAspect`, which determines whether an operation has\n * a specific aspect.\n * @internal\n */\nexport abstract class AbstractOperation<TResult = any> {\n  ns!: MongoDBNamespace;\n  readPreference: ReadPreference;\n  server!: Server;\n  bypassPinningCheck: boolean;\n  trySecondaryWrite: boolean;\n\n  // BSON serialization options\n  bsonOptions?: BSONSerializeOptions;\n\n  options: OperationOptions & Abortable;\n\n  /** Specifies the time an operation will run until it throws a timeout error. */\n  timeoutMS?: number;\n\n  private _session: ClientSession | undefined;\n\n  static aspects?: Set<symbol>;\n\n  constructor(options: OperationOptions & Abortable = {}) {\n    this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION)\n      ? ReadPreference.primary\n      : (ReadPreference.fromOptions(options) ?? ReadPreference.primary);\n\n    // Pull the BSON serialize options from the already-resolved options\n    this.bsonOptions = resolveBSONOptions(options);\n\n    this._session = options.session != null ? options.session : undefined;\n\n    this.options = options;\n    this.bypassPinningCheck = !!options.bypassPinningCheck;\n    this.trySecondaryWrite = false;\n  }\n\n  /** Must match the first key of the command object sent to the server.\n  Command name should be stateless (should not use 'this' keyword) */\n  abstract get commandName(): string;\n\n  abstract execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<TResult>;\n\n  hasAspect(aspect: symbol): boolean {\n    const ctor = this.constructor as { aspects?: Set<symbol> };\n    if (ctor.aspects == null) {\n      return false;\n    }\n\n    return ctor.aspects.has(aspect);\n  }\n\n  // Make sure the session is not writable from outside this class.\n  get session(): ClientSession | undefined {\n    return this._session;\n  }\n\n  clearSession() {\n    this._session = undefined;\n  }\n\n  resetBatch(): boolean {\n    return true;\n  }\n\n  get canRetryRead(): boolean {\n    return this.hasAspect(Aspect.RETRYABLE) && this.hasAspect(Aspect.READ_OPERATION);\n  }\n\n  get canRetryWrite(): boolean {\n    return this.hasAspect(Aspect.RETRYABLE) && this.hasAspect(Aspect.WRITE_OPERATION);\n  }\n}\n\nexport function defineAspects(\n  operation: { aspects?: Set<symbol> },\n  aspects: symbol | symbol[] | Set<symbol>\n): Set<symbol> {\n  if (!Array.isArray(aspects) && !(aspects instanceof Set)) {\n    aspects = [aspects];\n  }\n\n  aspects = new Set(aspects);\n  Object.defineProperty(operation, 'aspects', {\n    value: aspects,\n    writable: false\n  });\n\n  return aspects;\n}\n"],"names":[],"mappings":";;;;;AA+HA,QAAA,aAAA,GAAA;AA/HA,MAAA;AAEA,MAAA;AAMa,QAAA,MAAM,GAAG;IACpB,gBAAgB,OAAO;IACvB,iBAAiB,OAAO;IACxB,WAAW,OAAO;IAClB,aAAa,OAAO;IACpB,gBAAgB,OAAO;IACvB,iBAAiB,OAAO;IACxB,yBAAyB,OAAO;IAChC,kBAAkB,OAAO;;AA6B3B;;;;;;IAOA,MAAsB;IAmBpB,YAAY,UAAwC,CAAA,CAAE,CAAA;QACpD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,QAAA,MAAM,CAAC,eAAe,IACvD,kBAAA,cAAc,CAAC,OAAO,GACrB,kBAAA,cAAc,CAAC,WAAW,CAAC,YAAY,kBAAA,cAAc,CAAC,OAAO;QAElE,oEAAoE;QACpE,IAAI,CAAC,WAAW,GAAG,CAAA,GAAA,OAAA,kBAAkB,EAAC;QAEtC,IAAI,CAAC,QAAQ,GAAG,QAAQ,OAAO,IAAI,OAAO,QAAQ,OAAO,GAAG;QAE5D,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC,QAAQ,kBAAkB;QACtD,IAAI,CAAC,iBAAiB,GAAG;IAC3B;IAYA,UAAU,MAAc,EAAA;QACtB,MAAM,OAAO,IAAI,CAAC,WAAwC;QAC1D,IAAI,KAAK,OAAO,IAAI,MAAM;YACxB,OAAO;QACT;QAEA,OAAO,KAAK,OAAO,CAAC,GAAG,CAAC;IAC1B;IAEA,iEAAiE;IACjE,IAAI,UAAO;QACT,OAAO,IAAI,CAAC,QAAQ;IACtB;IAEA,eAAY;QACV,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA,aAAU;QACR,OAAO;IACT;IAEA,IAAI,eAAY;QACd,OAAO,IAAI,CAAC,SAAS,CAAC,QAAA,MAAM,CAAC,SAAS,KAAK,IAAI,CAAC,SAAS,CAAC,QAAA,MAAM,CAAC,cAAc;IACjF;IAEA,IAAI,gBAAa;QACf,OAAO,IAAI,CAAC,SAAS,CAAC,QAAA,MAAM,CAAC,SAAS,KAAK,IAAI,CAAC,SAAS,CAAC,QAAA,MAAM,CAAC,eAAe;IAClF;;AAxEF,QAAA,iBAAA,GAAA;AA2EA,SAAgB,cACd,SAAoC,EACpC,OAAwC;IAExC,IAAI,CAAC,MAAM,OAAO,CAAC,YAAY,CAAC,CAAC,mBAAmB,GAAG,GAAG;QACxD,UAAU;YAAC;SAAQ;IACrB;IAEA,UAAU,IAAI,IAAI;IAClB,OAAO,cAAc,CAAC,WAAW,WAAW;QAC1C,OAAO;QACP,UAAU;;IAGZ,OAAO;AACT"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/execute_operation.ts"],"sourcesContent":["import {\n  isRetryableReadError,\n  isRetryableWriteError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNotConnectedError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { ReadPreference } from '../read_preference';\nimport type { ServerDescription } from '../sdam/server_description';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  type ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { TimeoutContext } from '../timeout';\nimport { abortable, supportsRetryableWrites } from '../utils';\nimport { AbstractOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> =\n  TOperation extends AbstractOperation<infer K> ? K : never;\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nexport async function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, timeoutContext?: TimeoutContext | null): Promise<TResult> {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  const topology =\n    client.topology == null\n      ? await abortable(autoConnect(client), operation.options)\n      : client.topology;\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner: symbol | undefined;\n\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({ owner, explicit: false });\n  } else if (session.hasEnded) {\n    throw new MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n\n  if (\n    inTransaction &&\n    !readPreference.equals(ReadPreference.primary) &&\n    (hasReadAspect || operation.commandName === 'runCommand')\n  ) {\n    throw new MongoTransactionError(\n      `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n    );\n  }\n\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  timeoutContext ??= TimeoutContext.create({\n    session,\n    serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,\n    waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,\n    timeoutMS: operation.options.timeoutMS\n  });\n\n  try {\n    return await tryOperation(operation, {\n      topology,\n      timeoutContext,\n      session,\n      readPreference\n    });\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession();\n    }\n  }\n}\n\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nasync function autoConnect(client: MongoClient): Promise<Topology> {\n  if (client.topology == null) {\n    if (client.s.hasBeenClosed) {\n      throw new MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options.__skipPingOnConnect = true;\n    try {\n      await client.connect();\n      if (client.topology == null) {\n        throw new MongoRuntimeError(\n          'client.connect did not create a topology but also did not throw'\n        );\n      }\n      return client.topology;\n    } finally {\n      delete client.s.options.__skipPingOnConnect;\n    }\n  }\n  return client.topology;\n}\n\n/** @internal */\ntype RetryOptions = {\n  session: ClientSession | undefined;\n  readPreference: ReadPreference;\n  topology: Topology;\n  timeoutContext: TimeoutContext;\n};\n\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(\n  operation: T,\n  { topology, timeoutContext, session, readPreference }: RetryOptions\n): Promise<TResult> {\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  let server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName,\n    timeoutContext,\n    signal: operation.options.signal\n  });\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const inTransaction = session?.inTransaction() ?? false;\n\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n\n  const willRetryWrite =\n    topology.s.options.retryWrites &&\n    !inTransaction &&\n    supportsRetryableWrites(server) &&\n    operation.canRetryWrite;\n\n  const willRetry =\n    operation.hasAspect(Aspect.RETRYABLE) &&\n    session != null &&\n    ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite));\n\n  if (hasWriteAspect && willRetryWrite && session != null) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n\n  const maxTries = willRetry ? (timeoutContext.csotEnabled() ? Infinity : 2) : 1;\n  let previousOperationError: MongoError | undefined;\n  let previousServer: ServerDescription | undefined;\n\n  for (let tries = 0; tries < maxTries; tries++) {\n    if (previousOperationError) {\n      if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: previousOperationError\n        });\n      }\n\n      if (operation.hasAspect(Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {\n        throw previousOperationError;\n      }\n\n      if (hasWriteAspect && !isRetryableWriteError(previousOperationError))\n        throw previousOperationError;\n\n      if (hasReadAspect && !isRetryableReadError(previousOperationError))\n        throw previousOperationError;\n\n      if (\n        previousOperationError instanceof MongoNetworkError &&\n        operation.hasAspect(Aspect.CURSOR_CREATING) &&\n        session != null &&\n        session.isPinned &&\n        !session.inTransaction()\n      ) {\n        session.unpin({ force: true, forceClear: true });\n      }\n\n      server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        previousServer,\n        signal: operation.options.signal\n      });\n\n      if (hasWriteAspect && !supportsRetryableWrites(server)) {\n        throw new MongoUnexpectedServerResponseError(\n          'Selected server does not support retryable writes'\n        );\n      }\n    }\n\n    try {\n      // If tries > 0 and we are command batching we need to reset the batch.\n      if (tries > 0 && operation.hasAspect(Aspect.COMMAND_BATCHING)) {\n        operation.resetBatch();\n      }\n      return await operation.execute(server, session, timeoutContext);\n    } catch (operationError) {\n      if (!(operationError instanceof MongoError)) throw operationError;\n      if (\n        previousOperationError != null &&\n        operationError.hasErrorLabel(MongoErrorLabel.NoWritesPerformed)\n      ) {\n        throw previousOperationError;\n      }\n      previousServer = server.description;\n      previousOperationError = operationError;\n\n      // Reset timeouts\n      timeoutContext.clear();\n    }\n  }\n\n  throw (\n    previousOperationError ??\n    new MongoRuntimeError('Tried to propagate retryability error, but no error was found.')\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 287, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/get_more.ts"],"sourcesContent":["import type { Long } from '../bson';\nimport { CursorResponse } from '../cmap/wire_protocol/responses';\nimport { MongoRuntimeError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { maxWireVersion, type MongoDBNamespace } from '../utils';\nimport { AbstractOperation, Aspect, defineAspects, type OperationOptions } from './operation';\n\n/** @internal */\nexport interface GetMoreOptions extends OperationOptions {\n  /** Set the batchSize for the getMoreCommand when iterating over the query results. */\n  batchSize?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * getMore only supports 'comment' in server versions 4.4 and above.\n   */\n  comment?: unknown;\n  /** Number of milliseconds to wait before aborting the query. */\n  maxTimeMS?: number;\n  /** TODO(NODE-4413): Address bug with maxAwaitTimeMS not being passed in from the cursor correctly */\n  maxAwaitTimeMS?: number;\n}\n\n/**\n * GetMore command: https://www.mongodb.com/docs/manual/reference/command/getMore/\n * @internal\n */\nexport interface GetMoreCommand {\n  getMore: Long;\n  collection: string;\n  batchSize?: number;\n  maxTimeMS?: number;\n  /** Only supported on wire versions 10 or greater */\n  comment?: unknown;\n}\n\n/** @internal */\nexport class GetMoreOperation extends AbstractOperation {\n  cursorId: Long;\n  override options: GetMoreOptions;\n\n  constructor(ns: MongoDBNamespace, cursorId: Long, server: Server, options: GetMoreOptions) {\n    super(options);\n\n    this.options = options;\n    this.ns = ns;\n    this.cursorId = cursorId;\n    this.server = server;\n  }\n\n  override get commandName() {\n    return 'getMore' as const;\n  }\n  /**\n   * Although there is a server already associated with the get more operation, the signature\n   * for execute passes a server so we will just use that one.\n   */\n  override async execute(\n    server: Server,\n    _session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<CursorResponse> {\n    if (server !== this.server) {\n      throw new MongoRuntimeError('Getmore must run on the same server operation began on');\n    }\n\n    if (this.cursorId == null || this.cursorId.isZero()) {\n      throw new MongoRuntimeError('Unable to iterate cursor with no id');\n    }\n\n    const collection = this.ns.collection;\n    if (collection == null) {\n      // Cursors should have adopted the namespace returned by MongoDB\n      // which should always defined a collection name (even a pseudo one, ex. db.aggregate())\n      throw new MongoRuntimeError('A collection name must be determined before getMore');\n    }\n\n    const getMoreCmd: GetMoreCommand = {\n      getMore: this.cursorId,\n      collection\n    };\n\n    if (typeof this.options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(this.options.batchSize);\n    }\n\n    if (typeof this.options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (this.options.comment !== undefined && maxWireVersion(server) >= 9) {\n      getMoreCmd.comment = this.options.comment;\n    }\n\n    const commandOptions = {\n      returnFieldSelector: null,\n      documentsReturnedIn: 'nextBatch',\n      timeoutContext,\n      ...this.options\n    };\n\n    return await server.command(this.ns, getMoreCmd, commandOptions, CursorResponse);\n  }\n}\n\ndefineAspects(GetMoreOperation, [Aspect.READ_OPERATION, Aspect.MUST_SELECT_SAME_SERVER]);\n"],"names":[],"mappings":";;;;;AACA,MAAA;AACA,MAAA;AAIA,MAAA;AACA,MAAA;AA+BA,cAAA,GACA,MAAa,yBAAyB,YAAA,iBAAiB;IAIrD,YAAY,EAAoB,EAAE,QAAc,EAAE,MAAc,EAAE,OAAuB,CAAA;QACvF,KAAK,CAAC;QAEN,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,MAAM,GAAG;IAChB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IACA;;;QAIS,MAAM,QACb,MAAc,EACd,QAAmC,EACnC,cAA8B,EAAA;QAE9B,IAAI,WAAW,IAAI,CAAC,MAAM,EAAE;YAC1B,MAAM,IAAI,QAAA,iBAAiB,CAAC;QAC9B;QAEA,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI;YACnD,MAAM,IAAI,QAAA,iBAAiB,CAAC;QAC9B;QAEA,MAAM,aAAa,IAAI,CAAC,EAAE,CAAC,UAAU;QACrC,IAAI,cAAc,MAAM;YACtB,gEAAgE;YAChE,wFAAwF;YACxF,MAAM,IAAI,QAAA,iBAAiB,CAAC;QAC9B;QAEA,MAAM,aAA6B;YACjC,SAAS,IAAI,CAAC,QAAQ;YACtB;;QAGF,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,KAAK,UAAU;YAC9C,WAAW,SAAS,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS;QACxD;QAEA,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,cAAc,KAAK,UAAU;YACnD,WAAW,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc;QACpD;QAEA,iEAAiE;QACjE,gDAAgD;QAChD,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,aAAa,CAAA,GAAA,QAAA,cAAc,EAAC,WAAW,GAAG;YACrE,WAAW,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO;QAC3C;QAEA,MAAM,iBAAiB;YACrB,qBAAqB;YACrB,qBAAqB;YACrB;YACA,GAAG,IAAI,CAAC,OAAO;;QAGjB,OAAO,MAAM,OAAO,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,YAAY,gBAAgB,YAAA,cAAc;IACjF;;AAnEF,QAAA,gBAAA,GAAA;AAsEA,CAAA,GAAA,YAAA,aAAa,EAAC,kBAAkB;IAAC,YAAA,MAAM,CAAC,cAAc;IAAE,YAAA,MAAM,CAAC,uBAAuB;CAAC"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 356, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/kill_cursors.ts"],"sourcesContent":["import type { Long } from '../bson';\nimport { MongoRuntimeError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { type MongoDBNamespace, squashError } from '../utils';\nimport { AbstractOperation, Aspect, defineAspects, type OperationOptions } from './operation';\n\n/**\n * https://www.mongodb.com/docs/manual/reference/command/killCursors/\n * @internal\n */\ninterface KillCursorsCommand {\n  killCursors: string;\n  cursors: Long[];\n  comment?: unknown;\n}\n\nexport class KillCursorsOperation extends AbstractOperation {\n  cursorId: Long;\n\n  constructor(cursorId: Long, ns: MongoDBNamespace, server: Server, options: OperationOptions) {\n    super(options);\n    this.ns = ns;\n    this.cursorId = cursorId;\n    this.server = server;\n  }\n\n  override get commandName() {\n    return 'killCursors' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<void> {\n    if (server !== this.server) {\n      throw new MongoRuntimeError('Killcursor must run on the same server operation began on');\n    }\n\n    const killCursors = this.ns.collection;\n    if (killCursors == null) {\n      // Cursors should have adopted the namespace returned by MongoDB\n      // which should always defined a collection name (even a pseudo one, ex. db.aggregate())\n      throw new MongoRuntimeError('A collection name must be determined before killCursors');\n    }\n\n    const killCursorsCommand: KillCursorsCommand = {\n      killCursors,\n      cursors: [this.cursorId]\n    };\n    try {\n      await server.command(this.ns, killCursorsCommand, {\n        session,\n        timeoutContext\n      });\n    } catch (error) {\n      // The driver should never emit errors from killCursors, this is spec-ed behavior\n      squashError(error);\n    }\n  }\n}\n\ndefineAspects(KillCursorsOperation, [Aspect.MUST_SELECT_SAME_SERVER]);\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAIA,MAAA;AACA,MAAA;AAYA,MAAa,6BAA6B,YAAA,iBAAiB;IAGzD,YAAY,QAAc,EAAE,EAAoB,EAAE,MAAc,EAAE,OAAyB,CAAA;QACzF,KAAK,CAAC;QACN,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,MAAM,GAAG;IAChB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,IAAI,WAAW,IAAI,CAAC,MAAM,EAAE;YAC1B,MAAM,IAAI,QAAA,iBAAiB,CAAC;QAC9B;QAEA,MAAM,cAAc,IAAI,CAAC,EAAE,CAAC,UAAU;QACtC,IAAI,eAAe,MAAM;YACvB,gEAAgE;YAChE,wFAAwF;YACxF,MAAM,IAAI,QAAA,iBAAiB,CAAC;QAC9B;QAEA,MAAM,qBAAyC;YAC7C;YACA,SAAS;gBAAC,IAAI,CAAC,QAAQ;aAAC;;QAE1B,IAAI;YACF,MAAM,OAAO,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,oBAAoB;gBAChD;gBACA;;QAEJ,EAAE,OAAO,OAAO;YACd,iFAAiF;YACjF,CAAA,GAAA,QAAA,WAAW,EAAC;QACd;IACF;;AA3CF,QAAA,oBAAA,GAAA;AA8CA,CAAA,GAAA,YAAA,aAAa,EAAC,sBAAsB;IAAC,YAAA,MAAM,CAAC,uBAAuB;CAAC"}},
    {"offset": {"line": 405, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 409, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/delete.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport { MongoCompatibilityError, MongoServerError } from '../error';\nimport { type TODO_NODE_3286 } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { type MongoDBNamespace } from '../utils';\nimport { type WriteConcernOptions } from '../write_concern';\nimport { type CollationOptions, CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects, type Hint } from './operation';\n\n/** @public */\nexport interface DeleteOptions extends CommandOperationOptions, WriteConcernOptions {\n  /** If true, when an insert fails, don't execute the remaining writes. If false, continue with remaining inserts when one fails. */\n  ordered?: boolean;\n  /** Specifies the collation to use for the operation */\n  collation?: CollationOptions;\n  /** Specify that the update query should only consider plans using the hinted index */\n  hint?: string | Document;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n}\n\n/** @public */\nexport interface DeleteResult {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined. */\n  acknowledged: boolean;\n  /** The number of documents that were deleted */\n  deletedCount: number;\n}\n\n/** @public */\nexport interface DeleteStatement {\n  /** The query that matches documents to delete. */\n  q: Document;\n  /** The number of matching documents to delete. */\n  limit: number;\n  /** Specifies the collation to use for the operation. */\n  collation?: CollationOptions;\n  /** A document or string that specifies the index to use to support the query predicate. */\n  hint?: Hint;\n}\n\n/** @internal */\nexport class DeleteOperation extends CommandOperation<DeleteResult> {\n  override options: DeleteOptions;\n  statements: DeleteStatement[];\n\n  constructor(ns: MongoDBNamespace, statements: DeleteStatement[], options: DeleteOptions) {\n    super(undefined, options);\n    this.options = options;\n    this.ns = ns;\n    this.statements = statements;\n  }\n\n  override get commandName() {\n    return 'delete' as const;\n  }\n\n  override get canRetryWrite(): boolean {\n    if (super.canRetryWrite === false) {\n      return false;\n    }\n\n    return this.statements.every(op => (op.limit != null ? op.limit > 0 : true));\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<DeleteResult> {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command: Document = {\n      delete: this.ns.collection,\n      deletes: this.statements,\n      ordered\n    };\n\n    if (options.let) {\n      command.let = options.let;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;\n    if (unacknowledgedWrite) {\n      if (this.statements.find((o: Document) => o.hint)) {\n        // TODO(NODE-3541): fix error for hint with unacknowledged writes\n        throw new MongoCompatibilityError(`hint is not supported with unacknowledged writes`);\n      }\n    }\n\n    const res: TODO_NODE_3286 = await super.executeCommand(\n      server,\n      session,\n      command,\n      timeoutContext\n    );\n    return res;\n  }\n}\n\nexport class DeleteOneOperation extends DeleteOperation {\n  constructor(collection: Collection, filter: Document, options: DeleteOptions) {\n    super(collection.s.namespace, [makeDeleteStatement(filter, { ...options, limit: 1 })], options);\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<DeleteResult> {\n    const res: TODO_NODE_3286 = await super.execute(server, session, timeoutContext);\n    if (this.explain) return res;\n    if (res.code) throw new MongoServerError(res);\n    if (res.writeErrors) throw new MongoServerError(res.writeErrors[0]);\n\n    return {\n      acknowledged: this.writeConcern?.w !== 0,\n      deletedCount: res.n\n    };\n  }\n}\nexport class DeleteManyOperation extends DeleteOperation {\n  constructor(collection: Collection, filter: Document, options: DeleteOptions) {\n    super(collection.s.namespace, [makeDeleteStatement(filter, options)], options);\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<DeleteResult> {\n    const res: TODO_NODE_3286 = await super.execute(server, session, timeoutContext);\n    if (this.explain) return res;\n    if (res.code) throw new MongoServerError(res);\n    if (res.writeErrors) throw new MongoServerError(res.writeErrors[0]);\n\n    return {\n      acknowledged: this.writeConcern?.w !== 0,\n      deletedCount: res.n\n    };\n  }\n}\n\nexport function makeDeleteStatement(\n  filter: Document,\n  options: DeleteOptions & { limit?: number }\n): DeleteStatement {\n  const op: DeleteStatement = {\n    q: filter,\n    limit: typeof options.limit === 'number' ? options.limit : 0\n  };\n\n  if (options.collation) {\n    op.collation = options.collation;\n  }\n\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n\n  return op;\n}\n\ndefineAspects(DeleteOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(DeleteOneOperation, [\n  Aspect.RETRYABLE,\n  Aspect.WRITE_OPERATION,\n  Aspect.EXPLAINABLE,\n  Aspect.SKIP_COLLATION\n]);\ndefineAspects(DeleteManyOperation, [\n  Aspect.WRITE_OPERATION,\n  Aspect.EXPLAINABLE,\n  Aspect.SKIP_COLLATION\n]);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 533, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/bulk_write.ts"],"sourcesContent":["import type {\n  AnyBulkWriteOperation,\n  BulkOperationBase,\n  BulkWriteOptions,\n  BulkWriteResult\n} from '../bulk/common';\nimport type { Collection } from '../collection';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\n\n/** @internal */\nexport class BulkWriteOperation extends AbstractOperation<BulkWriteResult> {\n  override options: BulkWriteOptions;\n  collection: Collection;\n  operations: ReadonlyArray<AnyBulkWriteOperation>;\n\n  constructor(\n    collection: Collection,\n    operations: ReadonlyArray<AnyBulkWriteOperation>,\n    options: BulkWriteOptions\n  ) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  override get commandName() {\n    return 'bulkWrite' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<BulkWriteResult> {\n    const coll = this.collection;\n    const operations = this.operations;\n    const options = {\n      ...this.options,\n      ...this.bsonOptions,\n      readPreference: this.readPreference,\n      timeoutContext\n    };\n\n    // Create the bulk operation\n    const bulk: BulkOperationBase =\n      options.ordered === false\n        ? coll.initializeUnorderedBulkOp(options)\n        : coll.initializeOrderedBulkOp(options);\n\n    // for each op go through and add to the bulk\n    for (let i = 0; i < operations.length; i++) {\n      bulk.raw(operations[i]);\n    }\n\n    // Execute the bulk\n    return await bulk.execute({ ...options, session });\n  }\n}\n\ndefineAspects(BulkWriteOperation, [Aspect.WRITE_OPERATION]);\n"],"names":[],"mappings":";;;;;AAUA,MAAA;AAEA,cAAA,GACA,MAAa,2BAA2B,YAAA,iBAAkC;IAKxE,YACE,UAAsB,EACtB,UAAgD,EAChD,OAAyB,CAAA;QAEzB,KAAK,CAAC;QACN,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,UAAU,GAAG;IACpB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,OAAO,IAAI,CAAC,UAAU;QAC5B,MAAM,aAAa,IAAI,CAAC,UAAU;QAClC,MAAM,UAAU;YACd,GAAG,IAAI,CAAC,OAAO;YACf,GAAG,IAAI,CAAC,WAAW;YACnB,gBAAgB,IAAI,CAAC,cAAc;YACnC;;QAGF,4BAA4B;QAC5B,MAAM,OACJ,QAAQ,OAAO,KAAK,QAChB,KAAK,yBAAyB,CAAC,WAC/B,KAAK,uBAAuB,CAAC;QAEnC,6CAA6C;QAC7C,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IAAK;YAC1C,KAAK,GAAG,CAAC,UAAU,CAAC,EAAE;QACxB;QAEA,mBAAmB;QACnB,OAAO,MAAM,KAAK,OAAO,CAAC;YAAE,GAAG,OAAO;YAAE;QAAO;IACjD;;AA/CF,QAAA,kBAAA,GAAA;AAkDA,CAAA,GAAA,YAAA,aAAa,EAAC,oBAAoB;IAAC,YAAA,MAAM,CAAC,eAAe;CAAC"}},
    {"offset": {"line": 575, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 579, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/insert.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { BulkWriteOptions } from '../bulk/common';\nimport type { Collection } from '../collection';\nimport { MongoInvalidArgumentError, MongoServerError } from '../error';\nimport type { InferIdType } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { maybeAddIdToDocuments, type MongoDBNamespace } from '../utils';\nimport { WriteConcern } from '../write_concern';\nimport { BulkWriteOperation } from './bulk_write';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\n\n/** @internal */\nexport class InsertOperation extends CommandOperation<Document> {\n  override options: BulkWriteOptions;\n  documents: Document[];\n\n  constructor(ns: MongoDBNamespace, documents: Document[], options: BulkWriteOptions) {\n    super(undefined, options);\n    this.options = { ...options, checkKeys: options.checkKeys ?? false };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  override get commandName() {\n    return 'insert' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Document> {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command: Document = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    return await super.executeCommand(server, session, command, timeoutContext);\n  }\n}\n\n/** @public */\nexport interface InsertOneOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** Force server to assign _id values instead of driver. */\n  forceServerObjectId?: boolean;\n}\n\n/** @public */\nexport interface InsertOneResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The identifier that was inserted. If the server generated the identifier, this value will be null as the driver does not have access to that data */\n  insertedId: InferIdType<TSchema>;\n}\n\nexport class InsertOneOperation extends InsertOperation {\n  constructor(collection: Collection, doc: Document, options: InsertOneOptions) {\n    super(collection.s.namespace, maybeAddIdToDocuments(collection, [doc], options), options);\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<InsertOneResult> {\n    const res = await super.execute(server, session, timeoutContext);\n    if (res.code) throw new MongoServerError(res);\n    if (res.writeErrors) {\n      // This should be a WriteError but we can't change it now because of error hierarchy\n      throw new MongoServerError(res.writeErrors[0]);\n    }\n\n    return {\n      acknowledged: this.writeConcern?.w !== 0,\n      insertedId: this.documents[0]._id\n    };\n  }\n}\n\n/** @public */\nexport interface InsertManyResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The number of inserted documents for this operations */\n  insertedCount: number;\n  /** Map of the index of the inserted document to the id of the inserted document */\n  insertedIds: { [key: number]: InferIdType<TSchema> };\n}\n\n/** @internal */\nexport class InsertManyOperation extends AbstractOperation<InsertManyResult> {\n  override options: BulkWriteOptions;\n  collection: Collection;\n  docs: ReadonlyArray<Document>;\n\n  constructor(collection: Collection, docs: ReadonlyArray<Document>, options: BulkWriteOptions) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  override get commandName() {\n    return 'insert' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<InsertManyResult> {\n    const coll = this.collection;\n    const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };\n    const writeConcern = WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new BulkWriteOperation(\n      coll,\n      this.docs.map(document => ({\n        insertOne: { document }\n      })),\n      options\n    );\n\n    try {\n      const res = await bulkWriteOperation.execute(server, session, timeoutContext);\n      return {\n        acknowledged: writeConcern?.w !== 0,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      };\n    } catch (err) {\n      if (err && err.message === 'Operation must be an object with an operation key') {\n        throw new MongoInvalidArgumentError(\n          'Collection.insertMany() cannot be called with an array that has null/undefined values'\n        );\n      }\n      throw err;\n    }\n  }\n}\n\ndefineAspects(InsertOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertOneOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertManyOperation, [Aspect.WRITE_OPERATION]);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 696, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 700, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/update.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport { MongoCompatibilityError, MongoInvalidArgumentError, MongoServerError } from '../error';\nimport type { InferIdType, TODO_NODE_3286 } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { formatSort, type Sort, type SortForCmd } from '../sort';\nimport { type TimeoutContext } from '../timeout';\nimport { hasAtomicOperators, type MongoDBNamespace } from '../utils';\nimport { type CollationOptions, CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects, type Hint } from './operation';\n\n/** @public */\nexport interface UpdateOptions extends CommandOperationOptions {\n  /** A set of filters specifying to which array elements an update should apply */\n  arrayFilters?: Document[];\n  /** If true, allows the write to opt-out of document level validation */\n  bypassDocumentValidation?: boolean;\n  /** Specifies a collation */\n  collation?: CollationOptions;\n  /** Specify that the update query should only consider plans using the hinted index */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n}\n\n/**\n * @public\n * `TSchema` is the schema of the collection\n */\nexport interface UpdateResult<TSchema extends Document = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The number of documents that matched the filter */\n  matchedCount: number;\n  /** The number of documents that were modified */\n  modifiedCount: number;\n  /** The number of documents that were upserted */\n  upsertedCount: number;\n  /** The identifier of the inserted document if an upsert took place */\n  upsertedId: InferIdType<TSchema> | null;\n}\n\n/** @public */\nexport interface UpdateStatement {\n  /** The query that matches documents to update. */\n  q: Document;\n  /** The modifications to apply. */\n  u: Document | Document[];\n  /**  If true, perform an insert if no documents match the query. */\n  upsert?: boolean;\n  /** If true, updates all documents that meet the query criteria. */\n  multi?: boolean;\n  /** Specifies the collation to use for the operation. */\n  collation?: CollationOptions;\n  /** An array of filter documents that determines which array elements to modify for an update operation on an array field. */\n  arrayFilters?: Document[];\n  /** A document or string that specifies the index to use to support the query predicate. */\n  hint?: Hint;\n  /** Specifies the sort order for the documents matched by the filter. */\n  sort?: SortForCmd;\n}\n\n/**\n * @internal\n * UpdateOperation is used in bulk write, while UpdateOneOperation and UpdateManyOperation are only used in the collections API\n */\nexport class UpdateOperation extends CommandOperation<Document> {\n  override options: UpdateOptions & { ordered?: boolean };\n  statements: UpdateStatement[];\n\n  constructor(\n    ns: MongoDBNamespace,\n    statements: UpdateStatement[],\n    options: UpdateOptions & { ordered?: boolean }\n  ) {\n    super(undefined, options);\n    this.options = options;\n    this.ns = ns;\n\n    this.statements = statements;\n  }\n\n  override get commandName() {\n    return 'update' as const;\n  }\n\n  override get canRetryWrite(): boolean {\n    if (super.canRetryWrite === false) {\n      return false;\n    }\n\n    return this.statements.every(op => op.multi == null || op.multi === false);\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Document> {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command: Document = {\n      update: this.ns.collection,\n      updates: this.statements,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (options.let) {\n      command.let = options.let;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;\n    if (unacknowledgedWrite) {\n      if (this.statements.find((o: Document) => o.hint)) {\n        // TODO(NODE-3541): fix error for hint with unacknowledged writes\n        throw new MongoCompatibilityError(`hint is not supported with unacknowledged writes`);\n      }\n    }\n\n    const res = await super.executeCommand(server, session, command, timeoutContext);\n    return res;\n  }\n}\n\n/** @internal */\nexport class UpdateOneOperation extends UpdateOperation {\n  constructor(collection: Collection, filter: Document, update: Document, options: UpdateOptions) {\n    super(\n      collection.s.namespace,\n      [makeUpdateStatement(filter, update, { ...options, multi: false })],\n      options\n    );\n\n    if (!hasAtomicOperators(update, options)) {\n      throw new MongoInvalidArgumentError('Update document requires atomic operators');\n    }\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<UpdateResult> {\n    const res: TODO_NODE_3286 = await super.execute(server, session, timeoutContext);\n    if (this.explain != null) return res;\n    if (res.code) throw new MongoServerError(res);\n    if (res.writeErrors) throw new MongoServerError(res.writeErrors[0]);\n\n    return {\n      acknowledged: this.writeConcern?.w !== 0,\n      modifiedCount: res.nModified ?? res.n,\n      upsertedId:\n        Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,\n      upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,\n      matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n\n    };\n  }\n}\n\n/** @internal */\nexport class UpdateManyOperation extends UpdateOperation {\n  constructor(collection: Collection, filter: Document, update: Document, options: UpdateOptions) {\n    super(\n      collection.s.namespace,\n      [makeUpdateStatement(filter, update, { ...options, multi: true })],\n      options\n    );\n\n    if (!hasAtomicOperators(update, options)) {\n      throw new MongoInvalidArgumentError('Update document requires atomic operators');\n    }\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<UpdateResult> {\n    const res: TODO_NODE_3286 = await super.execute(server, session, timeoutContext);\n    if (this.explain != null) return res;\n    if (res.code) throw new MongoServerError(res);\n    if (res.writeErrors) throw new MongoServerError(res.writeErrors[0]);\n\n    return {\n      acknowledged: this.writeConcern?.w !== 0,\n      modifiedCount: res.nModified ?? res.n,\n      upsertedId:\n        Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,\n      upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,\n      matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n\n    };\n  }\n}\n\n/** @public */\nexport interface ReplaceOptions extends CommandOperationOptions {\n  /** If true, allows the write to opt-out of document level validation */\n  bypassDocumentValidation?: boolean;\n  /** Specifies a collation */\n  collation?: CollationOptions;\n  /** Specify that the update query should only consider plans using the hinted index */\n  hint?: string | Document;\n  /** When true, creates a new document if no document matches the query */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  /** Specifies the sort order for the documents matched by the filter. */\n  sort?: Sort;\n}\n\n/** @internal */\nexport class ReplaceOneOperation extends UpdateOperation {\n  constructor(\n    collection: Collection,\n    filter: Document,\n    replacement: Document,\n    options: ReplaceOptions\n  ) {\n    super(\n      collection.s.namespace,\n      [makeUpdateStatement(filter, replacement, { ...options, multi: false })],\n      options\n    );\n\n    if (hasAtomicOperators(replacement)) {\n      throw new MongoInvalidArgumentError('Replacement document must not contain atomic operators');\n    }\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<UpdateResult> {\n    const res: TODO_NODE_3286 = await super.execute(server, session, timeoutContext);\n    if (this.explain != null) return res;\n    if (res.code) throw new MongoServerError(res);\n    if (res.writeErrors) throw new MongoServerError(res.writeErrors[0]);\n\n    return {\n      acknowledged: this.writeConcern?.w !== 0,\n      modifiedCount: res.nModified ?? res.n,\n      upsertedId:\n        Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,\n      upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,\n      matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n\n    };\n  }\n}\n\nexport function makeUpdateStatement(\n  filter: Document,\n  update: Document | Document[],\n  options: UpdateOptions & { multi?: boolean } & { sort?: Sort }\n): UpdateStatement {\n  if (filter == null || typeof filter !== 'object') {\n    throw new MongoInvalidArgumentError('Selector must be a valid JavaScript object');\n  }\n\n  if (update == null || typeof update !== 'object') {\n    throw new MongoInvalidArgumentError('Document must be a valid JavaScript object');\n  }\n\n  const op: UpdateStatement = { q: filter, u: update };\n  if (typeof options.upsert === 'boolean') {\n    op.upsert = options.upsert;\n  }\n\n  if (options.multi) {\n    op.multi = options.multi;\n  }\n\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n\n  if (options.arrayFilters) {\n    op.arrayFilters = options.arrayFilters;\n  }\n\n  if (options.collation) {\n    op.collation = options.collation;\n  }\n\n  if (!options.multi && options.sort != null) {\n    op.sort = formatSort(options.sort);\n  }\n\n  return op;\n}\n\ndefineAspects(UpdateOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION, Aspect.SKIP_COLLATION]);\ndefineAspects(UpdateOneOperation, [\n  Aspect.RETRYABLE,\n  Aspect.WRITE_OPERATION,\n  Aspect.EXPLAINABLE,\n  Aspect.SKIP_COLLATION\n]);\ndefineAspects(UpdateManyOperation, [\n  Aspect.WRITE_OPERATION,\n  Aspect.EXPLAINABLE,\n  Aspect.SKIP_COLLATION\n]);\ndefineAspects(ReplaceOneOperation, [\n  Aspect.RETRYABLE,\n  Aspect.WRITE_OPERATION,\n  Aspect.SKIP_COLLATION\n]);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 894, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 898, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/aggregate.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { CursorResponse, ExplainedCursorResponse } from '../cmap/wire_protocol/responses';\nimport { type CursorTimeoutMode } from '../cursor/abstract_cursor';\nimport { MongoInvalidArgumentError } from '../error';\nimport { type ExplainOptions } from '../explain';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { maxWireVersion, type MongoDBNamespace } from '../utils';\nimport { WriteConcern } from '../write_concern';\nimport { type CollationOptions, CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects, type Hint } from './operation';\n\n/** @internal */\nexport const DB_AGGREGATE_COLLECTION = 1 as const;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;\n\n/** @public */\nexport interface AggregateOptions extends Omit<CommandOperationOptions, 'explain'> {\n  /** allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \\>). */\n  allowDiskUse?: boolean;\n  /** The number of documents to return per batch. See [aggregation documentation](https://www.mongodb.com/docs/manual/reference/command/aggregate). */\n  batchSize?: number;\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** Return the query as cursor, on 2.6 \\> it returns as a real cursor on pre 2.6 it returns as an emulated cursor. */\n  cursor?: Document;\n  /**\n   * Specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.\n   */\n  maxTimeMS?: number;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. */\n  maxAwaitTimeMS?: number;\n  /** Specify collation. */\n  collation?: CollationOptions;\n  /** Add an index selection hint to an aggregation command */\n  hint?: Hint;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n\n  out?: string;\n\n  /**\n   * Specifies the verbosity mode for the explain output.\n   * @deprecated This API is deprecated in favor of `collection.aggregate().explain()`\n   * or `db.aggregate().explain()`.\n   */\n  explain?: ExplainOptions['explain'];\n  /** @internal */\n  timeoutMode?: CursorTimeoutMode;\n}\n\n/** @internal */\nexport class AggregateOperation extends CommandOperation<CursorResponse> {\n  override options: AggregateOptions;\n  target: string | typeof DB_AGGREGATE_COLLECTION;\n  pipeline: Document[];\n  hasWriteStage: boolean;\n\n  constructor(ns: MongoDBNamespace, pipeline: Document[], options?: AggregateOptions) {\n    super(undefined, { ...options, dbName: ns.db });\n\n    this.options = { ...options };\n\n    // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n    this.target = ns.collection || DB_AGGREGATE_COLLECTION;\n\n    this.pipeline = pipeline;\n\n    // determine if we have a write stage, override read preference if so\n    this.hasWriteStage = false;\n    if (typeof options?.out === 'string') {\n      this.pipeline = this.pipeline.concat({ $out: options.out });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n\n    if (this.hasWriteStage) {\n      this.trySecondaryWrite = true;\n    } else {\n      delete this.options.writeConcern;\n    }\n\n    if (this.explain && this.writeConcern) {\n      throw new MongoInvalidArgumentError(\n        'Option \"explain\" cannot be used on an aggregate call with writeConcern'\n      );\n    }\n\n    if (options?.cursor != null && typeof options.cursor !== 'object') {\n      throw new MongoInvalidArgumentError('Cursor options must be an object');\n    }\n  }\n\n  override get commandName() {\n    return 'aggregate' as const;\n  }\n\n  override get canRetryRead(): boolean {\n    return !this.hasWriteStage;\n  }\n\n  addToPipeline(stage: Document): void {\n    this.pipeline.push(stage);\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<CursorResponse> {\n    const options: AggregateOptions = this.options;\n    const serverWireVersion = maxWireVersion(server);\n    const command: Document = { aggregate: this.target, pipeline: this.pipeline };\n\n    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n      this.readConcern = undefined;\n    }\n\n    if (this.hasWriteStage && this.writeConcern) {\n      WriteConcern.apply(command, this.writeConcern);\n    }\n\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n\n    if (options.let) {\n      command.let = options.let;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    command.cursor = options.cursor || {};\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n\n    return await super.executeCommand(\n      server,\n      session,\n      command,\n      timeoutContext,\n      this.explain ? ExplainedCursorResponse : CursorResponse\n    );\n  }\n}\n\ndefineAspects(AggregateOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.EXPLAINABLE,\n  Aspect.CURSOR_CREATING\n]);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1001, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1005, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/count.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport type { MongoDBNamespace } from '../utils';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface CountOptions extends CommandOperationOptions {\n  /** The number of documents to skip. */\n  skip?: number;\n  /** The maximum amounts to count before aborting. */\n  limit?: number;\n  /**\n   * Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS?: number;\n  /** An index name hint for the query. */\n  hint?: string | Document;\n}\n\n/** @internal */\nexport class CountOperation extends CommandOperation<number> {\n  override options: CountOptions;\n  collectionName?: string;\n  query: Document;\n\n  constructor(namespace: MongoDBNamespace, filter: Document, options: CountOptions) {\n    super({ s: { namespace: namespace } } as unknown as Collection, options);\n\n    this.options = options;\n    this.collectionName = namespace.collection;\n    this.query = filter;\n  }\n\n  override get commandName() {\n    return 'count' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<number> {\n    const options = this.options;\n    const cmd: Document = {\n      count: this.collectionName,\n      query: this.query\n    };\n\n    if (typeof options.limit === 'number') {\n      cmd.limit = options.limit;\n    }\n\n    if (typeof options.skip === 'number') {\n      cmd.skip = options.skip;\n    }\n\n    if (options.hint != null) {\n      cmd.hint = options.hint;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      cmd.maxTimeMS = options.maxTimeMS;\n    }\n\n    const result = await super.executeCommand(server, session, cmd, timeoutContext);\n    return result ? result.n : 0;\n  }\n}\n\ndefineAspects(CountOperation, [Aspect.READ_OPERATION, Aspect.RETRYABLE]);\n"],"names":[],"mappings":";;;;;AAMA,MAAA;AACA,MAAA;AAgBA,cAAA,GACA,MAAa,uBAAuB,UAAA,gBAAwB;IAK1D,YAAY,SAA2B,EAAE,MAAgB,EAAE,OAAqB,CAAA;QAC9E,KAAK,CAAC;YAAE,GAAG;gBAAE,WAAW;YAAS;QAAE,GAA6B;QAEhE,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,cAAc,GAAG,UAAU,UAAU;QAC1C,IAAI,CAAC,KAAK,GAAG;IACf;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,UAAU,IAAI,CAAC,OAAO;QAC5B,MAAM,MAAgB;YACpB,OAAO,IAAI,CAAC,cAAc;YAC1B,OAAO,IAAI,CAAC,KAAK;;QAGnB,IAAI,OAAO,QAAQ,KAAK,KAAK,UAAU;YACrC,IAAI,KAAK,GAAG,QAAQ,KAAK;QAC3B;QAEA,IAAI,OAAO,QAAQ,IAAI,KAAK,UAAU;YACpC,IAAI,IAAI,GAAG,QAAQ,IAAI;QACzB;QAEA,IAAI,QAAQ,IAAI,IAAI,MAAM;YACxB,IAAI,IAAI,GAAG,QAAQ,IAAI;QACzB;QAEA,IAAI,OAAO,QAAQ,SAAS,KAAK,UAAU;YACzC,IAAI,SAAS,GAAG,QAAQ,SAAS;QACnC;QAEA,MAAM,SAAS,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS,KAAK;QAChE,OAAO,SAAS,OAAO,CAAC,GAAG;IAC7B;;AA9CF,QAAA,cAAA,GAAA;AAiDA,CAAA,GAAA,YAAA,aAAa,EAAC,gBAAgB;IAAC,YAAA,MAAM,CAAC,cAAc;IAAE,YAAA,MAAM,CAAC,SAAS;CAAC"}},
    {"offset": {"line": 1053, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1057, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/find.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { CursorResponse, ExplainedCursorResponse } from '../cmap/wire_protocol/responses';\nimport { type AbstractCursorOptions, type CursorTimeoutMode } from '../cursor/abstract_cursor';\nimport { MongoInvalidArgumentError } from '../error';\nimport {\n  decorateWithExplain,\n  type ExplainOptions,\n  validateExplainTimeoutOptions\n} from '../explain';\nimport { ReadConcern } from '../read_concern';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { formatSort, type Sort } from '../sort';\nimport { type TimeoutContext } from '../timeout';\nimport { type MongoDBNamespace, normalizeHintField } from '../utils';\nimport { type CollationOptions, CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects, type Hint } from './operation';\n\n/**\n * @public\n * @typeParam TSchema - Unused schema definition, deprecated usage, only specify `FindOptions` with no generic\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface FindOptions<TSchema extends Document = Document>\n  extends Omit<CommandOperationOptions, 'writeConcern' | 'explain'>,\n    AbstractCursorOptions {\n  /** Sets the limit of documents returned in the query. */\n  limit?: number;\n  /** Set to sort the documents coming back from the query. Array of indexes, `[['a', 1]]` etc. */\n  sort?: Sort;\n  /** The fields to return in the query. Object of fields to either include or exclude (one of, not both), `{'a':1, 'b': 1}` **or** `{'a': 0, 'b': 0}` */\n  projection?: Document;\n  /** Set to skip N documents ahead in your query (useful for pagination). */\n  skip?: number;\n  /** Tell the query to use specific indexes in the query. Object of indexes to use, `{'_id':1}` */\n  hint?: Hint;\n  /** Specify if the cursor can timeout. */\n  timeout?: boolean;\n  /** Specify if the cursor is tailable. */\n  tailable?: boolean;\n  /** Specify if the cursor is a tailable-await cursor. Requires `tailable` to be true */\n  awaitData?: boolean;\n  /** Set the batchSize for the getMoreCommand when iterating over the query results. */\n  batchSize?: number;\n  /** If true, returns only the index keys in the resulting documents. */\n  returnKey?: boolean;\n  /** The inclusive lower bound for a specific index */\n  min?: Document;\n  /** The exclusive upper bound for a specific index */\n  max?: Document;\n  /** Number of milliseconds to wait before aborting the query. */\n  maxTimeMS?: number;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true */\n  maxAwaitTimeMS?: number;\n  /** The server normally times out idle cursors after an inactivity period (10 minutes) to prevent excess memory use. Set this option to prevent that. */\n  noCursorTimeout?: boolean;\n  /** Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields). */\n  collation?: CollationOptions;\n  /** Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher) */\n  allowDiskUse?: boolean;\n  /** Determines whether to close the cursor after the first batch. Defaults to false. */\n  singleBatch?: boolean;\n  /** For queries against a sharded collection, allows the command (or subsequent getMore commands) to return partial results, rather than an error, if one or more queried shards are unavailable. */\n  allowPartialResults?: boolean;\n  /** Determines whether to return the record identifier for each document. If true, adds a field $recordId to the returned documents. */\n  showRecordId?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  /**\n   * Option to enable an optimized code path for queries looking for a particular range of `ts` values in the oplog. Requires `tailable` to be true.\n   * @deprecated Starting from MongoDB 4.4 this flag is not needed and will be ignored.\n   */\n  oplogReplay?: boolean;\n\n  /**\n   * Specifies the verbosity mode for the explain output.\n   * @deprecated This API is deprecated in favor of `collection.find().explain()`.\n   */\n  explain?: ExplainOptions['explain'];\n  /** @internal*/\n  timeoutMode?: CursorTimeoutMode;\n}\n\n/** @internal */\nexport class FindOperation extends CommandOperation<CursorResponse> {\n  /**\n   * @remarks WriteConcern can still be present on the options because\n   * we inherit options from the client/db/collection.  The\n   * key must be present on the options in order to delete it.\n   * This allows typescript to delete the key but will\n   * not allow a writeConcern to be assigned as a property on options.\n   */\n  override options: FindOptions & { writeConcern?: never };\n  filter: Document;\n\n  constructor(ns: MongoDBNamespace, filter: Document = {}, options: FindOptions = {}) {\n    super(undefined, options);\n\n    this.options = { ...options };\n    delete this.options.writeConcern;\n    this.ns = ns;\n\n    if (typeof filter !== 'object' || Array.isArray(filter)) {\n      throw new MongoInvalidArgumentError('Query filter must be a plain object or ObjectId');\n    }\n\n    // special case passing in an ObjectId as a filter\n    this.filter = filter != null && filter._bsontype === 'ObjectId' ? { _id: filter } : filter;\n  }\n\n  override get commandName() {\n    return 'find' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<CursorResponse> {\n    this.server = server;\n\n    const options = this.options;\n\n    let findCommand = makeFindCommand(this.ns, this.filter, options);\n    if (this.explain) {\n      validateExplainTimeoutOptions(this.options, this.explain);\n      findCommand = decorateWithExplain(findCommand, this.explain);\n    }\n\n    return await server.command(\n      this.ns,\n      findCommand,\n      {\n        ...this.options,\n        ...this.bsonOptions,\n        documentsReturnedIn: 'firstBatch',\n        session,\n        timeoutContext\n      },\n      this.explain ? ExplainedCursorResponse : CursorResponse\n    );\n  }\n}\n\nfunction makeFindCommand(ns: MongoDBNamespace, filter: Document, options: FindOptions): Document {\n  const findCommand: Document = {\n    find: ns.collection,\n    filter\n  };\n\n  if (options.sort) {\n    findCommand.sort = formatSort(options.sort);\n  }\n\n  if (options.projection) {\n    let projection = options.projection;\n    if (projection && Array.isArray(projection)) {\n      projection = projection.length\n        ? projection.reduce((result, field) => {\n            result[field] = 1;\n            return result;\n          }, {})\n        : { _id: 1 };\n    }\n\n    findCommand.projection = projection;\n  }\n\n  if (options.hint) {\n    findCommand.hint = normalizeHintField(options.hint);\n  }\n\n  if (typeof options.skip === 'number') {\n    findCommand.skip = options.skip;\n  }\n\n  if (typeof options.limit === 'number') {\n    if (options.limit < 0) {\n      findCommand.limit = -options.limit;\n      findCommand.singleBatch = true;\n    } else {\n      findCommand.limit = options.limit;\n    }\n  }\n\n  if (typeof options.batchSize === 'number') {\n    if (options.batchSize < 0) {\n      if (\n        options.limit &&\n        options.limit !== 0 &&\n        Math.abs(options.batchSize) < Math.abs(options.limit)\n      ) {\n        findCommand.limit = -options.batchSize;\n      }\n\n      findCommand.singleBatch = true;\n    } else {\n      findCommand.batchSize = options.batchSize;\n    }\n  }\n\n  if (typeof options.singleBatch === 'boolean') {\n    findCommand.singleBatch = options.singleBatch;\n  }\n\n  // we check for undefined specifically here to allow falsy values\n  // eslint-disable-next-line no-restricted-syntax\n  if (options.comment !== undefined) {\n    findCommand.comment = options.comment;\n  }\n\n  if (typeof options.maxTimeMS === 'number') {\n    findCommand.maxTimeMS = options.maxTimeMS;\n  }\n\n  const readConcern = ReadConcern.fromOptions(options);\n  if (readConcern) {\n    findCommand.readConcern = readConcern.toJSON();\n  }\n\n  if (options.max) {\n    findCommand.max = options.max;\n  }\n\n  if (options.min) {\n    findCommand.min = options.min;\n  }\n\n  if (typeof options.returnKey === 'boolean') {\n    findCommand.returnKey = options.returnKey;\n  }\n\n  if (typeof options.showRecordId === 'boolean') {\n    findCommand.showRecordId = options.showRecordId;\n  }\n\n  if (typeof options.tailable === 'boolean') {\n    findCommand.tailable = options.tailable;\n  }\n\n  if (typeof options.oplogReplay === 'boolean') {\n    findCommand.oplogReplay = options.oplogReplay;\n  }\n\n  if (typeof options.timeout === 'boolean') {\n    findCommand.noCursorTimeout = !options.timeout;\n  } else if (typeof options.noCursorTimeout === 'boolean') {\n    findCommand.noCursorTimeout = options.noCursorTimeout;\n  }\n\n  if (typeof options.awaitData === 'boolean') {\n    findCommand.awaitData = options.awaitData;\n  }\n\n  if (typeof options.allowPartialResults === 'boolean') {\n    findCommand.allowPartialResults = options.allowPartialResults;\n  }\n\n  if (options.collation) {\n    findCommand.collation = options.collation;\n  }\n\n  if (typeof options.allowDiskUse === 'boolean') {\n    findCommand.allowDiskUse = options.allowDiskUse;\n  }\n\n  if (options.let) {\n    findCommand.let = options.let;\n  }\n\n  return findCommand;\n}\n\ndefineAspects(FindOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.EXPLAINABLE,\n  Aspect.CURSOR_CREATING\n]);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1212, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1216, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/indexes.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { CursorResponse } from '../cmap/wire_protocol/responses';\nimport type { Collection } from '../collection';\nimport { type AbstractCursorOptions } from '../cursor/abstract_cursor';\nimport { MongoCompatibilityError } from '../error';\nimport { type OneOrMore } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { isObject, maxWireVersion, type MongoDBNamespace } from '../utils';\nimport {\n  type CollationOptions,\n  CommandOperation,\n  type CommandOperationOptions,\n  type OperationParent\n} from './command';\nimport { Aspect, defineAspects } from './operation';\n\nconst VALID_INDEX_OPTIONS = new Set([\n  'background',\n  'unique',\n  'name',\n  'partialFilterExpression',\n  'sparse',\n  'hidden',\n  'expireAfterSeconds',\n  'storageEngine',\n  'collation',\n  'version',\n\n  // text indexes\n  'weights',\n  'default_language',\n  'language_override',\n  'textIndexVersion',\n\n  // 2d-sphere indexes\n  '2dsphereIndexVersion',\n\n  // 2d indexes\n  'bits',\n  'min',\n  'max',\n\n  // geoHaystack Indexes\n  'bucketSize',\n\n  // wildcard indexes\n  'wildcardProjection'\n]);\n\n/** @public */\nexport type IndexDirection =\n  | -1\n  | 1\n  | '2d'\n  | '2dsphere'\n  | 'text'\n  | 'geoHaystack'\n  | 'hashed'\n  | number;\n\nfunction isIndexDirection(x: unknown): x is IndexDirection {\n  return (\n    typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack'\n  );\n}\n/** @public */\nexport type IndexSpecification = OneOrMore<\n  | string\n  | [string, IndexDirection]\n  | { [key: string]: IndexDirection }\n  | Map<string, IndexDirection>\n>;\n\n/** @public */\nexport interface IndexInformationOptions extends ListIndexesOptions {\n  /**\n   * When `true`, an array of index descriptions is returned.\n   * When `false`, the driver returns an object that with keys corresponding to index names with values\n   * corresponding to the entries of the indexes' key.\n   *\n   * For example, the given the following indexes:\n   * ```\n   * [ { name: 'a_1', key: { a: 1 } }, { name: 'b_1_c_1' , key: { b: 1, c: 1 } }]\n   * ```\n   *\n   * When `full` is `true`, the above array is returned.  When `full` is `false`, the following is returned:\n   * ```\n   * {\n   *   'a_1': [['a', 1]],\n   *   'b_1_c_1': [['b', 1], ['c', 1]],\n   * }\n   * ```\n   */\n  full?: boolean;\n}\n\n/** @public */\nexport interface IndexDescription\n  extends Pick<\n    CreateIndexesOptions,\n    | 'background'\n    | 'unique'\n    | 'partialFilterExpression'\n    | 'sparse'\n    | 'hidden'\n    | 'expireAfterSeconds'\n    | 'storageEngine'\n    | 'version'\n    | 'weights'\n    | 'default_language'\n    | 'language_override'\n    | 'textIndexVersion'\n    | '2dsphereIndexVersion'\n    | 'bits'\n    | 'min'\n    | 'max'\n    | 'bucketSize'\n    | 'wildcardProjection'\n  > {\n  collation?: CollationOptions;\n  name?: string;\n  key: { [key: string]: IndexDirection } | Map<string, IndexDirection>;\n}\n\n/** @public */\nexport interface CreateIndexesOptions extends Omit<CommandOperationOptions, 'writeConcern'> {\n  /** Creates the index in the background, yielding whenever possible. */\n  background?: boolean;\n  /** Creates an unique index. */\n  unique?: boolean;\n  /** Override the autogenerated index name (useful if the resulting name is larger than 128 bytes) */\n  name?: string;\n  /** Creates a partial index based on the given filter object (MongoDB 3.2 or higher) */\n  partialFilterExpression?: Document;\n  /** Creates a sparse index. */\n  sparse?: boolean;\n  /** Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher) */\n  expireAfterSeconds?: number;\n  /** Allows users to configure the storage engine on a per-index basis when creating an index. (MongoDB 3.0 or higher) */\n  storageEngine?: Document;\n  /** (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes. */\n  commitQuorum?: number | string;\n  /** Specifies the index version number, either 0 or 1. */\n  version?: number;\n  // text indexes\n  weights?: Document;\n  default_language?: string;\n  language_override?: string;\n  textIndexVersion?: number;\n  // 2d-sphere indexes\n  '2dsphereIndexVersion'?: number;\n  // 2d indexes\n  bits?: number;\n  /** For geospatial indexes set the lower bound for the co-ordinates. */\n  min?: number;\n  /** For geospatial indexes set the high bound for the co-ordinates. */\n  max?: number;\n  // geoHaystack Indexes\n  bucketSize?: number;\n  // wildcard indexes\n  wildcardProjection?: Document;\n  /** Specifies that the index should exist on the target collection but should not be used by the query planner when executing operations. (MongoDB 4.4 or higher) */\n  hidden?: boolean;\n}\n\nfunction isSingleIndexTuple(t: unknown): t is [string, IndexDirection] {\n  return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);\n}\n\n/**\n * Converts an `IndexSpecification`, which can be specified in multiple formats, into a\n * valid `key` for the createIndexes command.\n */\nfunction constructIndexDescriptionMap(indexSpec: IndexSpecification): Map<string, IndexDirection> {\n  const key: Map<string, IndexDirection> = new Map();\n\n  const indexSpecs =\n    !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;\n\n  // Iterate through array and handle different types\n  for (const spec of indexSpecs) {\n    if (typeof spec === 'string') {\n      key.set(spec, 1);\n    } else if (Array.isArray(spec)) {\n      key.set(spec[0], spec[1] ?? 1);\n    } else if (spec instanceof Map) {\n      for (const [property, value] of spec) {\n        key.set(property, value);\n      }\n    } else if (isObject(spec)) {\n      for (const [property, value] of Object.entries(spec)) {\n        key.set(property, value);\n      }\n    }\n  }\n\n  return key;\n}\n\n/**\n * Receives an index description and returns a modified index description which has had invalid options removed\n * from the description and has mapped the `version` option to the `v` option.\n */\nfunction resolveIndexDescription(\n  description: IndexDescription\n): Omit<ResolvedIndexDescription, 'key'> {\n  const validProvidedOptions = Object.entries(description).filter(([optionName]) =>\n    VALID_INDEX_OPTIONS.has(optionName)\n  );\n\n  return Object.fromEntries(\n    // we support the `version` option, but the `createIndexes` command expects it to be the `v`\n    validProvidedOptions.map(([name, value]) => (name === 'version' ? ['v', value] : [name, value]))\n  );\n}\n\n/**\n * @public\n * The index information returned by the listIndexes command. https://www.mongodb.com/docs/manual/reference/command/listIndexes/#mongodb-dbcommand-dbcmd.listIndexes\n */\nexport type IndexDescriptionInfo = Omit<IndexDescription, 'key' | 'version'> & {\n  key: { [key: string]: IndexDirection };\n  v?: IndexDescription['version'];\n} & Document;\n\n/** @public */\nexport type IndexDescriptionCompact = Record<string, [name: string, direction: IndexDirection][]>;\n\n/**\n * @internal\n *\n * Internally, the driver represents index description keys with `Map`s to preserve key ordering.\n * We don't require users to specify maps, so we transform user provided descriptions into\n * \"resolved\" by converting the `key` into a JS `Map`, if it isn't already a map.\n *\n * Additionally, we support the `version` option, but the `createIndexes` command uses the field `v`\n * to specify the index version so we map the value of `version` to `v`, if provided.\n */\ntype ResolvedIndexDescription = Omit<IndexDescription, 'key' | 'version'> & {\n  key: Map<string, IndexDirection>;\n  v?: IndexDescription['version'];\n};\n\n/** @internal */\nexport class CreateIndexesOperation extends CommandOperation<string[]> {\n  override options: CreateIndexesOptions;\n  collectionName: string;\n  indexes: ReadonlyArray<ResolvedIndexDescription>;\n\n  private constructor(\n    parent: OperationParent,\n    collectionName: string,\n    indexes: IndexDescription[],\n    options?: CreateIndexesOptions\n  ) {\n    super(parent, options);\n\n    this.options = options ?? {};\n    this.collectionName = collectionName;\n    this.indexes = indexes.map((userIndex: IndexDescription): ResolvedIndexDescription => {\n      // Ensure the key is a Map to preserve index key ordering\n      const key =\n        userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));\n      const name = userIndex.name ?? Array.from(key).flat().join('_');\n      const validIndexOptions = resolveIndexDescription(userIndex);\n      return {\n        ...validIndexOptions,\n        name,\n        key\n      };\n    });\n  }\n\n  static fromIndexDescriptionArray(\n    parent: OperationParent,\n    collectionName: string,\n    indexes: IndexDescription[],\n    options?: CreateIndexesOptions\n  ): CreateIndexesOperation {\n    return new CreateIndexesOperation(parent, collectionName, indexes, options);\n  }\n\n  static fromIndexSpecification(\n    parent: OperationParent,\n    collectionName: string,\n    indexSpec: IndexSpecification,\n    options: CreateIndexesOptions = {}\n  ): CreateIndexesOperation {\n    const key = constructIndexDescriptionMap(indexSpec);\n    const description: IndexDescription = { ...options, key };\n    return new CreateIndexesOperation(parent, collectionName, [description], options);\n  }\n\n  override get commandName() {\n    return 'createIndexes';\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<string[]> {\n    const options = this.options;\n    const indexes = this.indexes;\n\n    const serverWireVersion = maxWireVersion(server);\n\n    const cmd: Document = { createIndexes: this.collectionName, indexes };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        throw new MongoCompatibilityError(\n          'Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'\n        );\n      }\n      cmd.commitQuorum = options.commitQuorum;\n    }\n\n    // collation is set on each index, it should not be defined at the root\n    this.options.collation = undefined;\n\n    await super.executeCommand(server, session, cmd, timeoutContext);\n\n    const indexNames = indexes.map(index => index.name || '');\n    return indexNames;\n  }\n}\n\n/** @public */\nexport type DropIndexesOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropIndexOperation extends CommandOperation<Document> {\n  override options: DropIndexesOptions;\n  collection: Collection;\n  indexName: string;\n\n  constructor(collection: Collection, indexName: string, options?: DropIndexesOptions) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n\n  override get commandName() {\n    return 'dropIndexes' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Document> {\n    const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };\n    return await super.executeCommand(server, session, cmd, timeoutContext);\n  }\n}\n\n/** @public */\nexport type ListIndexesOptions = AbstractCursorOptions & {\n  /** @internal */\n  omitMaxTimeMS?: boolean;\n};\n\n/** @internal */\nexport class ListIndexesOperation extends CommandOperation<CursorResponse> {\n  /**\n   * @remarks WriteConcern can still be present on the options because\n   * we inherit options from the client/db/collection.  The\n   * key must be present on the options in order to delete it.\n   * This allows typescript to delete the key but will\n   * not allow a writeConcern to be assigned as a property on options.\n   */\n  override options: ListIndexesOptions & { writeConcern?: never };\n  collectionNamespace: MongoDBNamespace;\n\n  constructor(collection: Collection, options?: ListIndexesOptions) {\n    super(collection, options);\n\n    this.options = { ...options };\n    delete this.options.writeConcern;\n    this.collectionNamespace = collection.s.namespace;\n  }\n\n  override get commandName() {\n    return 'listIndexes' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<CursorResponse> {\n    const serverWireVersion = maxWireVersion(server);\n\n    const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};\n\n    const command: Document = { listIndexes: this.collectionNamespace.collection, cursor };\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n\n    return await super.executeCommand(server, session, command, timeoutContext, CursorResponse);\n  }\n}\n\ndefineAspects(ListIndexesOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.CURSOR_CREATING\n]);\ndefineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropIndexOperation, [Aspect.WRITE_OPERATION]);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1414, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1418, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/distinct.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { decorateWithCollation, decorateWithReadConcern } from '../utils';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport type DistinctOptions = CommandOperationOptions & {\n  /**\n   * @sinceServerVersion 7.1\n   *\n   * The index to use. Specify either the index name as a string or the index key pattern.\n   * If specified, then the query system will only consider plans using the hinted index.\n   *\n   * If provided as a string, `hint` must be index name for an index on the collection.\n   * If provided as an object, `hint` must be an index description for an index defined on the collection.\n   *\n   * See https://www.mongodb.com/docs/manual/reference/command/distinct/#command-fields.\n   */\n  hint?: Document | string;\n};\n\n/**\n * Return a list of distinct values for the given key across a collection.\n * @internal\n */\nexport class DistinctOperation extends CommandOperation<any[]> {\n  override options: DistinctOptions;\n  collection: Collection;\n  /** Field of the document to find distinct values for. */\n  key: string;\n  /** The query for filtering the set of documents to which we apply the distinct filter. */\n  query: Document;\n\n  /**\n   * Construct a Distinct operation.\n   *\n   * @param collection - Collection instance.\n   * @param key - Field of the document to find distinct values for.\n   * @param query - The query for filtering the set of documents to which we apply the distinct filter.\n   * @param options - Optional settings. See Collection.prototype.distinct for a list of options.\n   */\n  constructor(collection: Collection, key: string, query: Document, options?: DistinctOptions) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collection = collection;\n    this.key = key;\n    this.query = query;\n  }\n\n  override get commandName() {\n    return 'distinct' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<any[]> {\n    const coll = this.collection;\n    const key = this.key;\n    const query = this.query;\n    const options = this.options;\n\n    // Distinct command\n    const cmd: Document = {\n      distinct: coll.collectionName,\n      key: key,\n      query: query\n    };\n\n    // Add maxTimeMS if defined\n    if (typeof options.maxTimeMS === 'number') {\n      cmd.maxTimeMS = options.maxTimeMS;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (typeof options.comment !== 'undefined') {\n      cmd.comment = options.comment;\n    }\n\n    if (options.hint != null) {\n      cmd.hint = options.hint;\n    }\n\n    // Do we have a readConcern specified\n    decorateWithReadConcern(cmd, coll, options);\n\n    // Have we specified collation\n    decorateWithCollation(cmd, coll, options);\n\n    const result = await super.executeCommand(server, session, cmd, timeoutContext);\n\n    return this.explain ? result : result.values;\n  }\n}\n\ndefineAspects(DistinctOperation, [Aspect.READ_OPERATION, Aspect.RETRYABLE, Aspect.EXPLAINABLE]);\n"],"names":[],"mappings":";;;;;AAKA,MAAA;AACA,MAAA;AACA,MAAA;AAkBA;;;IAIA,MAAa,0BAA0B,UAAA,gBAAuB;IAQ5D;;;;;;;QAQA,YAAY,UAAsB,EAAE,GAAW,EAAE,KAAe,EAAE,OAAyB,CAAA;QACzF,KAAK,CAAC,YAAY;QAElB,IAAI,CAAC,OAAO,GAAG,WAAW,CAAA;QAC1B,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,KAAK,GAAG;IACf;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,OAAO,IAAI,CAAC,UAAU;QAC5B,MAAM,MAAM,IAAI,CAAC,GAAG;QACpB,MAAM,QAAQ,IAAI,CAAC,KAAK;QACxB,MAAM,UAAU,IAAI,CAAC,OAAO;QAE5B,mBAAmB;QACnB,MAAM,MAAgB;YACpB,UAAU,KAAK,cAAc;YAC7B,KAAK;YACL,OAAO;;QAGT,2BAA2B;QAC3B,IAAI,OAAO,QAAQ,SAAS,KAAK,UAAU;YACzC,IAAI,SAAS,GAAG,QAAQ,SAAS;QACnC;QAEA,iEAAiE;QACjE,gDAAgD;QAChD,IAAI,OAAO,QAAQ,OAAO,KAAK,aAAa;YAC1C,IAAI,OAAO,GAAG,QAAQ,OAAO;QAC/B;QAEA,IAAI,QAAQ,IAAI,IAAI,MAAM;YACxB,IAAI,IAAI,GAAG,QAAQ,IAAI;QACzB;QAEA,qCAAqC;QACrC,CAAA,GAAA,QAAA,uBAAuB,EAAC,KAAK,MAAM;QAEnC,8BAA8B;QAC9B,CAAA,GAAA,QAAA,qBAAqB,EAAC,KAAK,MAAM;QAEjC,MAAM,SAAS,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS,KAAK;QAEhE,OAAO,IAAI,CAAC,OAAO,GAAG,SAAS,OAAO,MAAM;IAC9C;;AAtEF,QAAA,iBAAA,GAAA;AAyEA,CAAA,GAAA,YAAA,aAAa,EAAC,mBAAmB;IAAC,YAAA,MAAM,CAAC,cAAc;IAAE,YAAA,MAAM,CAAC,SAAS;IAAE,YAAA,MAAM,CAAC,WAAW;CAAC"}},
    {"offset": {"line": 1484, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1488, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/drop.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Db } from '../db';\nimport { MONGODB_ERROR_CODES, MongoServerError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface DropCollectionOptions extends CommandOperationOptions {\n  /** @experimental */\n  encryptedFields?: Document;\n}\n\n/** @internal */\nexport class DropCollectionOperation extends CommandOperation<boolean> {\n  override options: DropCollectionOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options: DropCollectionOptions = {}) {\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  override get commandName() {\n    return 'drop' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<boolean> {\n    const db = this.db;\n    const options = this.options;\n    const name = this.name;\n\n    const encryptedFieldsMap = db.client.s.options.autoEncryption?.encryptedFieldsMap;\n    let encryptedFields: Document | undefined =\n      options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n    if (!encryptedFields && encryptedFieldsMap) {\n      // If the MongoClient was configured with an encryptedFieldsMap,\n      // and no encryptedFields config was available in it or explicitly\n      // passed as an argument, the spec tells us to look one up using\n      // listCollections().\n      const listCollectionsResult = await db\n        .listCollections({ name }, { nameOnly: false })\n        .toArray();\n      encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n    }\n\n    if (encryptedFields) {\n      const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n      const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n      for (const collectionName of [escCollection, ecocCollection]) {\n        // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n        const dropOp = new DropCollectionOperation(db, collectionName);\n        try {\n          await dropOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);\n        } catch (err) {\n          if (\n            !(err instanceof MongoServerError) ||\n            err.code !== MONGODB_ERROR_CODES.NamespaceNotFound\n          ) {\n            throw err;\n          }\n        }\n      }\n    }\n\n    return await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);\n  }\n\n  private async executeWithoutEncryptedFieldsCheck(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<boolean> {\n    await super.executeCommand(server, session, { drop: this.name }, timeoutContext);\n    return true;\n  }\n}\n\n/** @public */\nexport type DropDatabaseOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropDatabaseOperation extends CommandOperation<boolean> {\n  override options: DropDatabaseOptions;\n\n  constructor(db: Db, options: DropDatabaseOptions) {\n    super(db, options);\n    this.options = options;\n  }\n  override get commandName() {\n    return 'dropDatabase' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<boolean> {\n    await super.executeCommand(server, session, { dropDatabase: 1 }, timeoutContext);\n    return true;\n  }\n}\n\ndefineAspects(DropCollectionOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropDatabaseOperation, [Aspect.WRITE_OPERATION]);\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AAIA,MAAA;AACA,MAAA;AAQA,cAAA,GACA,MAAa,gCAAgC,UAAA,gBAAyB;IAKpE,YAAY,EAAM,EAAE,IAAY,EAAE,UAAiC,CAAA,CAAE,CAAA;QACnE,KAAK,CAAC,IAAI;QACV,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,IAAI,GAAG;IACd;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,KAAK,IAAI,CAAC,EAAE;QAClB,MAAM,UAAU,IAAI,CAAC,OAAO;QAC5B,MAAM,OAAO,IAAI,CAAC,IAAI;QAEtB,MAAM,qBAAqB,GAAG,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,cAAc,EAAE;QAC/D,IAAI,kBACF,QAAQ,eAAe,IAAI,oBAAoB,CAAC,CAAA,EAAG,GAAG,YAAY,CAAA,CAAA,EAAI,KAAI,CAAE,CAAC;QAE/E,IAAI,CAAC,mBAAmB,oBAAoB;YAC1C,gEAAgE;YAChE,kEAAkE;YAClE,gEAAgE;YAChE,qBAAqB;YACrB,MAAM,wBAAwB,MAAM,GACjC,eAAe,CAAC;gBAAE;YAAI,GAAI;gBAAE,UAAU;YAAK,GAC3C,OAAO;YACV,kBAAkB,uBAAuB,CAAC,EAAE,EAAE,SAAS;QACzD;QAEA,IAAI,iBAAiB;YACnB,MAAM,gBAAgB,gBAAgB,aAAa,IAAI,CAAA,QAAA,EAAW,KAAI,IAAA,CAAM;YAC5E,MAAM,iBAAiB,gBAAgB,cAAc,IAAI,CAAA,QAAA,EAAW,KAAI,KAAA,CAAO;YAE/E,KAAK,MAAM,kBAAkB;gBAAC;gBAAe;aAAe,CAAE;gBAC5D,4EAA4E;gBAC5E,MAAM,SAAS,IAAI,wBAAwB,IAAI;gBAC/C,IAAI;oBACF,MAAM,OAAO,kCAAkC,CAAC,QAAQ,SAAS;gBACnE,EAAE,OAAO,KAAK;oBACZ,IACE,CAAC,CAAC,eAAe,QAAA,gBAAgB,KACjC,IAAI,IAAI,KAAK,QAAA,mBAAmB,CAAC,iBAAiB,EAClD;wBACA,MAAM;oBACR;gBACF;YACF;QACF;QAEA,OAAO,MAAM,IAAI,CAAC,kCAAkC,CAAC,QAAQ,SAAS;IACxE;IAEQ,MAAM,mCACZ,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS;YAAE,MAAM,IAAI,CAAC,IAAI;QAAA,GAAI;QACjE,OAAO;IACT;;AAtEF,QAAA,uBAAA,GAAA;AA4EA,cAAA,GACA,MAAa,8BAA8B,UAAA,gBAAyB;IAGlE,YAAY,EAAM,EAAE,OAA4B,CAAA;QAC9C,KAAK,CAAC,IAAI;QACV,IAAI,CAAC,OAAO,GAAG;IACjB;IACA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS;YAAE,cAAc;QAAC,GAAI;QACjE,OAAO;IACT;;AAlBF,QAAA,qBAAA,GAAA;AAqBA,CAAA,GAAA,YAAA,aAAa,EAAC,yBAAyB;IAAC,YAAA,MAAM,CAAC,eAAe;CAAC;AAC/D,CAAA,GAAA,YAAA,aAAa,EAAC,uBAAuB;IAAC,YAAA,MAAM,CAAC,eAAe;CAAC"}},
    {"offset": {"line": 1574, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1578, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/estimated_document_count.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface EstimatedDocumentCountOptions extends CommandOperationOptions {\n  /**\n   * The maximum amount of time to allow the operation to run.\n   *\n   * This option is sent only if the caller explicitly provides a value. The default is to not send a value.\n   */\n  maxTimeMS?: number;\n}\n\n/** @internal */\nexport class EstimatedDocumentCountOperation extends CommandOperation<number> {\n  override options: EstimatedDocumentCountOptions;\n  collectionName: string;\n\n  constructor(collection: Collection, options: EstimatedDocumentCountOptions = {}) {\n    super(collection, options);\n    this.options = options;\n    this.collectionName = collection.collectionName;\n  }\n\n  override get commandName() {\n    return 'count' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<number> {\n    const cmd: Document = { count: this.collectionName };\n\n    if (typeof this.options.maxTimeMS === 'number') {\n      cmd.maxTimeMS = this.options.maxTimeMS;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (this.options.comment !== undefined) {\n      cmd.comment = this.options.comment;\n    }\n\n    const response = await super.executeCommand(server, session, cmd, timeoutContext);\n\n    return response?.n || 0;\n  }\n}\n\ndefineAspects(EstimatedDocumentCountOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.CURSOR_CREATING\n]);\n"],"names":[],"mappings":";;;;;AAKA,MAAA;AACA,MAAA;AAYA,cAAA,GACA,MAAa,wCAAwC,UAAA,gBAAwB;IAI3E,YAAY,UAAsB,EAAE,UAAyC,CAAA,CAAE,CAAA;QAC7E,KAAK,CAAC,YAAY;QAClB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,cAAc,GAAG,WAAW,cAAc;IACjD;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,MAAgB;YAAE,OAAO,IAAI,CAAC,cAAc;QAAA;QAElD,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,KAAK,UAAU;YAC9C,IAAI,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS;QACxC;QAEA,iEAAiE;QACjE,gDAAgD;QAChD,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,WAAW;YACtC,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO;QACpC;QAEA,MAAM,WAAW,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS,KAAK;QAElE,OAAO,UAAU,KAAK;IACxB;;AAlCF,QAAA,+BAAA,GAAA;AAqCA,CAAA,GAAA,YAAA,aAAa,EAAC,iCAAiC;IAC7C,YAAA,MAAM,CAAC,cAAc;IACrB,YAAA,MAAM,CAAC,SAAS;IAChB,YAAA,MAAM,CAAC,eAAe;CACvB"}},
    {"offset": {"line": 1616, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1620, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/find_and_modify.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport { MongoCompatibilityError, MongoInvalidArgumentError } from '../error';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { formatSort, type Sort, type SortForCmd } from '../sort';\nimport { type TimeoutContext } from '../timeout';\nimport { decorateWithCollation, hasAtomicOperators, maxWireVersion } from '../utils';\nimport { type WriteConcern, type WriteConcernSettings } from '../write_concern';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport const ReturnDocument = Object.freeze({\n  BEFORE: 'before',\n  AFTER: 'after'\n} as const);\n\n/** @public */\nexport type ReturnDocument = (typeof ReturnDocument)[keyof typeof ReturnDocument];\n\n/** @public */\nexport interface FindOneAndDeleteOptions extends CommandOperationOptions {\n  /** An optional hint for query optimization. See the {@link https://www.mongodb.com/docs/manual/reference/command/update/#update-command-hint|update command} reference for more information.*/\n  hint?: Document;\n  /** Limits the fields to return for all matching documents. */\n  projection?: Document;\n  /** Determines which document the operation modifies if the query selects multiple documents. */\n  sort?: Sort;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  /**\n   * Return the ModifyResult instead of the modified document. Defaults to false\n   */\n  includeResultMetadata?: boolean;\n}\n\n/** @public */\nexport interface FindOneAndReplaceOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** An optional hint for query optimization. See the {@link https://www.mongodb.com/docs/manual/reference/command/update/#update-command-hint|update command} reference for more information.*/\n  hint?: Document;\n  /** Limits the fields to return for all matching documents. */\n  projection?: Document;\n  /** When set to 'after', returns the updated document rather than the original. The default is 'before'.  */\n  returnDocument?: ReturnDocument;\n  /** Determines which document the operation modifies if the query selects multiple documents. */\n  sort?: Sort;\n  /** Upsert the document if it does not exist. */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  /**\n   * Return the ModifyResult instead of the modified document. Defaults to false\n   */\n  includeResultMetadata?: boolean;\n}\n\n/** @public */\nexport interface FindOneAndUpdateOptions extends CommandOperationOptions {\n  /** Optional list of array filters referenced in filtered positional operators */\n  arrayFilters?: Document[];\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** An optional hint for query optimization. See the {@link https://www.mongodb.com/docs/manual/reference/command/update/#update-command-hint|update command} reference for more information.*/\n  hint?: Document;\n  /** Limits the fields to return for all matching documents. */\n  projection?: Document;\n  /** When set to 'after', returns the updated document rather than the original. The default is 'before'.  */\n  returnDocument?: ReturnDocument;\n  /** Determines which document the operation modifies if the query selects multiple documents. */\n  sort?: Sort;\n  /** Upsert the document if it does not exist. */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  /**\n   * Return the ModifyResult instead of the modified document. Defaults to false\n   */\n  includeResultMetadata?: boolean;\n}\n\n/** @internal */\ninterface FindAndModifyCmdBase {\n  remove: boolean;\n  new: boolean;\n  upsert: boolean;\n  update?: Document;\n  sort?: SortForCmd;\n  fields?: Document;\n  bypassDocumentValidation?: boolean;\n  arrayFilters?: Document[];\n  maxTimeMS?: number;\n  let?: Document;\n  writeConcern?: WriteConcern | WriteConcernSettings;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n}\n\nfunction configureFindAndModifyCmdBaseUpdateOpts(\n  cmdBase: FindAndModifyCmdBase,\n  options: FindOneAndReplaceOptions | FindOneAndUpdateOptions\n): FindAndModifyCmdBase {\n  cmdBase.new = options.returnDocument === ReturnDocument.AFTER;\n  cmdBase.upsert = options.upsert === true;\n\n  if (options.bypassDocumentValidation === true) {\n    cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;\n  }\n  return cmdBase;\n}\n\n/** @internal */\nexport class FindAndModifyOperation extends CommandOperation<Document> {\n  override options: FindOneAndReplaceOptions | FindOneAndUpdateOptions | FindOneAndDeleteOptions;\n  cmdBase: FindAndModifyCmdBase;\n  collection: Collection;\n  query: Document;\n  doc?: Document;\n\n  constructor(\n    collection: Collection,\n    query: Document,\n    options: FindOneAndReplaceOptions | FindOneAndUpdateOptions | FindOneAndDeleteOptions\n  ) {\n    super(collection, options);\n    this.options = options ?? {};\n    this.cmdBase = {\n      remove: false,\n      new: false,\n      upsert: false\n    };\n\n    options.includeResultMetadata ??= false;\n\n    const sort = formatSort(options.sort);\n    if (sort) {\n      this.cmdBase.sort = sort;\n    }\n\n    if (options.projection) {\n      this.cmdBase.fields = options.projection;\n    }\n\n    if (options.maxTimeMS) {\n      this.cmdBase.maxTimeMS = options.maxTimeMS;\n    }\n\n    // Decorate the findAndModify command with the write Concern\n    if (options.writeConcern) {\n      this.cmdBase.writeConcern = options.writeConcern;\n    }\n\n    if (options.let) {\n      this.cmdBase.let = options.let;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cmdBase.comment = options.comment;\n    }\n\n    // force primary read preference\n    this.readPreference = ReadPreference.primary;\n\n    this.collection = collection;\n    this.query = query;\n  }\n\n  override get commandName() {\n    return 'findAndModify' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Document> {\n    const coll = this.collection;\n    const query = this.query;\n    const options = { ...this.options, ...this.bsonOptions };\n\n    // Create findAndModify command object\n    const cmd: Document = {\n      findAndModify: coll.collectionName,\n      query: query,\n      ...this.cmdBase\n    };\n\n    decorateWithCollation(cmd, coll, options);\n\n    if (options.hint) {\n      // TODO: once this method becomes a CommandOperation we will have the server\n      // in place to check.\n      const unacknowledgedWrite = this.writeConcern?.w === 0;\n      if (unacknowledgedWrite || maxWireVersion(server) < 8) {\n        throw new MongoCompatibilityError(\n          'The current topology does not support a hint on findAndModify commands'\n        );\n      }\n\n      cmd.hint = options.hint;\n    }\n\n    // Execute the command\n    const result = await super.executeCommand(server, session, cmd, timeoutContext);\n    return options.includeResultMetadata ? result : (result.value ?? null);\n  }\n}\n\n/** @internal */\nexport class FindOneAndDeleteOperation extends FindAndModifyOperation {\n  constructor(collection: Collection, filter: Document, options: FindOneAndDeleteOptions) {\n    // Basic validation\n    if (filter == null || typeof filter !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"filter\" must be an object');\n    }\n\n    super(collection, filter, options);\n    this.cmdBase.remove = true;\n  }\n}\n\n/** @internal */\nexport class FindOneAndReplaceOperation extends FindAndModifyOperation {\n  constructor(\n    collection: Collection,\n    filter: Document,\n    replacement: Document,\n    options: FindOneAndReplaceOptions\n  ) {\n    if (filter == null || typeof filter !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"filter\" must be an object');\n    }\n\n    if (replacement == null || typeof replacement !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"replacement\" must be an object');\n    }\n\n    if (hasAtomicOperators(replacement)) {\n      throw new MongoInvalidArgumentError('Replacement document must not contain atomic operators');\n    }\n\n    super(collection, filter, options);\n    this.cmdBase.update = replacement;\n    configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);\n  }\n}\n\n/** @internal */\nexport class FindOneAndUpdateOperation extends FindAndModifyOperation {\n  constructor(\n    collection: Collection,\n    filter: Document,\n    update: Document,\n    options: FindOneAndUpdateOptions\n  ) {\n    if (filter == null || typeof filter !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"filter\" must be an object');\n    }\n\n    if (update == null || typeof update !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"update\" must be an object');\n    }\n\n    if (!hasAtomicOperators(update, options)) {\n      throw new MongoInvalidArgumentError('Update document requires atomic operators');\n    }\n\n    super(collection, filter, options);\n    this.cmdBase.update = update;\n    configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);\n\n    if (options.arrayFilters) {\n      this.cmdBase.arrayFilters = options.arrayFilters;\n    }\n  }\n}\n\ndefineAspects(FindAndModifyOperation, [\n  Aspect.WRITE_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.EXPLAINABLE\n]);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1769, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/is_capped.ts"],"sourcesContent":["import type { Collection } from '../collection';\nimport { MongoAPIError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { AbstractOperation, type OperationOptions } from './operation';\n\n/** @internal */\nexport class IsCappedOperation extends AbstractOperation<boolean> {\n  override options: OperationOptions;\n  collection: Collection;\n\n  constructor(collection: Collection, options: OperationOptions) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  override get commandName() {\n    return 'listCollections' as const;\n  }\n\n  override async execute(server: Server, session: ClientSession | undefined): Promise<boolean> {\n    const coll = this.collection;\n    const [collection] = await coll.s.db\n      .listCollections(\n        { name: coll.collectionName },\n        { ...this.options, nameOnly: false, readPreference: this.readPreference, session }\n      )\n      .toArray();\n    if (collection == null || collection.options == null) {\n      throw new MongoAPIError(`collection ${coll.namespace} not found`);\n    }\n    return !!collection.options?.capped;\n  }\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAGA,MAAA;AAEA,cAAA,GACA,MAAa,0BAA0B,YAAA,iBAA0B;IAI/D,YAAY,UAAsB,EAAE,OAAyB,CAAA;QAC3D,KAAK,CAAC;QACN,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,UAAU,GAAG;IACpB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QAAQ,MAAc,EAAE,OAAkC,EAAA;QACvE,MAAM,OAAO,IAAI,CAAC,UAAU;QAC5B,MAAM,CAAC,WAAW,GAAG,MAAM,KAAK,CAAC,CAAC,EAAE,CACjC,eAAe,CACd;YAAE,MAAM,KAAK,cAAc;QAAA,GAC3B;YAAE,GAAG,IAAI,CAAC,OAAO;YAAE,UAAU;YAAO,gBAAgB,IAAI,CAAC,cAAc;YAAE;QAAO,GAEjF,OAAO;QACV,IAAI,cAAc,QAAQ,WAAW,OAAO,IAAI,MAAM;YACpD,MAAM,IAAI,QAAA,aAAa,CAAC,CAAA,WAAA,EAAc,KAAK,SAAS,CAAA,UAAA,CAAY;QAClE;QACA,OAAO,CAAC,CAAC,WAAW,OAAO,EAAE;IAC/B;;AA1BF,QAAA,iBAAA,GAAA"}},
    {"offset": {"line": 1802, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/options_operation.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport { MongoAPIError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { AbstractOperation, type OperationOptions } from './operation';\n\n/** @internal */\nexport class OptionsOperation extends AbstractOperation<Document> {\n  override options: OperationOptions;\n  collection: Collection;\n\n  constructor(collection: Collection, options: OperationOptions) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n  override get commandName() {\n    return 'listCollections' as const;\n  }\n\n  override async execute(server: Server, session: ClientSession | undefined): Promise<Document> {\n    const coll = this.collection;\n    const [collection] = await coll.s.db\n      .listCollections(\n        { name: coll.collectionName },\n        { ...this.options, nameOnly: false, readPreference: this.readPreference, session }\n      )\n      .toArray();\n    if (collection == null || collection.options == null) {\n      throw new MongoAPIError(`collection ${coll.namespace} not found`);\n    }\n    return collection.options;\n  }\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AAGA,MAAA;AAEA,cAAA,GACA,MAAa,yBAAyB,YAAA,iBAA2B;IAI/D,YAAY,UAAsB,EAAE,OAAyB,CAAA;QAC3D,KAAK,CAAC;QACN,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,UAAU,GAAG;IACpB;IACA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QAAQ,MAAc,EAAE,OAAkC,EAAA;QACvE,MAAM,OAAO,IAAI,CAAC,UAAU;QAC5B,MAAM,CAAC,WAAW,GAAG,MAAM,KAAK,CAAC,CAAC,EAAE,CACjC,eAAe,CACd;YAAE,MAAM,KAAK,cAAc;QAAA,GAC3B;YAAE,GAAG,IAAI,CAAC,OAAO;YAAE,UAAU;YAAO,gBAAgB,IAAI,CAAC,cAAc;YAAE;QAAO,GAEjF,OAAO;QACV,IAAI,cAAc,QAAQ,WAAW,OAAO,IAAI,MAAM;YACpD,MAAM,IAAI,QAAA,aAAa,CAAC,CAAA,WAAA,EAAc,KAAK,SAAS,CAAA,UAAA,CAAY;QAClE;QACA,OAAO,WAAW,OAAO;IAC3B;;AAzBF,QAAA,gBAAA,GAAA"}},
    {"offset": {"line": 1839, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1843, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/rename.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { Collection } from '../collection';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { MongoDBNamespace } from '../utils';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface RenameOptions extends CommandOperationOptions {\n  /** Drop the target name collection if it previously exists. */\n  dropTarget?: boolean;\n  /** Unclear */\n  new_collection?: boolean;\n}\n\n/** @internal */\nexport class RenameOperation extends CommandOperation<Document> {\n  constructor(\n    public collection: Collection,\n    public newName: string,\n    public override options: RenameOptions\n  ) {\n    super(collection, options);\n    this.ns = new MongoDBNamespace('admin', '$cmd');\n  }\n\n  override get commandName(): string {\n    return 'renameCollection' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Collection> {\n    // Build the command\n    const renameCollection = this.collection.namespace;\n    const toCollection = this.collection.s.namespace.withCollection(this.newName).toString();\n    const dropTarget =\n      typeof this.options.dropTarget === 'boolean' ? this.options.dropTarget : false;\n\n    const command = {\n      renameCollection: renameCollection,\n      to: toCollection,\n      dropTarget: dropTarget\n    };\n\n    await super.executeCommand(server, session, command, timeoutContext);\n    return new Collection(this.collection.s.db, this.newName, this.collection.s.options);\n  }\n}\n\ndefineAspects(RenameOperation, [Aspect.WRITE_OPERATION]);\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAIA,MAAA;AACA,MAAA;AACA,MAAA;AAUA,cAAA,GACA,MAAa,wBAAwB,UAAA,gBAA0B;IAC7D,YACS,UAAsB,EACtB,OAAe,EACN,OAAsB,CAAA;QAEtC,KAAK,CAAC,YAAY;QAJX,IAAA,CAAA,UAAU,GAAV;QACA,IAAA,CAAA,OAAO,GAAP;QACS,IAAA,CAAA,OAAO,GAAP;QAGhB,IAAI,CAAC,EAAE,GAAG,IAAI,QAAA,gBAAgB,CAAC,SAAS;IAC1C;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,oBAAoB;QACpB,MAAM,mBAAmB,IAAI,CAAC,UAAU,CAAC,SAAS;QAClD,MAAM,eAAe,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ;QACtF,MAAM,aACJ,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,KAAK,YAAY,IAAI,CAAC,OAAO,CAAC,UAAU,GAAG;QAE3E,MAAM,UAAU;YACd,kBAAkB;YAClB,IAAI;YACJ,YAAY;;QAGd,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS,SAAS;QACrD,OAAO,IAAI,aAAA,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO;IACrF;;AAjCF,QAAA,eAAA,GAAA;AAoCA,CAAA,GAAA,YAAA,aAAa,EAAC,iBAAiB;IAAC,YAAA,MAAM,CAAC,eAAe;CAAC"}},
    {"offset": {"line": 1881, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1885, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/search_indexes/create.ts"],"sourcesContent":["import type { Document } from '../../bson';\nimport type { Collection } from '../../collection';\nimport type { Server } from '../../sdam/server';\nimport type { ClientSession } from '../../sessions';\nimport { type TimeoutContext } from '../../timeout';\nimport { AbstractOperation } from '../operation';\n\n/**\n * @public\n */\nexport interface SearchIndexDescription extends Document {\n  /** The name of the index. */\n  name?: string;\n\n  /** The index definition. */\n  definition: Document;\n\n  /** The type of the index.  Currently `search` or `vectorSearch` are supported. */\n  type?: string;\n}\n\n/** @internal */\nexport class CreateSearchIndexesOperation extends AbstractOperation<string[]> {\n  constructor(\n    private readonly collection: Collection,\n    private readonly descriptions: ReadonlyArray<SearchIndexDescription>\n  ) {\n    super();\n  }\n\n  override get commandName() {\n    return 'createSearchIndexes' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<string[]> {\n    const namespace = this.collection.fullNamespace;\n    const command = {\n      createSearchIndexes: namespace.collection,\n      indexes: this.descriptions\n    };\n\n    const res = await server.command(namespace, command, {\n      session,\n      timeoutContext\n    });\n\n    const indexesCreated: Array<{ name: string }> = res?.indexesCreated ?? [];\n    return indexesCreated.map(({ name }) => name);\n  }\n}\n"],"names":[],"mappings":";;;;;AAKA,MAAA;AAgBA,cAAA,GACA,MAAa,qCAAqC,YAAA,iBAA2B;IAC3E,YACmB,UAAsB,EACtB,YAAmD,CAAA;QAEpE,KAAK;QAHY,IAAA,CAAA,UAAU,GAAV;QACA,IAAA,CAAA,YAAY,GAAZ;IAGnB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,YAAY,IAAI,CAAC,UAAU,CAAC,aAAa;QAC/C,MAAM,UAAU;YACd,qBAAqB,UAAU,UAAU;YACzC,SAAS,IAAI,CAAC,YAAY;;QAG5B,MAAM,MAAM,MAAM,OAAO,OAAO,CAAC,WAAW,SAAS;YACnD;YACA;;QAGF,MAAM,iBAA0C,KAAK,kBAAkB,EAAE;QACzE,OAAO,eAAe,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,GAAK;IAC1C;;AA9BF,QAAA,4BAAA,GAAA"}},
    {"offset": {"line": 1915, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1919, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/search_indexes/drop.ts"],"sourcesContent":["import type { Document } from '../../bson';\nimport type { Collection } from '../../collection';\nimport { MONGODB_ERROR_CODES, MongoServerError } from '../../error';\nimport type { Server } from '../../sdam/server';\nimport type { ClientSession } from '../../sessions';\nimport { type TimeoutContext } from '../../timeout';\nimport { AbstractOperation } from '../operation';\n\n/** @internal */\nexport class DropSearchIndexOperation extends AbstractOperation<void> {\n  constructor(\n    private readonly collection: Collection,\n    private readonly name: string\n  ) {\n    super();\n  }\n\n  override get commandName() {\n    return 'dropSearchIndex' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<void> {\n    const namespace = this.collection.fullNamespace;\n\n    const command: Document = {\n      dropSearchIndex: namespace.collection\n    };\n\n    if (typeof this.name === 'string') {\n      command.name = this.name;\n    }\n\n    try {\n      await server.command(namespace, command, { session, timeoutContext });\n    } catch (error) {\n      const isNamespaceNotFoundError =\n        error instanceof MongoServerError && error.code === MONGODB_ERROR_CODES.NamespaceNotFound;\n      if (!isNamespaceNotFoundError) {\n        throw error;\n      }\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AAIA,MAAA;AAEA,cAAA,GACA,MAAa,iCAAiC,YAAA,iBAAuB;IACnE,YACmB,UAAsB,EACtB,IAAY,CAAA;QAE7B,KAAK;QAHY,IAAA,CAAA,UAAU,GAAV;QACA,IAAA,CAAA,IAAI,GAAJ;IAGnB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,YAAY,IAAI,CAAC,UAAU,CAAC,aAAa;QAE/C,MAAM,UAAoB;YACxB,iBAAiB,UAAU,UAAU;;QAGvC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU;YACjC,QAAQ,IAAI,GAAG,IAAI,CAAC,IAAI;QAC1B;QAEA,IAAI;YACF,MAAM,OAAO,OAAO,CAAC,WAAW,SAAS;gBAAE;gBAAS;YAAc;QACpE,EAAE,OAAO,OAAO;YACd,MAAM,2BACJ,iBAAiB,QAAA,gBAAgB,IAAI,MAAM,IAAI,KAAK,QAAA,mBAAmB,CAAC,iBAAiB;YAC3F,IAAI,CAAC,0BAA0B;gBAC7B,MAAM;YACR;QACF;IACF;;AApCF,QAAA,wBAAA,GAAA"}},
    {"offset": {"line": 1957, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1961, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/search_indexes/update.ts"],"sourcesContent":["import type { Document } from '../../bson';\nimport type { Collection } from '../../collection';\nimport type { Server } from '../../sdam/server';\nimport type { ClientSession } from '../../sessions';\nimport { type TimeoutContext } from '../../timeout';\nimport { AbstractOperation } from '../operation';\n\n/** @internal */\nexport class UpdateSearchIndexOperation extends AbstractOperation<void> {\n  constructor(\n    private readonly collection: Collection,\n    private readonly name: string,\n    private readonly definition: Document\n  ) {\n    super();\n  }\n\n  override get commandName() {\n    return 'updateSearchIndex' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<void> {\n    const namespace = this.collection.fullNamespace;\n    const command = {\n      updateSearchIndex: namespace.collection,\n      name: this.name,\n      definition: this.definition\n    };\n\n    await server.command(namespace, command, { session, timeoutContext });\n    return;\n  }\n}\n"],"names":[],"mappings":";;;;;AAKA,MAAA;AAEA,cAAA,GACA,MAAa,mCAAmC,YAAA,iBAAuB;IACrE,YACmB,UAAsB,EACtB,IAAY,EACZ,UAAoB,CAAA;QAErC,KAAK;QAJY,IAAA,CAAA,UAAU,GAAV;QACA,IAAA,CAAA,IAAI,GAAJ;QACA,IAAA,CAAA,UAAU,GAAV;IAGnB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,YAAY,IAAI,CAAC,UAAU,CAAC,aAAa;QAC/C,MAAM,UAAU;YACd,mBAAmB,UAAU,UAAU;YACvC,MAAM,IAAI,CAAC,IAAI;YACf,YAAY,IAAI,CAAC,UAAU;;QAG7B,MAAM,OAAO,OAAO,CAAC,WAAW,SAAS;YAAE;YAAS;QAAc;QAClE;IACF;;AA3BF,QAAA,0BAAA,GAAA"}},
    {"offset": {"line": 1992, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1996, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/list_collections.ts"],"sourcesContent":["import type { Binary, Document } from '../bson';\nimport { CursorResponse } from '../cmap/wire_protocol/responses';\nimport { type CursorTimeoutContext, type CursorTimeoutMode } from '../cursor/abstract_cursor';\nimport type { Db } from '../db';\nimport { type Abortable } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { maxWireVersion } from '../utils';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface ListCollectionsOptions\n  extends Omit<CommandOperationOptions, 'writeConcern'>,\n    Abortable {\n  /** Since 4.0: If true, will only return the collection name in the response, and will omit additional info */\n  nameOnly?: boolean;\n  /** Since 4.0: If true and nameOnly is true, allows a user without the required privilege (i.e. listCollections action on the database) to run the command when access control is enforced. */\n  authorizedCollections?: boolean;\n  /** The batchSize for the returned command cursor or if pre 2.8 the systems batch collection */\n  batchSize?: number;\n  /** @internal */\n  timeoutMode?: CursorTimeoutMode;\n\n  /** @internal */\n  timeoutContext?: CursorTimeoutContext;\n}\n\n/** @internal */\nexport class ListCollectionsOperation extends CommandOperation<CursorResponse> {\n  /**\n   * @remarks WriteConcern can still be present on the options because\n   * we inherit options from the client/db/collection.  The\n   * key must be present on the options in order to delete it.\n   * This allows typescript to delete the key but will\n   * not allow a writeConcern to be assigned as a property on options.\n   */\n  override options: ListCollectionsOptions & { writeConcern?: never };\n  db: Db;\n  filter: Document;\n  nameOnly: boolean;\n  authorizedCollections: boolean;\n  batchSize?: number;\n\n  constructor(db: Db, filter: Document, options?: ListCollectionsOptions) {\n    super(db, options);\n\n    this.options = { ...options };\n    delete this.options.writeConcern;\n    this.db = db;\n    this.filter = filter;\n    this.nameOnly = !!this.options.nameOnly;\n    this.authorizedCollections = !!this.options.authorizedCollections;\n\n    if (typeof this.options.batchSize === 'number') {\n      this.batchSize = this.options.batchSize;\n    }\n  }\n\n  override get commandName() {\n    return 'listCollections' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<CursorResponse> {\n    return await super.executeCommand(\n      server,\n      session,\n      this.generateCommand(maxWireVersion(server)),\n      timeoutContext,\n      CursorResponse\n    );\n  }\n\n  /* This is here for the purpose of unit testing the final command that gets sent. */\n  generateCommand(wireVersion: number): Document {\n    const command: Document = {\n      listCollections: 1,\n      filter: this.filter,\n      cursor: this.batchSize ? { batchSize: this.batchSize } : {},\n      nameOnly: this.nameOnly,\n      authorizedCollections: this.authorizedCollections\n    };\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (wireVersion >= 9 && this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n\n    return command;\n  }\n}\n\n/** @public */\nexport interface CollectionInfo extends Document {\n  name: string;\n  type?: string;\n  options?: Document;\n  info?: {\n    readOnly?: false;\n    uuid?: Binary;\n  };\n  idIndex?: Document;\n}\n\ndefineAspects(ListCollectionsOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.CURSOR_CREATING\n]);\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAOA,MAAA;AACA,MAAA;AACA,MAAA;AAmBA,cAAA,GACA,MAAa,iCAAiC,UAAA,gBAAgC;IAe5E,YAAY,EAAM,EAAE,MAAgB,EAAE,OAAgC,CAAA;QACpE,KAAK,CAAC,IAAI;QAEV,IAAI,CAAC,OAAO,GAAG;YAAE,GAAG,OAAO;QAAA;QAC3B,OAAO,IAAI,CAAC,OAAO,CAAC,YAAY;QAChC,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ;QACvC,IAAI,CAAC,qBAAqB,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,qBAAqB;QAEjE,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,KAAK,UAAU;YAC9C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS;QACzC;IACF;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,OAAO,MAAM,KAAK,CAAC,eACjB,QACA,SACA,IAAI,CAAC,eAAe,CAAC,CAAA,GAAA,QAAA,cAAc,EAAC,UACpC,gBACA,YAAA,cAAc;IAElB;IAEA,kFAAA,GACA,gBAAgB,WAAmB,EAAA;QACjC,MAAM,UAAoB;YACxB,iBAAiB;YACjB,QAAQ,IAAI,CAAC,MAAM;YACnB,QAAQ,IAAI,CAAC,SAAS,GAAG;gBAAE,WAAW,IAAI,CAAC,SAAS;YAAA,IAAK,CAAA;YACzD,UAAU,IAAI,CAAC,QAAQ;YACvB,uBAAuB,IAAI,CAAC,qBAAqB;;QAGnD,iEAAiE;QACjE,gDAAgD;QAChD,IAAI,eAAe,KAAK,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,WAAW;YAC1D,QAAQ,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO;QACxC;QAEA,OAAO;IACT;;AAjEF,QAAA,wBAAA,GAAA;AAgFA,CAAA,GAAA,YAAA,aAAa,EAAC,0BAA0B;IACtC,YAAA,MAAM,CAAC,cAAc;IACrB,YAAA,MAAM,CAAC,SAAS;IAChB,YAAA,MAAM,CAAC,eAAe;CACvB"}},
    {"offset": {"line": 2050, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2054, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/run_command.ts"],"sourcesContent":["import type { BSONSerializeOptions, Document } from '../bson';\nimport { type MongoDBResponseConstructor } from '../cmap/wire_protocol/responses';\nimport { type Db } from '../db';\nimport { type TODO_NODE_3286 } from '../mongo_types';\nimport type { ReadPreferenceLike } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { MongoDBNamespace } from '../utils';\nimport { AbstractOperation } from './operation';\n\n/** @public */\nexport type RunCommandOptions = {\n  /** Specify ClientSession for this command */\n  session?: ClientSession;\n  /** The read preference */\n  readPreference?: ReadPreferenceLike;\n  /**\n   * @experimental\n   * Specifies the time an operation will run until it throws a timeout error\n   */\n  timeoutMS?: number;\n  /** @internal */\n  omitMaxTimeMS?: boolean;\n} & BSONSerializeOptions;\n\n/** @internal */\nexport class RunCommandOperation<T = Document> extends AbstractOperation<T> {\n  constructor(\n    parent: Db,\n    public command: Document,\n    public override options: RunCommandOptions & { responseType?: MongoDBResponseConstructor }\n  ) {\n    super(options);\n    this.ns = parent.s.namespace.withCollection('$cmd');\n  }\n\n  override get commandName() {\n    return 'runCommand' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<T> {\n    this.server = server;\n    const res: TODO_NODE_3286 = await server.command(\n      this.ns,\n      this.command,\n      {\n        ...this.options,\n        readPreference: this.readPreference,\n        session,\n        timeoutContext\n      },\n      this.options.responseType\n    );\n\n    return res;\n  }\n}\n\nexport class RunAdminCommandOperation<T = Document> extends AbstractOperation<T> {\n  constructor(\n    public command: Document,\n    public override options: RunCommandOptions & {\n      noResponse?: boolean;\n      bypassPinningCheck?: boolean;\n    }\n  ) {\n    super(options);\n    this.ns = new MongoDBNamespace('admin', '$cmd');\n  }\n\n  override get commandName() {\n    return 'runCommand' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<T> {\n    this.server = server;\n    const res: TODO_NODE_3286 = await server.command(this.ns, this.command, {\n      ...this.options,\n      readPreference: this.readPreference,\n      session,\n      timeoutContext\n    });\n    return res;\n  }\n}\n"],"names":[],"mappings":";;;;;AAQA,MAAA;AACA,MAAA;AAiBA,cAAA,GACA,MAAa,4BAA0C,YAAA,iBAAoB;IACzE,YACE,MAAU,EACH,OAAiB,EACR,OAA0E,CAAA;QAE1F,KAAK,CAAC;QAHC,IAAA,CAAA,OAAO,GAAP;QACS,IAAA,CAAA,OAAO,GAAP;QAGhB,IAAI,CAAC,EAAE,GAAG,OAAO,CAAC,CAAC,SAAS,CAAC,cAAc,CAAC;IAC9C;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,IAAI,CAAC,MAAM,GAAG;QACd,MAAM,MAAsB,MAAM,OAAO,OAAO,CAC9C,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,OAAO,EACZ;YACE,GAAG,IAAI,CAAC,OAAO;YACf,gBAAgB,IAAI,CAAC,cAAc;YACnC;YACA;WAEF,IAAI,CAAC,OAAO,CAAC,YAAY;QAG3B,OAAO;IACT;;AAjCF,QAAA,mBAAA,GAAA;AAoCA,MAAa,iCAA+C,YAAA,iBAAoB;IAC9E,YACS,OAAiB,EACR,OAGf,CAAA;QAED,KAAK,CAAC;QANC,IAAA,CAAA,OAAO,GAAP;QACS,IAAA,CAAA,OAAO,GAAP;QAMhB,IAAI,CAAC,EAAE,GAAG,IAAI,QAAA,gBAAgB,CAAC,SAAS;IAC1C;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,IAAI,CAAC,MAAM,GAAG;QACd,MAAM,MAAsB,MAAM,OAAO,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,EAAE;YACtE,GAAG,IAAI,CAAC,OAAO;YACf,gBAAgB,IAAI,CAAC,cAAc;YACnC;YACA;;QAEF,OAAO;IACT;;AA7BF,QAAA,wBAAA,GAAA"}},
    {"offset": {"line": 2105, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2109, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/collections.ts"],"sourcesContent":["import { Collection } from '../collection';\nimport type { Db } from '../db';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { AbstractOperation, type OperationOptions } from './operation';\n\nexport interface CollectionsOptions extends OperationOptions {\n  nameOnly?: boolean;\n}\n\n/** @internal */\nexport class CollectionsOperation extends AbstractOperation<Collection[]> {\n  override options: CollectionsOptions;\n  db: Db;\n\n  constructor(db: Db, options: CollectionsOptions) {\n    super(options);\n    this.options = options;\n    this.db = db;\n  }\n\n  override get commandName() {\n    return 'listCollections' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined\n  ): Promise<Collection[]> {\n    // Let's get the collection names\n    const documents = await this.db\n      .listCollections(\n        {},\n        { ...this.options, nameOnly: true, readPreference: this.readPreference, session }\n      )\n      .toArray();\n    const collections: Collection[] = [];\n    for (const { name } of documents) {\n      if (!name.includes('$')) {\n        // Filter collections removing any illegal ones\n        collections.push(new Collection(this.db, name, this.db.s.options));\n      }\n    }\n    // Return the collection objects\n    return collections;\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAIA,MAAA;AAMA,cAAA,GACA,MAAa,6BAA6B,YAAA,iBAA+B;IAIvE,YAAY,EAAM,EAAE,OAA2B,CAAA;QAC7C,KAAK,CAAC;QACN,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAAA;QAElC,iCAAiC;QACjC,MAAM,YAAY,MAAM,IAAI,CAAC,EAAE,CAC5B,eAAe,CACd,CAAA,GACA;YAAE,GAAG,IAAI,CAAC,OAAO;YAAE,UAAU;YAAM,gBAAgB,IAAI,CAAC,cAAc;YAAE;QAAO,GAEhF,OAAO;QACV,MAAM,cAA4B,EAAE;QACpC,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,UAAW;YAChC,IAAI,CAAC,KAAK,QAAQ,CAAC,MAAM;gBACvB,+CAA+C;gBAC/C,YAAY,IAAI,CAAC,IAAI,aAAA,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,MAAM,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO;YAClE;QACF;QACA,gCAAgC;QAChC,OAAO;IACT;;AAlCF,QAAA,oBAAA,GAAA"}},
    {"offset": {"line": 2145, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2149, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/create_collection.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport {\n  MIN_SUPPORTED_QE_SERVER_VERSION,\n  MIN_SUPPORTED_QE_WIRE_VERSION\n} from '../cmap/wire_protocol/constants';\nimport { Collection } from '../collection';\nimport type { Db } from '../db';\nimport { MongoCompatibilityError } from '../error';\nimport type { PkFactory } from '../mongo_client';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { CreateIndexesOperation } from './indexes';\nimport { Aspect, defineAspects } from './operation';\n\nconst ILLEGAL_COMMAND_FIELDS = new Set([\n  'w',\n  'wtimeout',\n  'timeoutMS',\n  'j',\n  'fsync',\n  'autoIndexId',\n  'pkFactory',\n  'raw',\n  'readPreference',\n  'session',\n  'readConcern',\n  'writeConcern',\n  'raw',\n  'fieldsAsRaw',\n  'useBigInt64',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'bsonRegExp',\n  'serializeFunctions',\n  'ignoreUndefined',\n  'enableUtf8Validation'\n]);\n\n/** @public\n * Configuration options for timeseries collections\n * @see https://www.mongodb.com/docs/manual/core/timeseries-collections/\n */\nexport interface TimeSeriesCollectionOptions extends Document {\n  timeField: string;\n  metaField?: string;\n  granularity?: 'seconds' | 'minutes' | 'hours' | string;\n  bucketMaxSpanSeconds?: number;\n  bucketRoundingSeconds?: number;\n}\n\n/** @public\n * Configuration options for clustered collections\n * @see https://www.mongodb.com/docs/manual/core/clustered-collections/\n */\nexport interface ClusteredCollectionOptions extends Document {\n  name?: string;\n  key: Document;\n  unique: boolean;\n}\n\n/** @public */\nexport interface CreateCollectionOptions extends CommandOperationOptions {\n  /** Create a capped collection */\n  capped?: boolean;\n  /** @deprecated Create an index on the _id field of the document. This option is deprecated in MongoDB 3.2+ and will be removed once no longer supported by the server. */\n  autoIndexId?: boolean;\n  /** The size of the capped collection in bytes */\n  size?: number;\n  /** The maximum number of documents in the capped collection */\n  max?: number;\n  /** Available for the MMAPv1 storage engine only to set the usePowerOf2Sizes and the noPadding flag */\n  flags?: number;\n  /** Allows users to specify configuration to the storage engine on a per-collection basis when creating a collection */\n  storageEngine?: Document;\n  /** Allows users to specify validation rules or expressions for the collection. For more information, see Document Validation */\n  validator?: Document;\n  /** Determines how strictly MongoDB applies the validation rules to existing documents during an update */\n  validationLevel?: string;\n  /** Determines whether to error on invalid documents or just warn about the violations but allow invalid documents to be inserted */\n  validationAction?: string;\n  /** Allows users to specify a default configuration for indexes when creating a collection */\n  indexOptionDefaults?: Document;\n  /** The name of the source collection or view from which to create the view. The name is not the full namespace of the collection or view (i.e., does not include the database name and implies the same database as the view to create) */\n  viewOn?: string;\n  /** An array that consists of the aggregation pipeline stage. Creates the view by applying the specified pipeline to the viewOn collection or view */\n  pipeline?: Document[];\n  /** A primary key factory function for generation of custom _id keys. */\n  pkFactory?: PkFactory;\n  /** A document specifying configuration options for timeseries collections. */\n  timeseries?: TimeSeriesCollectionOptions;\n  /** A document specifying configuration options for clustered collections. For MongoDB 5.3 and above. */\n  clusteredIndex?: ClusteredCollectionOptions;\n  /** The number of seconds after which a document in a timeseries or clustered collection expires. */\n  expireAfterSeconds?: number;\n  /** @experimental */\n  encryptedFields?: Document;\n  /**\n   * If set, enables pre-update and post-update document events to be included for any\n   * change streams that listen on this collection.\n   */\n  changeStreamPreAndPostImages?: { enabled: boolean };\n}\n\n/* @internal */\nconst INVALID_QE_VERSION =\n  'Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.';\n\n/** @internal */\nexport class CreateCollectionOperation extends CommandOperation<Collection> {\n  override options: CreateCollectionOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options: CreateCollectionOptions = {}) {\n    super(db, options);\n\n    this.options = options;\n    this.db = db;\n    this.name = name;\n  }\n\n  override get commandName() {\n    return 'create' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Collection> {\n    const db = this.db;\n    const name = this.name;\n    const options = this.options;\n\n    const encryptedFields: Document | undefined =\n      options.encryptedFields ??\n      db.client.s.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n    if (encryptedFields) {\n      // Creating a QE collection required min server of 7.0.0\n      // TODO(NODE-5353): Get wire version information from connection.\n      if (\n        !server.loadBalanced &&\n        server.description.maxWireVersion < MIN_SUPPORTED_QE_WIRE_VERSION\n      ) {\n        throw new MongoCompatibilityError(\n          `${INVALID_QE_VERSION} The minimum server version required is ${MIN_SUPPORTED_QE_SERVER_VERSION}`\n        );\n      }\n      // Create auxilliary collections for queryable encryption support.\n      const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;\n      const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;\n\n      for (const collectionName of [escCollection, ecocCollection]) {\n        const createOp = new CreateCollectionOperation(db, collectionName, {\n          clusteredIndex: {\n            key: { _id: 1 },\n            unique: true\n          }\n        });\n        await createOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);\n      }\n\n      if (!options.encryptedFields) {\n        this.options = { ...this.options, encryptedFields };\n      }\n    }\n\n    const coll = await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);\n\n    if (encryptedFields) {\n      // Create the required index for queryable encryption support.\n      const createIndexOp = CreateIndexesOperation.fromIndexSpecification(\n        db,\n        name,\n        { __safeContent__: 1 },\n        {}\n      );\n      await createIndexOp.execute(server, session, timeoutContext);\n    }\n\n    return coll;\n  }\n\n  private async executeWithoutEncryptedFieldsCheck(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Collection> {\n    const db = this.db;\n    const name = this.name;\n    const options = this.options;\n\n    const cmd: Document = { create: name };\n    for (const n in options) {\n      if (\n        (options as any)[n] != null &&\n        typeof (options as any)[n] !== 'function' &&\n        !ILLEGAL_COMMAND_FIELDS.has(n)\n      ) {\n        cmd[n] = (options as any)[n];\n      }\n    }\n    // otherwise just execute the command\n    await super.executeCommand(server, session, cmd, timeoutContext);\n    return new Collection(db, name, options);\n  }\n}\n\ndefineAspects(CreateCollectionOperation, [Aspect.WRITE_OPERATION]);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2261, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2265, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/profiling_level.ts"],"sourcesContent":["import type { Db } from '../db';\nimport { MongoUnexpectedServerResponseError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { CommandOperation, type CommandOperationOptions } from './command';\n\n/** @public */\nexport type ProfilingLevelOptions = CommandOperationOptions;\n\n/** @internal */\nexport class ProfilingLevelOperation extends CommandOperation<string> {\n  override options: ProfilingLevelOptions;\n\n  constructor(db: Db, options: ProfilingLevelOptions) {\n    super(db, options);\n    this.options = options;\n  }\n\n  override get commandName() {\n    return 'profile' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<string> {\n    const doc = await super.executeCommand(server, session, { profile: -1 }, timeoutContext);\n    if (doc.ok === 1) {\n      const was = doc.was;\n      if (was === 0) return 'off';\n      if (was === 1) return 'slow_only';\n      if (was === 2) return 'all';\n      throw new MongoUnexpectedServerResponseError(`Illegal profiling level value ${was}`);\n    } else {\n      throw new MongoUnexpectedServerResponseError('Error with profile command');\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAIA,MAAA;AAKA,cAAA,GACA,MAAa,gCAAgC,UAAA,gBAAwB;IAGnE,YAAY,EAAM,EAAE,OAA8B,CAAA;QAChD,KAAK,CAAC,IAAI;QACV,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,MAAM,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS;YAAE,SAAS,CAAC;QAAC,GAAI;QACzE,IAAI,IAAI,EAAE,KAAK,GAAG;YAChB,MAAM,MAAM,IAAI,GAAG;YACnB,IAAI,QAAQ,GAAG,OAAO;YACtB,IAAI,QAAQ,GAAG,OAAO;YACtB,IAAI,QAAQ,GAAG,OAAO;YACtB,MAAM,IAAI,QAAA,kCAAkC,CAAC,CAAA,8BAAA,EAAiC,IAAG,CAAE;QACrF,OAAO;YACL,MAAM,IAAI,QAAA,kCAAkC,CAAC;QAC/C;IACF;;AA3BF,QAAA,uBAAA,GAAA"}},
    {"offset": {"line": 2296, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2300, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/remove_user.ts"],"sourcesContent":["import type { Db } from '../db';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport type RemoveUserOptions = CommandOperationOptions;\n\n/** @internal */\nexport class RemoveUserOperation extends CommandOperation<boolean> {\n  override options: RemoveUserOptions;\n  username: string;\n\n  constructor(db: Db, username: string, options: RemoveUserOptions) {\n    super(db, options);\n    this.options = options;\n    this.username = username;\n  }\n\n  override get commandName() {\n    return 'dropUser' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<boolean> {\n    await super.executeCommand(server, session, { dropUser: this.username }, timeoutContext);\n    return true;\n  }\n}\n\ndefineAspects(RemoveUserOperation, [Aspect.WRITE_OPERATION]);\n"],"names":[],"mappings":";;;;;AAIA,MAAA;AACA,MAAA;AAKA,cAAA,GACA,MAAa,4BAA4B,UAAA,gBAAyB;IAIhE,YAAY,EAAM,EAAE,QAAgB,EAAE,OAA0B,CAAA;QAC9D,KAAK,CAAC,IAAI;QACV,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS;YAAE,UAAU,IAAI,CAAC,QAAQ;QAAA,GAAI;QACzE,OAAO;IACT;;AArBF,QAAA,mBAAA,GAAA;AAwBA,CAAA,GAAA,YAAA,aAAa,EAAC,qBAAqB;IAAC,YAAA,MAAM,CAAC,eAAe;CAAC"}},
    {"offset": {"line": 2327, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2331, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/set_profiling_level.ts"],"sourcesContent":["import type { Db } from '../db';\nimport { MongoInvalidArgumentError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { enumToString } from '../utils';\nimport { CommandOperation, type CommandOperationOptions } from './command';\n\nconst levelValues = new Set(['off', 'slow_only', 'all']);\n\n/** @public */\nexport const ProfilingLevel = Object.freeze({\n  off: 'off',\n  slowOnly: 'slow_only',\n  all: 'all'\n} as const);\n\n/** @public */\nexport type ProfilingLevel = (typeof ProfilingLevel)[keyof typeof ProfilingLevel];\n\n/** @public */\nexport type SetProfilingLevelOptions = CommandOperationOptions;\n\n/** @internal */\nexport class SetProfilingLevelOperation extends CommandOperation<ProfilingLevel> {\n  override options: SetProfilingLevelOptions;\n  level: ProfilingLevel;\n  profile: 0 | 1 | 2;\n\n  constructor(db: Db, level: ProfilingLevel, options: SetProfilingLevelOptions) {\n    super(db, options);\n    this.options = options;\n    switch (level) {\n      case ProfilingLevel.off:\n        this.profile = 0;\n        break;\n      case ProfilingLevel.slowOnly:\n        this.profile = 1;\n        break;\n      case ProfilingLevel.all:\n        this.profile = 2;\n        break;\n      default:\n        this.profile = 0;\n        break;\n    }\n\n    this.level = level;\n  }\n\n  override get commandName() {\n    return 'profile' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<ProfilingLevel> {\n    const level = this.level;\n\n    if (!levelValues.has(level)) {\n      throw new MongoInvalidArgumentError(\n        `Profiling level must be one of \"${enumToString(ProfilingLevel)}\"`\n      );\n    }\n\n    // TODO(NODE-3483): Determine error to put here\n    await super.executeCommand(server, session, { profile: this.profile }, timeoutContext);\n    return level;\n  }\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAIA,MAAA;AACA,MAAA;AAEA,MAAM,cAAc,IAAI,IAAI;IAAC;IAAO;IAAa;CAAM;AAEvD,YAAA,GACa,QAAA,cAAc,GAAG,OAAO,MAAM,CAAC;IAC1C,KAAK;IACL,UAAU;IACV,KAAK;;AASP,cAAA,GACA,MAAa,mCAAmC,UAAA,gBAAgC;IAK9E,YAAY,EAAM,EAAE,KAAqB,EAAE,OAAiC,CAAA;QAC1E,KAAK,CAAC,IAAI;QACV,IAAI,CAAC,OAAO,GAAG;QACf,OAAQ;YACN,KAAK,QAAA,cAAc,CAAC,GAAG;gBACrB,IAAI,CAAC,OAAO,GAAG;gBACf;YACF,KAAK,QAAA,cAAc,CAAC,QAAQ;gBAC1B,IAAI,CAAC,OAAO,GAAG;gBACf;YACF,KAAK,QAAA,cAAc,CAAC,GAAG;gBACrB,IAAI,CAAC,OAAO,GAAG;gBACf;YACF;gBACE,IAAI,CAAC,OAAO,GAAG;gBACf;QACJ;QAEA,IAAI,CAAC,KAAK,GAAG;IACf;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,QAAQ,IAAI,CAAC,KAAK;QAExB,IAAI,CAAC,YAAY,GAAG,CAAC,QAAQ;YAC3B,MAAM,IAAI,QAAA,yBAAyB,CACjC,CAAA,gCAAA,EAAmC,CAAA,GAAA,QAAA,YAAY,EAAC,QAAA,cAAc,EAAC,CAAA,CAAG;QAEtE;QAEA,+CAA+C;QAC/C,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS;YAAE,SAAS,IAAI,CAAC,OAAO;QAAA,GAAI;QACvE,OAAO;IACT;;AA9CF,QAAA,0BAAA,GAAA"}},
    {"offset": {"line": 2385, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2389, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/stats.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Db } from '../db';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface DbStatsOptions extends CommandOperationOptions {\n  /** Divide the returned sizes by scale value. */\n  scale?: number;\n}\n\n/** @internal */\nexport class DbStatsOperation extends CommandOperation<Document> {\n  override options: DbStatsOptions;\n\n  constructor(db: Db, options: DbStatsOptions) {\n    super(db, options);\n    this.options = options;\n  }\n\n  override get commandName() {\n    return 'dbStats' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Document> {\n    const command: Document = { dbStats: true };\n    if (this.options.scale != null) {\n      command.scale = this.options.scale;\n    }\n\n    return await super.executeCommand(server, session, command, timeoutContext);\n  }\n}\n\ndefineAspects(DbStatsOperation, [Aspect.READ_OPERATION]);\n"],"names":[],"mappings":";;;;;AAKA,MAAA;AACA,MAAA;AAQA,cAAA,GACA,MAAa,yBAAyB,UAAA,gBAA0B;IAG9D,YAAY,EAAM,EAAE,OAAuB,CAAA;QACzC,KAAK,CAAC,IAAI;QACV,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,UAAoB;YAAE,SAAS;QAAI;QACzC,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,MAAM;YAC9B,QAAQ,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK;QACpC;QAEA,OAAO,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS,SAAS;IAC9D;;AAvBF,QAAA,gBAAA,GAAA;AA0BA,CAAA,GAAA,YAAA,aAAa,EAAC,kBAAkB;IAAC,YAAA,MAAM,CAAC,cAAc;CAAC"}},
    {"offset": {"line": 2418, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2422, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/client_bulk_write/client_bulk_write.ts"],"sourcesContent":["import { MongoClientBulkWriteExecutionError, ServerType } from '../../beta';\nimport { ClientBulkWriteCursorResponse } from '../../cmap/wire_protocol/responses';\nimport type { Server } from '../../sdam/server';\nimport type { ClientSession } from '../../sessions';\nimport { type TimeoutContext } from '../../timeout';\nimport { MongoDBNamespace } from '../../utils';\nimport { CommandOperation } from '../command';\nimport { Aspect, defineAspects } from '../operation';\nimport { type ClientBulkWriteCommandBuilder } from './command_builder';\nimport { type ClientBulkWriteOptions } from './common';\n\n/**\n * Executes a single client bulk write operation within a potential batch.\n * @internal\n */\nexport class ClientBulkWriteOperation extends CommandOperation<ClientBulkWriteCursorResponse> {\n  commandBuilder: ClientBulkWriteCommandBuilder;\n  override options: ClientBulkWriteOptions;\n\n  override get commandName() {\n    return 'bulkWrite' as const;\n  }\n\n  constructor(commandBuilder: ClientBulkWriteCommandBuilder, options: ClientBulkWriteOptions) {\n    super(undefined, options);\n    this.commandBuilder = commandBuilder;\n    this.options = options;\n    this.ns = new MongoDBNamespace('admin', '$cmd');\n  }\n\n  override resetBatch(): boolean {\n    return this.commandBuilder.resetBatch();\n  }\n\n  override get canRetryWrite(): boolean {\n    return this.commandBuilder.isBatchRetryable;\n  }\n\n  /**\n   * Execute the command. Superclass will handle write concern, etc.\n   * @param server - The server.\n   * @param session - The session.\n   * @returns The response.\n   */\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<ClientBulkWriteCursorResponse> {\n    let command;\n\n    if (server.description.type === ServerType.LoadBalancer) {\n      if (session) {\n        let connection;\n        if (!session.pinnedConnection) {\n          // Checkout a connection to build the command.\n          connection = await server.pool.checkOut({ timeoutContext });\n          // Pin the connection to the session so it get used to execute the command and we do not\n          // perform a double check-in/check-out.\n          session.pin(connection);\n        } else {\n          connection = session.pinnedConnection;\n        }\n        command = this.commandBuilder.buildBatch(\n          connection.hello?.maxMessageSizeBytes,\n          connection.hello?.maxWriteBatchSize,\n          connection.hello?.maxBsonObjectSize\n        );\n      } else {\n        throw new MongoClientBulkWriteExecutionError(\n          'Session provided to the client bulk write operation must be present.'\n        );\n      }\n    } else {\n      // At this point we have a server and the auto connect code has already\n      // run in executeOperation, so the server description will be populated.\n      // We can use that to build the command.\n      if (\n        !server.description.maxWriteBatchSize ||\n        !server.description.maxMessageSizeBytes ||\n        !server.description.maxBsonObjectSize\n      ) {\n        throw new MongoClientBulkWriteExecutionError(\n          'In order to execute a client bulk write, both maxWriteBatchSize, maxMessageSizeBytes and maxBsonObjectSize must be provided by the servers hello response.'\n        );\n      }\n      command = this.commandBuilder.buildBatch(\n        server.description.maxMessageSizeBytes,\n        server.description.maxWriteBatchSize,\n        server.description.maxBsonObjectSize\n      );\n    }\n\n    // Check after the batch is built if we cannot retry it and override the option.\n    if (!this.canRetryWrite) {\n      this.options.willRetryWrite = false;\n    }\n    return await super.executeCommand(\n      server,\n      session,\n      command,\n      timeoutContext,\n      ClientBulkWriteCursorResponse\n    );\n  }\n}\n\n// Skipping the collation as it goes on the individual ops.\ndefineAspects(ClientBulkWriteOperation, [\n  Aspect.WRITE_OPERATION,\n  Aspect.SKIP_COLLATION,\n  Aspect.CURSOR_CREATING,\n  Aspect.RETRYABLE,\n  Aspect.COMMAND_BATCHING\n]);\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AAIA,MAAA;AACA,MAAA;AACA,MAAA;AAIA;;;IAIA,MAAa,iCAAiC,UAAA,gBAA+C;IAI3F,IAAa,cAAW;QACtB,OAAO;IACT;IAEA,YAAY,cAA6C,EAAE,OAA+B,CAAA;QACxF,KAAK,CAAC,WAAW;QACjB,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,EAAE,GAAG,IAAI,QAAA,gBAAgB,CAAC,SAAS;IAC1C;IAES,aAAU;QACjB,OAAO,IAAI,CAAC,cAAc,CAAC,UAAU;IACvC;IAEA,IAAa,gBAAa;QACxB,OAAO,IAAI,CAAC,cAAc,CAAC,gBAAgB;IAC7C;IAEA;;;;;QAMS,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,IAAI;QAEJ,IAAI,OAAO,WAAW,CAAC,IAAI,KAAK,OAAA,UAAU,CAAC,YAAY,EAAE;YACvD,IAAI,SAAS;gBACX,IAAI;gBACJ,IAAI,CAAC,QAAQ,gBAAgB,EAAE;oBAC7B,8CAA8C;oBAC9C,aAAa,MAAM,OAAO,IAAI,CAAC,QAAQ,CAAC;wBAAE;oBAAc;oBACxD,wFAAwF;oBACxF,uCAAuC;oBACvC,QAAQ,GAAG,CAAC;gBACd,OAAO;oBACL,aAAa,QAAQ,gBAAgB;gBACvC;gBACA,UAAU,IAAI,CAAC,cAAc,CAAC,UAAU,CACtC,WAAW,KAAK,EAAE,qBAClB,WAAW,KAAK,EAAE,mBAClB,WAAW,KAAK,EAAE;YAEtB,OAAO;gBACL,MAAM,IAAI,OAAA,kCAAkC,CAC1C;YAEJ;QACF,OAAO;YACL,uEAAuE;YACvE,wEAAwE;YACxE,wCAAwC;YACxC,IACE,CAAC,OAAO,WAAW,CAAC,iBAAiB,IACrC,CAAC,OAAO,WAAW,CAAC,mBAAmB,IACvC,CAAC,OAAO,WAAW,CAAC,iBAAiB,EACrC;gBACA,MAAM,IAAI,OAAA,kCAAkC,CAC1C;YAEJ;YACA,UAAU,IAAI,CAAC,cAAc,CAAC,UAAU,CACtC,OAAO,WAAW,CAAC,mBAAmB,EACtC,OAAO,WAAW,CAAC,iBAAiB,EACpC,OAAO,WAAW,CAAC,iBAAiB;QAExC;QAEA,gFAAgF;QAChF,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,IAAI,CAAC,OAAO,CAAC,cAAc,GAAG;QAChC;QACA,OAAO,MAAM,KAAK,CAAC,eACjB,QACA,SACA,SACA,gBACA,YAAA,6BAA6B;IAEjC;;AAzFF,QAAA,wBAAA,GAAA;AA4FA,2DAA2D;AAC3D,CAAA,GAAA,YAAA,aAAa,EAAC,0BAA0B;IACtC,YAAA,MAAM,CAAC,eAAe;IACtB,YAAA,MAAM,CAAC,cAAc;IACrB,YAAA,MAAM,CAAC,eAAe;IACtB,YAAA,MAAM,CAAC,SAAS;IAChB,YAAA,MAAM,CAAC,gBAAgB;CACxB"}},
    {"offset": {"line": 2501, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2505, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/client_bulk_write/command_builder.ts"],"sourcesContent":["import { BSON, type BSONSerializeOptions, type Document } from '../../bson';\nimport { DocumentSequence } from '../../cmap/commands';\nimport { MongoAPIError, MongoInvalidArgumentError } from '../../error';\nimport { type PkFactory } from '../../mongo_client';\nimport type { Filter, OptionalId, UpdateFilter, WithoutId } from '../../mongo_types';\nimport { formatSort, type SortForCmd } from '../../sort';\nimport { DEFAULT_PK_FACTORY, hasAtomicOperators } from '../../utils';\nimport { type CollationOptions } from '../command';\nimport { type Hint } from '../operation';\nimport type {\n  AnyClientBulkWriteModel,\n  ClientBulkWriteOptions,\n  ClientDeleteManyModel,\n  ClientDeleteOneModel,\n  ClientInsertOneModel,\n  ClientReplaceOneModel,\n  ClientUpdateManyModel,\n  ClientUpdateOneModel\n} from './common';\n\n/** @internal */\nexport interface ClientBulkWriteCommand {\n  bulkWrite: 1;\n  errorsOnly: boolean;\n  ordered: boolean;\n  ops: DocumentSequence;\n  nsInfo: DocumentSequence;\n  bypassDocumentValidation?: boolean;\n  let?: Document;\n  comment?: any;\n}\n\n/**\n * The bytes overhead for the extra fields added post command generation.\n */\nconst MESSAGE_OVERHEAD_BYTES = 1000;\n\n/** @internal */\nexport class ClientBulkWriteCommandBuilder {\n  models: ReadonlyArray<AnyClientBulkWriteModel<Document>>;\n  options: ClientBulkWriteOptions;\n  pkFactory: PkFactory;\n  /** The current index in the models array that is being processed. */\n  currentModelIndex: number;\n  /** The model index that the builder was on when it finished the previous batch. Used for resets when retrying. */\n  previousModelIndex: number;\n  /** The last array of operations that were created. Used by the results merger for indexing results. */\n  lastOperations: Document[];\n  /** Returns true if the current batch being created has no multi-updates. */\n  isBatchRetryable: boolean;\n\n  /**\n   * Create the command builder.\n   * @param models - The client write models.\n   */\n  constructor(\n    models: ReadonlyArray<AnyClientBulkWriteModel<Document>>,\n    options: ClientBulkWriteOptions,\n    pkFactory?: PkFactory\n  ) {\n    this.models = models;\n    this.options = options;\n    this.pkFactory = pkFactory ?? DEFAULT_PK_FACTORY;\n    this.currentModelIndex = 0;\n    this.previousModelIndex = 0;\n    this.lastOperations = [];\n    this.isBatchRetryable = true;\n  }\n\n  /**\n   * Gets the errorsOnly value for the command, which is the inverse of the\n   * user provided verboseResults option. Defaults to true.\n   */\n  get errorsOnly(): boolean {\n    if ('verboseResults' in this.options) {\n      return !this.options.verboseResults;\n    }\n    return true;\n  }\n\n  /**\n   * Determines if there is another batch to process.\n   * @returns True if not all batches have been built.\n   */\n  hasNextBatch(): boolean {\n    return this.currentModelIndex < this.models.length;\n  }\n\n  /**\n   * When we need to retry a command we need to set the current\n   * model index back to its previous value.\n   */\n  resetBatch(): boolean {\n    this.currentModelIndex = this.previousModelIndex;\n    return true;\n  }\n\n  /**\n   * Build a single batch of a client bulk write command.\n   * @param maxMessageSizeBytes - The max message size in bytes.\n   * @param maxWriteBatchSize - The max write batch size.\n   * @returns The client bulk write command.\n   */\n  buildBatch(\n    maxMessageSizeBytes: number,\n    maxWriteBatchSize: number,\n    maxBsonObjectSize: number\n  ): ClientBulkWriteCommand {\n    // We start by assuming the batch has no multi-updates, so it is retryable\n    // until we find them.\n    this.isBatchRetryable = true;\n    let commandLength = 0;\n    let currentNamespaceIndex = 0;\n    const command: ClientBulkWriteCommand = this.baseCommand();\n    const namespaces = new Map<string, number>();\n    // In the case of retries we need to mark where we started this batch.\n    this.previousModelIndex = this.currentModelIndex;\n\n    while (this.currentModelIndex < this.models.length) {\n      const model = this.models[this.currentModelIndex];\n      const ns = model.namespace;\n      const nsIndex = namespaces.get(ns);\n\n      // Multi updates are not retryable.\n      if (model.name === 'deleteMany' || model.name === 'updateMany') {\n        this.isBatchRetryable = false;\n      }\n\n      if (nsIndex != null) {\n        // Build the operation and serialize it to get the bytes buffer.\n        const operation = buildOperation(model, nsIndex, this.pkFactory, this.options);\n        let operationBuffer;\n        try {\n          operationBuffer = BSON.serialize(operation);\n        } catch (cause) {\n          throw new MongoInvalidArgumentError(`Could not serialize operation to BSON`, { cause });\n        }\n\n        validateBufferSize('ops', operationBuffer, maxBsonObjectSize);\n\n        // Check if the operation buffer can fit in the command. If it can,\n        // then add the operation to the document sequence and increment the\n        // current length as long as the ops don't exceed the maxWriteBatchSize.\n        if (\n          commandLength + operationBuffer.length < maxMessageSizeBytes &&\n          command.ops.documents.length < maxWriteBatchSize\n        ) {\n          // Pushing to the ops document sequence returns the total byte length of the document sequence.\n          commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);\n          // Increment the builder's current model index.\n          this.currentModelIndex++;\n        } else {\n          // The operation cannot fit in the current command and will need to\n          // go in the next batch. Exit the loop.\n          break;\n        }\n      } else {\n        // The namespace is not already in the nsInfo so we will set it in the map, and\n        // construct our nsInfo and ops documents and buffers.\n        namespaces.set(ns, currentNamespaceIndex);\n        const nsInfo = { ns: ns };\n        const operation = buildOperation(\n          model,\n          currentNamespaceIndex,\n          this.pkFactory,\n          this.options\n        );\n        let nsInfoBuffer;\n        let operationBuffer;\n        try {\n          nsInfoBuffer = BSON.serialize(nsInfo);\n          operationBuffer = BSON.serialize(operation);\n        } catch (cause) {\n          throw new MongoInvalidArgumentError(`Could not serialize ns info to BSON`, { cause });\n        }\n\n        validateBufferSize('nsInfo', nsInfoBuffer, maxBsonObjectSize);\n        validateBufferSize('ops', operationBuffer, maxBsonObjectSize);\n\n        // Check if the operation and nsInfo buffers can fit in the command. If they\n        // can, then add the operation and nsInfo to their respective document\n        // sequences and increment the current length as long as the ops don't exceed\n        // the maxWriteBatchSize.\n        if (\n          commandLength + nsInfoBuffer.length + operationBuffer.length < maxMessageSizeBytes &&\n          command.ops.documents.length < maxWriteBatchSize\n        ) {\n          // Pushing to the ops document sequence returns the total byte length of the document sequence.\n          commandLength =\n            MESSAGE_OVERHEAD_BYTES +\n            command.nsInfo.push(nsInfo, nsInfoBuffer) +\n            command.ops.push(operation, operationBuffer);\n          // We've added a new namespace, increment the namespace index.\n          currentNamespaceIndex++;\n          // Increment the builder's current model index.\n          this.currentModelIndex++;\n        } else {\n          // The operation cannot fit in the current command and will need to\n          // go in the next batch. Exit the loop.\n          break;\n        }\n      }\n    }\n    // Set the last operations and return the command.\n    this.lastOperations = command.ops.documents;\n    return command;\n  }\n\n  private baseCommand(): ClientBulkWriteCommand {\n    const command: ClientBulkWriteCommand = {\n      bulkWrite: 1,\n      errorsOnly: this.errorsOnly,\n      ordered: this.options.ordered ?? true,\n      ops: new DocumentSequence('ops'),\n      nsInfo: new DocumentSequence('nsInfo')\n    };\n    // Add bypassDocumentValidation if it was present in the options.\n    if (this.options.bypassDocumentValidation != null) {\n      command.bypassDocumentValidation = this.options.bypassDocumentValidation;\n    }\n    // Add let if it was present in the options.\n    if (this.options.let) {\n      command.let = this.options.let;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n\n    return command;\n  }\n}\n\nfunction validateBufferSize(name: string, buffer: Uint8Array, maxBsonObjectSize: number) {\n  if (buffer.length > maxBsonObjectSize) {\n    throw new MongoInvalidArgumentError(\n      `Client bulk write operation ${name} of length ${buffer.length} exceeds the max bson object size of ${maxBsonObjectSize}`\n    );\n  }\n}\n\n/** @internal */\ninterface ClientInsertOperation {\n  insert: number;\n  document: OptionalId<Document>;\n}\n\n/**\n * Build the insert one operation.\n * @param model - The insert one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildInsertOneOperation = (\n  model: ClientInsertOneModel<Document>,\n  index: number,\n  pkFactory: PkFactory\n): ClientInsertOperation => {\n  const document: ClientInsertOperation = {\n    insert: index,\n    document: model.document\n  };\n  document.document._id = model.document._id ?? pkFactory.createPk();\n  return document;\n};\n\n/** @internal */\nexport interface ClientDeleteOperation {\n  delete: number;\n  multi: boolean;\n  filter: Filter<Document>;\n  hint?: Hint;\n  collation?: CollationOptions;\n}\n\n/**\n * Build the delete one operation.\n * @param model - The insert many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildDeleteOneOperation = (\n  model: ClientDeleteOneModel<Document>,\n  index: number\n): Document => {\n  return createDeleteOperation(model, index, false);\n};\n\n/**\n * Build the delete many operation.\n * @param model - The delete many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildDeleteManyOperation = (\n  model: ClientDeleteManyModel<Document>,\n  index: number\n): Document => {\n  return createDeleteOperation(model, index, true);\n};\n\n/**\n * Creates a delete operation based on the parameters.\n */\nfunction createDeleteOperation(\n  model: ClientDeleteOneModel<Document> | ClientDeleteManyModel<Document>,\n  index: number,\n  multi: boolean\n): ClientDeleteOperation {\n  const document: ClientDeleteOperation = {\n    delete: index,\n    multi: multi,\n    filter: model.filter\n  };\n  if (model.hint) {\n    document.hint = model.hint;\n  }\n  if (model.collation) {\n    document.collation = model.collation;\n  }\n  return document;\n}\n\n/** @internal */\nexport interface ClientUpdateOperation {\n  update: number;\n  multi: boolean;\n  filter: Filter<Document>;\n  updateMods: UpdateFilter<Document> | Document[];\n  hint?: Hint;\n  upsert?: boolean;\n  arrayFilters?: Document[];\n  collation?: CollationOptions;\n  sort?: SortForCmd;\n}\n\n/**\n * Build the update one operation.\n * @param model - The update one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildUpdateOneOperation = (\n  model: ClientUpdateOneModel<Document>,\n  index: number,\n  options: BSONSerializeOptions\n): ClientUpdateOperation => {\n  return createUpdateOperation(model, index, false, options);\n};\n\n/**\n * Build the update many operation.\n * @param model - The update many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildUpdateManyOperation = (\n  model: ClientUpdateManyModel<Document>,\n  index: number,\n  options: BSONSerializeOptions\n): ClientUpdateOperation => {\n  return createUpdateOperation(model, index, true, options);\n};\n\n/**\n * Validate the update document.\n * @param update - The update document.\n */\nfunction validateUpdate(update: Document, options: BSONSerializeOptions) {\n  if (!hasAtomicOperators(update, options)) {\n    throw new MongoAPIError(\n      'Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.'\n    );\n  }\n}\n\n/**\n * Creates a delete operation based on the parameters.\n */\nfunction createUpdateOperation(\n  model: ClientUpdateOneModel<Document> | ClientUpdateManyModel<Document>,\n  index: number,\n  multi: boolean,\n  options: BSONSerializeOptions\n): ClientUpdateOperation {\n  // Update documents provided in UpdateOne and UpdateMany write models are\n  // required only to contain atomic modifiers (i.e. keys that start with \"$\").\n  // Drivers MUST throw an error if an update document is empty or if the\n  // document's first key does not start with \"$\".\n  validateUpdate(model.update, options);\n  const document: ClientUpdateOperation = {\n    update: index,\n    multi: multi,\n    filter: model.filter,\n    updateMods: model.update\n  };\n  if (model.hint) {\n    document.hint = model.hint;\n  }\n  if (model.upsert) {\n    document.upsert = model.upsert;\n  }\n  if (model.arrayFilters) {\n    document.arrayFilters = model.arrayFilters;\n  }\n  if (model.collation) {\n    document.collation = model.collation;\n  }\n  if (!multi && 'sort' in model && model.sort != null) {\n    document.sort = formatSort(model.sort);\n  }\n  return document;\n}\n\n/** @internal */\nexport interface ClientReplaceOneOperation {\n  update: number;\n  multi: boolean;\n  filter: Filter<Document>;\n  updateMods: WithoutId<Document>;\n  hint?: Hint;\n  upsert?: boolean;\n  collation?: CollationOptions;\n  sort?: SortForCmd;\n}\n\n/**\n * Build the replace one operation.\n * @param model - The replace one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildReplaceOneOperation = (\n  model: ClientReplaceOneModel<Document>,\n  index: number\n): ClientReplaceOneOperation => {\n  if (hasAtomicOperators(model.replacement)) {\n    throw new MongoAPIError(\n      'Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.'\n    );\n  }\n\n  const document: ClientReplaceOneOperation = {\n    update: index,\n    multi: false,\n    filter: model.filter,\n    updateMods: model.replacement\n  };\n  if (model.hint) {\n    document.hint = model.hint;\n  }\n  if (model.upsert) {\n    document.upsert = model.upsert;\n  }\n  if (model.collation) {\n    document.collation = model.collation;\n  }\n  if (model.sort != null) {\n    document.sort = formatSort(model.sort);\n  }\n  return document;\n};\n\n/** @internal */\nexport function buildOperation(\n  model: AnyClientBulkWriteModel<Document>,\n  index: number,\n  pkFactory: PkFactory,\n  options: BSONSerializeOptions\n): Document {\n  switch (model.name) {\n    case 'insertOne':\n      return buildInsertOneOperation(model, index, pkFactory);\n    case 'deleteOne':\n      return buildDeleteOneOperation(model, index);\n    case 'deleteMany':\n      return buildDeleteManyOperation(model, index);\n    case 'updateOne':\n      return buildUpdateOneOperation(model, index, options);\n    case 'updateMany':\n      return buildUpdateManyOperation(model, index, options);\n    case 'replaceOne':\n      return buildReplaceOneOperation(model, index);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2821, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2825, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/client_bulk_write/results_merger.ts"],"sourcesContent":["import { MongoWriteConcernError } from '../..';\nimport { type Document } from '../../bson';\nimport { type ClientBulkWriteCursor } from '../../cursor/client_bulk_write_cursor';\nimport { MongoClientBulkWriteError } from '../../error';\nimport {\n  type ClientBulkWriteError,\n  type ClientBulkWriteOptions,\n  type ClientBulkWriteResult,\n  type ClientDeleteResult,\n  type ClientInsertOneResult,\n  type ClientUpdateResult\n} from './common';\n\n/**\n * Unacknowledged bulk writes are always the same.\n */\nconst UNACKNOWLEDGED = {\n  acknowledged: false,\n  insertedCount: 0,\n  upsertedCount: 0,\n  matchedCount: 0,\n  modifiedCount: 0,\n  deletedCount: 0,\n  insertResults: undefined,\n  updateResults: undefined,\n  deleteResults: undefined\n};\n\ninterface ClientBulkWriteResultAccumulation {\n  /**\n   * Whether the bulk write was acknowledged.\n   */\n  acknowledged: boolean;\n  /**\n   * The total number of documents inserted across all insert operations.\n   */\n  insertedCount: number;\n  /**\n   * The total number of documents upserted across all update operations.\n   */\n  upsertedCount: number;\n  /**\n   * The total number of documents matched across all update operations.\n   */\n  matchedCount: number;\n  /**\n   * The total number of documents modified across all update operations.\n   */\n  modifiedCount: number;\n  /**\n   * The total number of documents deleted across all delete operations.\n   */\n  deletedCount: number;\n  /**\n   * The results of each individual insert operation that was successfully performed.\n   */\n  insertResults?: Map<number, ClientInsertOneResult>;\n  /**\n   * The results of each individual update operation that was successfully performed.\n   */\n  updateResults?: Map<number, ClientUpdateResult>;\n  /**\n   * The results of each individual delete operation that was successfully performed.\n   */\n  deleteResults?: Map<number, ClientDeleteResult>;\n}\n\n/**\n * Merges client bulk write cursor responses together into a single result.\n * @internal\n */\nexport class ClientBulkWriteResultsMerger {\n  private result: ClientBulkWriteResultAccumulation;\n  private options: ClientBulkWriteOptions;\n  private currentBatchOffset: number;\n  writeConcernErrors: Document[];\n  writeErrors: Map<number, ClientBulkWriteError>;\n\n  /**\n   * @returns The standard unacknowledged bulk write result.\n   */\n  static unacknowledged(): ClientBulkWriteResult {\n    return UNACKNOWLEDGED;\n  }\n\n  /**\n   * Instantiate the merger.\n   * @param options - The options.\n   */\n  constructor(options: ClientBulkWriteOptions) {\n    this.options = options;\n    this.currentBatchOffset = 0;\n    this.writeConcernErrors = [];\n    this.writeErrors = new Map();\n    this.result = {\n      acknowledged: true,\n      insertedCount: 0,\n      upsertedCount: 0,\n      matchedCount: 0,\n      modifiedCount: 0,\n      deletedCount: 0,\n      insertResults: undefined,\n      updateResults: undefined,\n      deleteResults: undefined\n    };\n\n    if (options.verboseResults) {\n      this.result.insertResults = new Map<number, ClientInsertOneResult>();\n      this.result.updateResults = new Map<number, ClientUpdateResult>();\n      this.result.deleteResults = new Map<number, ClientDeleteResult>();\n    }\n  }\n\n  /**\n   * Get the bulk write result object.\n   */\n  get bulkWriteResult(): ClientBulkWriteResult {\n    return {\n      acknowledged: this.result.acknowledged,\n      insertedCount: this.result.insertedCount,\n      upsertedCount: this.result.upsertedCount,\n      matchedCount: this.result.matchedCount,\n      modifiedCount: this.result.modifiedCount,\n      deletedCount: this.result.deletedCount,\n      insertResults: this.result.insertResults,\n      updateResults: this.result.updateResults,\n      deleteResults: this.result.deleteResults\n    };\n  }\n\n  /**\n   * Merge the results in the cursor to the existing result.\n   * @param currentBatchOffset - The offset index to the original models.\n   * @param response - The cursor response.\n   * @param documents - The documents in the cursor.\n   * @returns The current result.\n   */\n  async merge(cursor: ClientBulkWriteCursor): Promise<ClientBulkWriteResult> {\n    let writeConcernErrorResult;\n    try {\n      for await (const document of cursor) {\n        // Only add to maps if ok: 1\n        if (document.ok === 1) {\n          if (this.options.verboseResults) {\n            this.processDocument(cursor, document);\n          }\n        } else {\n          // If an individual write error is encountered during an ordered bulk write, drivers MUST\n          // record the error in writeErrors and immediately throw the exception. Otherwise, drivers\n          // MUST continue to iterate the results cursor and execute any further bulkWrite batches.\n          if (this.options.ordered) {\n            const error = new MongoClientBulkWriteError({\n              message: 'Mongo client ordered bulk write encountered a write error.'\n            });\n            error.writeErrors.set(document.idx + this.currentBatchOffset, {\n              code: document.code,\n              message: document.errmsg\n            });\n            error.partialResult = this.result;\n            throw error;\n          } else {\n            this.writeErrors.set(document.idx + this.currentBatchOffset, {\n              code: document.code,\n              message: document.errmsg\n            });\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof MongoWriteConcernError) {\n        const result = error.result;\n        writeConcernErrorResult = {\n          insertedCount: result.nInserted,\n          upsertedCount: result.nUpserted,\n          matchedCount: result.nMatched,\n          modifiedCount: result.nModified,\n          deletedCount: result.nDeleted,\n          writeConcernError: result.writeConcernError\n        };\n        if (this.options.verboseResults && result.cursor.firstBatch) {\n          for (const document of result.cursor.firstBatch) {\n            if (document.ok === 1) {\n              this.processDocument(cursor, document);\n            }\n          }\n        }\n      } else {\n        throw error;\n      }\n    } finally {\n      // Update the counts from the cursor response.\n      if (cursor.response) {\n        const response = cursor.response;\n        this.incrementCounts(response);\n      }\n\n      // Increment the batch offset.\n      this.currentBatchOffset += cursor.operations.length;\n    }\n\n    // If we have write concern errors ensure they are added.\n    if (writeConcernErrorResult) {\n      const writeConcernError = writeConcernErrorResult.writeConcernError as Document;\n      this.incrementCounts(writeConcernErrorResult);\n      this.writeConcernErrors.push({\n        code: writeConcernError.code,\n        message: writeConcernError.errmsg\n      });\n    }\n\n    return this.result;\n  }\n\n  /**\n   * Process an individual document in the results.\n   * @param cursor - The cursor.\n   * @param document - The document to process.\n   */\n  private processDocument(cursor: ClientBulkWriteCursor, document: Document) {\n    // Get the corresponding operation from the command.\n    const operation = cursor.operations[document.idx];\n    // Handle insert results.\n    if ('insert' in operation) {\n      this.result.insertResults?.set(document.idx + this.currentBatchOffset, {\n        insertedId: operation.document._id\n      });\n    }\n    // Handle update results.\n    if ('update' in operation) {\n      const result: ClientUpdateResult = {\n        matchedCount: document.n,\n        modifiedCount: document.nModified ?? 0,\n        // Check if the bulk did actually upsert.\n        didUpsert: document.upserted != null\n      };\n      if (document.upserted) {\n        result.upsertedId = document.upserted._id;\n      }\n      this.result.updateResults?.set(document.idx + this.currentBatchOffset, result);\n    }\n    // Handle delete results.\n    if ('delete' in operation) {\n      this.result.deleteResults?.set(document.idx + this.currentBatchOffset, {\n        deletedCount: document.n\n      });\n    }\n  }\n\n  /**\n   * Increment the result counts.\n   * @param document - The document with the results.\n   */\n  private incrementCounts(document: Document) {\n    this.result.insertedCount += document.insertedCount;\n    this.result.upsertedCount += document.upsertedCount;\n    this.result.matchedCount += document.matchedCount;\n    this.result.modifiedCount += document.modifiedCount;\n    this.result.deletedCount += document.deletedCount;\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAGA,MAAA;AAUA;;IAGA,MAAM,iBAAiB;IACrB,cAAc;IACd,eAAe;IACf,eAAe;IACf,cAAc;IACd,eAAe;IACf,cAAc;IACd,eAAe;IACf,eAAe;IACf,eAAe;;AA0CjB;;;IAIA,MAAa;IAOX;;QAGA,OAAO,iBAAc;QACnB,OAAO;IACT;IAEA;;;QAIA,YAAY,OAA+B,CAAA;QACzC,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,kBAAkB,GAAG,EAAE;QAC5B,IAAI,CAAC,WAAW,GAAG,IAAI;QACvB,IAAI,CAAC,MAAM,GAAG;YACZ,cAAc;YACd,eAAe;YACf,eAAe;YACf,cAAc;YACd,eAAe;YACf,cAAc;YACd,eAAe;YACf,eAAe;YACf,eAAe;;QAGjB,IAAI,QAAQ,cAAc,EAAE;YAC1B,IAAI,CAAC,MAAM,CAAC,aAAa,GAAG,IAAI;YAChC,IAAI,CAAC,MAAM,CAAC,aAAa,GAAG,IAAI;YAChC,IAAI,CAAC,MAAM,CAAC,aAAa,GAAG,IAAI;QAClC;IACF;IAEA;;QAGA,IAAI,kBAAe;QACjB,OAAO;YACL,cAAc,IAAI,CAAC,MAAM,CAAC,YAAY;YACtC,eAAe,IAAI,CAAC,MAAM,CAAC,aAAa;YACxC,eAAe,IAAI,CAAC,MAAM,CAAC,aAAa;YACxC,cAAc,IAAI,CAAC,MAAM,CAAC,YAAY;YACtC,eAAe,IAAI,CAAC,MAAM,CAAC,aAAa;YACxC,cAAc,IAAI,CAAC,MAAM,CAAC,YAAY;YACtC,eAAe,IAAI,CAAC,MAAM,CAAC,aAAa;YACxC,eAAe,IAAI,CAAC,MAAM,CAAC,aAAa;YACxC,eAAe,IAAI,CAAC,MAAM,CAAC,aAAa;;IAE5C;IAEA;;;;;;QAOA,MAAM,MAAM,MAA6B,EAAA;QACvC,IAAI;QACJ,IAAI;YACF,WAAW,MAAM,YAAY,OAAQ;gBACnC,4BAA4B;gBAC5B,IAAI,SAAS,EAAE,KAAK,GAAG;oBACrB,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;wBAC/B,IAAI,CAAC,eAAe,CAAC,QAAQ;oBAC/B;gBACF,OAAO;oBACL,yFAAyF;oBACzF,0FAA0F;oBAC1F,yFAAyF;oBACzF,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;wBACxB,MAAM,QAAQ,IAAI,QAAA,yBAAyB,CAAC;4BAC1C,SAAS;;wBAEX,MAAM,WAAW,CAAC,GAAG,CAAC,SAAS,GAAG,GAAG,IAAI,CAAC,kBAAkB,EAAE;4BAC5D,MAAM,SAAS,IAAI;4BACnB,SAAS,SAAS,MAAM;;wBAE1B,MAAM,aAAa,GAAG,IAAI,CAAC,MAAM;wBACjC,MAAM;oBACR,OAAO;wBACL,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,SAAS,GAAG,GAAG,IAAI,CAAC,kBAAkB,EAAE;4BAC3D,MAAM,SAAS,IAAI;4BACnB,SAAS,SAAS,MAAM;;oBAE5B;gBACF;YACF;QACF,EAAE,OAAO,OAAO;YACd,IAAI,iBAAiB,IAAA,sBAAsB,EAAE;gBAC3C,MAAM,SAAS,MAAM,MAAM;gBAC3B,0BAA0B;oBACxB,eAAe,OAAO,SAAS;oBAC/B,eAAe,OAAO,SAAS;oBAC/B,cAAc,OAAO,QAAQ;oBAC7B,eAAe,OAAO,SAAS;oBAC/B,cAAc,OAAO,QAAQ;oBAC7B,mBAAmB,OAAO,iBAAiB;;gBAE7C,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,IAAI,OAAO,MAAM,CAAC,UAAU,EAAE;oBAC3D,KAAK,MAAM,YAAY,OAAO,MAAM,CAAC,UAAU,CAAE;wBAC/C,IAAI,SAAS,EAAE,KAAK,GAAG;4BACrB,IAAI,CAAC,eAAe,CAAC,QAAQ;wBAC/B;oBACF;gBACF;YACF,OAAO;gBACL,MAAM;YACR;QACF,SAAU;YACR,8CAA8C;YAC9C,IAAI,OAAO,QAAQ,EAAE;gBACnB,MAAM,WAAW,OAAO,QAAQ;gBAChC,IAAI,CAAC,eAAe,CAAC;YACvB;YAEA,8BAA8B;YAC9B,IAAI,CAAC,kBAAkB,IAAI,OAAO,UAAU,CAAC,MAAM;QACrD;QAEA,yDAAyD;QACzD,IAAI,yBAAyB;YAC3B,MAAM,oBAAoB,wBAAwB,iBAA6B;YAC/E,IAAI,CAAC,eAAe,CAAC;YACrB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;gBAC3B,MAAM,kBAAkB,IAAI;gBAC5B,SAAS,kBAAkB,MAAM;;QAErC;QAEA,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA;;;;QAKQ,gBAAgB,MAA6B,EAAE,QAAkB,EAAA;QACvE,oDAAoD;QACpD,MAAM,YAAY,OAAO,UAAU,CAAC,SAAS,GAAG,CAAC;QACjD,yBAAyB;QACzB,IAAI,YAAY,WAAW;YACzB,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,IAAI,SAAS,GAAG,GAAG,IAAI,CAAC,kBAAkB,EAAE;gBACrE,YAAY,UAAU,QAAQ,CAAC,GAAG;;QAEtC;QACA,yBAAyB;QACzB,IAAI,YAAY,WAAW;YACzB,MAAM,SAA6B;gBACjC,cAAc,SAAS,CAAC;gBACxB,eAAe,SAAS,SAAS,IAAI;gBACrC,yCAAyC;gBACzC,WAAW,SAAS,QAAQ,IAAI;;YAElC,IAAI,SAAS,QAAQ,EAAE;gBACrB,OAAO,UAAU,GAAG,SAAS,QAAQ,CAAC,GAAG;YAC3C;YACA,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,IAAI,SAAS,GAAG,GAAG,IAAI,CAAC,kBAAkB,EAAE;QACzE;QACA,yBAAyB;QACzB,IAAI,YAAY,WAAW;YACzB,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,IAAI,SAAS,GAAG,GAAG,IAAI,CAAC,kBAAkB,EAAE;gBACrE,cAAc,SAAS,CAAC;;QAE5B;IACF;IAEA;;;QAIQ,gBAAgB,QAAkB,EAAA;QACxC,IAAI,CAAC,MAAM,CAAC,aAAa,IAAI,SAAS,aAAa;QACnD,IAAI,CAAC,MAAM,CAAC,aAAa,IAAI,SAAS,aAAa;QACnD,IAAI,CAAC,MAAM,CAAC,YAAY,IAAI,SAAS,YAAY;QACjD,IAAI,CAAC,MAAM,CAAC,aAAa,IAAI,SAAS,aAAa;QACnD,IAAI,CAAC,MAAM,CAAC,YAAY,IAAI,SAAS,YAAY;IACnD;;AA3LF,QAAA,4BAAA,GAAA"}},
    {"offset": {"line": 3017, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3021, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/client_bulk_write/executor.ts"],"sourcesContent":["import { type Document } from '../../bson';\nimport { CursorTimeoutContext, CursorTimeoutMode } from '../../cursor/abstract_cursor';\nimport { ClientBulkWriteCursor } from '../../cursor/client_bulk_write_cursor';\nimport {\n  MongoClientBulkWriteError,\n  MongoClientBulkWriteExecutionError,\n  MongoInvalidArgumentError,\n  MongoServerError\n} from '../../error';\nimport { type MongoClient } from '../../mongo_client';\nimport { TimeoutContext } from '../../timeout';\nimport { resolveTimeoutOptions } from '../../utils';\nimport { WriteConcern } from '../../write_concern';\nimport { executeOperation } from '../execute_operation';\nimport { ClientBulkWriteOperation } from './client_bulk_write';\nimport { ClientBulkWriteCommandBuilder } from './command_builder';\nimport {\n  type AnyClientBulkWriteModel,\n  type ClientBulkWriteOptions,\n  type ClientBulkWriteResult\n} from './common';\nimport { ClientBulkWriteResultsMerger } from './results_merger';\n\n/**\n * Responsible for executing a client bulk write.\n * @internal\n */\nexport class ClientBulkWriteExecutor {\n  private readonly client: MongoClient;\n  private readonly options: ClientBulkWriteOptions;\n  private readonly operations: ReadonlyArray<AnyClientBulkWriteModel<Document>>;\n\n  /**\n   * Instantiate the executor.\n   * @param client - The mongo client.\n   * @param operations - The user supplied bulk write models.\n   * @param options - The bulk write options.\n   */\n  constructor(\n    client: MongoClient,\n    operations: ReadonlyArray<AnyClientBulkWriteModel<Document>>,\n    options?: ClientBulkWriteOptions\n  ) {\n    if (operations.length === 0) {\n      throw new MongoClientBulkWriteExecutionError('No client bulk write models were provided.');\n    }\n\n    this.client = client;\n    this.operations = operations;\n    this.options = {\n      ordered: true,\n      bypassDocumentValidation: false,\n      verboseResults: false,\n      ...options\n    };\n\n    // If no write concern was provided, we inherit one from the client.\n    if (!this.options.writeConcern) {\n      this.options.writeConcern = WriteConcern.fromOptions(this.client.s.options);\n    }\n\n    if (this.options.writeConcern?.w === 0) {\n      if (this.options.verboseResults) {\n        throw new MongoInvalidArgumentError(\n          'Cannot request unacknowledged write concern and verbose results'\n        );\n      }\n\n      if (this.options.ordered) {\n        throw new MongoInvalidArgumentError(\n          'Cannot request unacknowledged write concern and ordered writes'\n        );\n      }\n    }\n  }\n\n  /**\n   * Execute the client bulk write. Will split commands into batches and exhaust the cursors\n   * for each, then merge the results into one.\n   * @returns The result.\n   */\n  async execute(): Promise<ClientBulkWriteResult> {\n    // The command builder will take the user provided models and potential split the batch\n    // into multiple commands due to size.\n    const pkFactory = this.client.s.options.pkFactory;\n    const commandBuilder = new ClientBulkWriteCommandBuilder(\n      this.operations,\n      this.options,\n      pkFactory\n    );\n    // Unacknowledged writes need to execute all batches and return { ok: 1}\n    const resolvedOptions = resolveTimeoutOptions(this.client, this.options);\n    const context = TimeoutContext.create(resolvedOptions);\n\n    if (this.options.writeConcern?.w === 0) {\n      while (commandBuilder.hasNextBatch()) {\n        const operation = new ClientBulkWriteOperation(commandBuilder, this.options);\n        await executeOperation(this.client, operation, context);\n      }\n      return ClientBulkWriteResultsMerger.unacknowledged();\n    } else {\n      const resultsMerger = new ClientBulkWriteResultsMerger(this.options);\n      // For each command will will create and exhaust a cursor for the results.\n      while (commandBuilder.hasNextBatch()) {\n        const cursorContext = new CursorTimeoutContext(context, Symbol());\n        const options = {\n          ...this.options,\n          timeoutContext: cursorContext,\n          ...(resolvedOptions.timeoutMS != null && { timeoutMode: CursorTimeoutMode.LIFETIME })\n        };\n        const cursor = new ClientBulkWriteCursor(this.client, commandBuilder, options);\n        try {\n          await resultsMerger.merge(cursor);\n        } catch (error) {\n          // Write concern errors are recorded in the writeConcernErrors field on MongoClientBulkWriteError.\n          // When a write concern error is encountered, it should not terminate execution of the bulk write\n          // for either ordered or unordered bulk writes. However, drivers MUST throw an exception at the end\n          // of execution if any write concern errors were observed.\n          if (error instanceof MongoServerError && !(error instanceof MongoClientBulkWriteError)) {\n            // Server side errors need to be wrapped inside a MongoClientBulkWriteError, where the root\n            // cause is the error property and a partial result is to be included.\n            const bulkWriteError = new MongoClientBulkWriteError({\n              message: 'Mongo client bulk write encountered an error during execution'\n            });\n            bulkWriteError.cause = error;\n            bulkWriteError.partialResult = resultsMerger.bulkWriteResult;\n            throw bulkWriteError;\n          } else {\n            // Client side errors are just thrown.\n            throw error;\n          }\n        }\n      }\n\n      // If we have write concern errors or unordered write errors at the end we throw.\n      if (resultsMerger.writeConcernErrors.length > 0 || resultsMerger.writeErrors.size > 0) {\n        const error = new MongoClientBulkWriteError({\n          message: 'Mongo client bulk write encountered errors during execution.'\n        });\n        error.writeConcernErrors = resultsMerger.writeConcernErrors;\n        error.writeErrors = resultsMerger.writeErrors;\n        error.partialResult = resultsMerger.bulkWriteResult;\n        throw error;\n      }\n\n      return resultsMerger.bulkWriteResult;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3138, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3142, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/command.ts"],"sourcesContent":["import type { BSONSerializeOptions, Document } from '../bson';\nimport { type MongoDBResponseConstructor } from '../cmap/wire_protocol/responses';\nimport { MongoInvalidArgumentError } from '../error';\nimport {\n  decorateWithExplain,\n  Explain,\n  type ExplainOptions,\n  validateExplainTimeoutOptions\n} from '../explain';\nimport { ReadConcern } from '../read_concern';\nimport type { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport { MIN_SECONDARY_WRITE_WIRE_VERSION } from '../sdam/server_selection';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { commandSupportsReadConcern, maxWireVersion, MongoDBNamespace } from '../utils';\nimport { WriteConcern, type WriteConcernOptions } from '../write_concern';\nimport type { ReadConcernLike } from './../read_concern';\nimport { AbstractOperation, Aspect, type OperationOptions } from './operation';\n\n/** @public */\nexport interface CollationOptions {\n  locale: string;\n  caseLevel?: boolean;\n  caseFirst?: string;\n  strength?: number;\n  numericOrdering?: boolean;\n  alternate?: string;\n  maxVariable?: string;\n  backwards?: boolean;\n  normalization?: boolean;\n}\n\n/** @public */\nexport interface CommandOperationOptions\n  extends OperationOptions,\n    WriteConcernOptions,\n    ExplainOptions {\n  /** Specify a read concern and level for the collection. (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcernLike;\n  /** Collation */\n  collation?: CollationOptions;\n  /**\n   * maxTimeMS is a server-side time limit in milliseconds for processing an operation.\n   */\n  maxTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /** Should retry failed writes */\n  retryWrites?: boolean;\n\n  // Admin command overrides.\n  dbName?: string;\n  authdb?: string;\n  noResponse?: boolean;\n}\n\n/** @internal */\nexport interface OperationParent {\n  s: { namespace: MongoDBNamespace };\n  readConcern?: ReadConcern;\n  writeConcern?: WriteConcern;\n  readPreference?: ReadPreference;\n  bsonOptions?: BSONSerializeOptions;\n  timeoutMS?: number;\n}\n\n/** @internal */\nexport abstract class CommandOperation<T> extends AbstractOperation<T> {\n  override options: CommandOperationOptions;\n  readConcern?: ReadConcern;\n  writeConcern?: WriteConcern;\n  explain?: Explain;\n\n  constructor(parent?: OperationParent, options?: CommandOperationOptions) {\n    super(options);\n    this.options = options ?? {};\n\n    // NOTE: this was explicitly added for the add/remove user operations, it's likely\n    //       something we'd want to reconsider. Perhaps those commands can use `Admin`\n    //       as a parent?\n    const dbNameOverride = options?.dbName || options?.authdb;\n    if (dbNameOverride) {\n      this.ns = new MongoDBNamespace(dbNameOverride, '$cmd');\n    } else {\n      this.ns = parent\n        ? parent.s.namespace.withCollection('$cmd')\n        : new MongoDBNamespace('admin', '$cmd');\n    }\n\n    this.readConcern = ReadConcern.fromOptions(options);\n    this.writeConcern = WriteConcern.fromOptions(options);\n\n    if (this.hasAspect(Aspect.EXPLAINABLE)) {\n      this.explain = Explain.fromOptions(options);\n      if (this.explain) validateExplainTimeoutOptions(this.options, this.explain);\n    } else if (options?.explain != null) {\n      throw new MongoInvalidArgumentError(`Option \"explain\" is not supported on this command`);\n    }\n  }\n\n  override get canRetryWrite(): boolean {\n    if (this.hasAspect(Aspect.EXPLAINABLE)) {\n      return this.explain == null;\n    }\n    return super.canRetryWrite;\n  }\n\n  public async executeCommand<T extends MongoDBResponseConstructor>(\n    server: Server,\n    session: ClientSession | undefined,\n    cmd: Document,\n    timeoutContext: TimeoutContext,\n    responseType: T | undefined\n  ): Promise<typeof responseType extends undefined ? Document : InstanceType<T>>;\n\n  public async executeCommand(\n    server: Server,\n    session: ClientSession | undefined,\n    cmd: Document,\n    timeoutContext: TimeoutContext\n  ): Promise<Document>;\n\n  async executeCommand(\n    server: Server,\n    session: ClientSession | undefined,\n    cmd: Document,\n    timeoutContext: TimeoutContext,\n    responseType?: MongoDBResponseConstructor\n  ): Promise<Document> {\n    this.server = server;\n\n    const options = {\n      ...this.options,\n      ...this.bsonOptions,\n      timeoutContext,\n      readPreference: this.readPreference,\n      session\n    };\n\n    const serverWireVersion = maxWireVersion(server);\n    const inTransaction = this.session && this.session.inTransaction();\n\n    if (this.readConcern && commandSupportsReadConcern(cmd) && !inTransaction) {\n      Object.assign(cmd, { readConcern: this.readConcern });\n    }\n\n    if (this.trySecondaryWrite && serverWireVersion < MIN_SECONDARY_WRITE_WIRE_VERSION) {\n      options.omitReadPreference = true;\n    }\n\n    if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION) && !inTransaction) {\n      WriteConcern.apply(cmd, this.writeConcern);\n    }\n\n    if (\n      options.collation &&\n      typeof options.collation === 'object' &&\n      !this.hasAspect(Aspect.SKIP_COLLATION)\n    ) {\n      Object.assign(cmd, { collation: options.collation });\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      cmd.maxTimeMS = options.maxTimeMS;\n    }\n\n    if (this.hasAspect(Aspect.EXPLAINABLE) && this.explain) {\n      cmd = decorateWithExplain(cmd, this.explain);\n    }\n\n    return await server.command(this.ns, cmd, options, responseType);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3219, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3223, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/list_databases.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Db } from '../db';\nimport { type TODO_NODE_3286 } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { maxWireVersion, MongoDBNamespace } from '../utils';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface ListDatabasesResult {\n  databases: ({ name: string; sizeOnDisk?: number; empty?: boolean } & Document)[];\n  totalSize?: number;\n  totalSizeMb?: number;\n  ok: 1 | 0;\n}\n\n/** @public */\nexport interface ListDatabasesOptions extends CommandOperationOptions {\n  /** A query predicate that determines which databases are listed */\n  filter?: Document;\n  /** A flag to indicate whether the command should return just the database names, or return both database names and size information */\n  nameOnly?: boolean;\n  /** A flag that determines which databases are returned based on the user privileges when access control is enabled */\n  authorizedDatabases?: boolean;\n}\n\n/** @internal */\nexport class ListDatabasesOperation extends CommandOperation<ListDatabasesResult> {\n  override options: ListDatabasesOptions;\n\n  constructor(db: Db, options?: ListDatabasesOptions) {\n    super(db, options);\n    this.options = options ?? {};\n    this.ns = new MongoDBNamespace('admin', '$cmd');\n  }\n\n  override get commandName() {\n    return 'listDatabases' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<ListDatabasesResult> {\n    const cmd: Document = { listDatabases: 1 };\n\n    if (typeof this.options.nameOnly === 'boolean') {\n      cmd.nameOnly = this.options.nameOnly;\n    }\n\n    if (this.options.filter) {\n      cmd.filter = this.options.filter;\n    }\n\n    if (typeof this.options.authorizedDatabases === 'boolean') {\n      cmd.authorizedDatabases = this.options.authorizedDatabases;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (maxWireVersion(server) >= 9 && this.options.comment !== undefined) {\n      cmd.comment = this.options.comment;\n    }\n\n    return await (super.executeCommand(\n      server,\n      session,\n      cmd,\n      timeoutContext\n    ) as Promise<TODO_NODE_3286>);\n  }\n}\n\ndefineAspects(ListDatabasesOperation, [Aspect.READ_OPERATION, Aspect.RETRYABLE]);\n"],"names":[],"mappings":";;;;;AAMA,MAAA;AACA,MAAA;AACA,MAAA;AAoBA,cAAA,GACA,MAAa,+BAA+B,UAAA,gBAAqC;IAG/E,YAAY,EAAM,EAAE,OAA8B,CAAA;QAChD,KAAK,CAAC,IAAI;QACV,IAAI,CAAC,OAAO,GAAG,WAAW,CAAA;QAC1B,IAAI,CAAC,EAAE,GAAG,IAAI,QAAA,gBAAgB,CAAC,SAAS;IAC1C;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,MAAgB;YAAE,eAAe;QAAC;QAExC,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,WAAW;YAC9C,IAAI,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ;QACtC;QAEA,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;YACvB,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM;QAClC;QAEA,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,mBAAmB,KAAK,WAAW;YACzD,IAAI,mBAAmB,GAAG,IAAI,CAAC,OAAO,CAAC,mBAAmB;QAC5D;QAEA,iEAAiE;QACjE,gDAAgD;QAChD,IAAI,CAAA,GAAA,QAAA,cAAc,EAAC,WAAW,KAAK,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,WAAW;YACrE,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO;QACpC;QAEA,OAAO,MAAO,KAAK,CAAC,eAClB,QACA,SACA,KACA;IAEJ;;AA5CF,QAAA,sBAAA,GAAA;AA+CA,CAAA,GAAA,YAAA,aAAa,EAAC,wBAAwB;IAAC,YAAA,MAAM,CAAC,cAAc;IAAE,YAAA,MAAM,CAAC,SAAS;CAAC"}},
    {"offset": {"line": 3266, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3270, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/operations/validate_collection.ts"],"sourcesContent":["import type { Admin } from '../admin';\nimport type { Document } from '../bson';\nimport { MongoUnexpectedServerResponseError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { CommandOperation, type CommandOperationOptions } from './command';\n\n/** @public */\nexport interface ValidateCollectionOptions extends CommandOperationOptions {\n  /** Validates a collection in the background, without interrupting read or write traffic (only in MongoDB 4.4+) */\n  background?: boolean;\n}\n\n/** @internal */\nexport class ValidateCollectionOperation extends CommandOperation<Document> {\n  override options: ValidateCollectionOptions;\n  collectionName: string;\n  command: Document;\n\n  constructor(admin: Admin, collectionName: string, options: ValidateCollectionOptions) {\n    // Decorate command with extra options\n    const command: Document = { validate: collectionName };\n    const keys = Object.keys(options);\n    for (let i = 0; i < keys.length; i++) {\n      if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== 'session') {\n        command[keys[i]] = (options as Document)[keys[i]];\n      }\n    }\n\n    super(admin.s.db, options);\n    this.options = options;\n    this.command = command;\n    this.collectionName = collectionName;\n  }\n\n  override get commandName() {\n    return 'validate' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Document> {\n    const collectionName = this.collectionName;\n\n    const doc = await super.executeCommand(server, session, this.command, timeoutContext);\n    if (doc.result != null && typeof doc.result !== 'string')\n      throw new MongoUnexpectedServerResponseError('Error with validation data');\n    if (doc.result != null && doc.result.match(/exception|corrupt/) != null)\n      throw new MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);\n    if (doc.valid != null && !doc.valid)\n      throw new MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);\n\n    return doc;\n  }\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AAIA,MAAA;AAQA,cAAA,GACA,MAAa,oCAAoC,UAAA,gBAA0B;IAKzE,YAAY,KAAY,EAAE,cAAsB,EAAE,OAAkC,CAAA;QAClF,sCAAsC;QACtC,MAAM,UAAoB;YAAE,UAAU;QAAc;QACpD,MAAM,OAAO,OAAO,IAAI,CAAC;QACzB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;YACpC,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,KAAK,WAAW;gBACnF,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,GAAI,OAAoB,CAAC,IAAI,CAAC,EAAE,CAAC;YACnD;QACF;QAEA,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE;QAClB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,cAAc,GAAG;IACxB;IAEA,IAAa,cAAW;QACtB,OAAO;IACT;IAES,MAAM,QACb,MAAc,EACd,OAAkC,EAClC,cAA8B,EAAA;QAE9B,MAAM,iBAAiB,IAAI,CAAC,cAAc;QAE1C,MAAM,MAAM,MAAM,KAAK,CAAC,eAAe,QAAQ,SAAS,IAAI,CAAC,OAAO,EAAE;QACtE,IAAI,IAAI,MAAM,IAAI,QAAQ,OAAO,IAAI,MAAM,KAAK,UAC9C,MAAM,IAAI,QAAA,kCAAkC,CAAC;QAC/C,IAAI,IAAI,MAAM,IAAI,QAAQ,IAAI,MAAM,CAAC,KAAK,CAAC,wBAAwB,MACjE,MAAM,IAAI,QAAA,kCAAkC,CAAC,CAAA,mBAAA,EAAsB,eAAc,CAAE;QACrF,IAAI,IAAI,KAAK,IAAI,QAAQ,CAAC,IAAI,KAAK,EACjC,MAAM,IAAI,QAAA,kCAAkC,CAAC,CAAA,mBAAA,EAAsB,eAAc,CAAE;QAErF,OAAO;IACT;;AAzCF,QAAA,2BAAA,GAAA"}},
    {"offset": {"line": 3307, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}