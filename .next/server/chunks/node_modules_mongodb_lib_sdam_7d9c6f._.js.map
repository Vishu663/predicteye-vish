{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/common.ts"],"sourcesContent":["import type { Binary, Long, Timestamp } from '../bson';\nimport type { ClientSession } from '../sessions';\nimport type { Topology } from './topology';\n\n// shared state names\nexport const STATE_CLOSING = 'closing';\nexport const STATE_CLOSED = 'closed';\nexport const STATE_CONNECTING = 'connecting';\nexport const STATE_CONNECTED = 'connected';\n\n/**\n * An enumeration of topology types we know about\n * @public\n */\nexport const TopologyType = Object.freeze({\n  Single: 'Single',\n  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',\n  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',\n  Sharded: 'Sharded',\n  Unknown: 'Unknown',\n  LoadBalanced: 'LoadBalanced'\n} as const);\n\n/** @public */\nexport type TopologyType = (typeof TopologyType)[keyof typeof TopologyType];\n\n/**\n * An enumeration of server types we know about\n * @public\n */\nexport const ServerType = Object.freeze({\n  Standalone: 'Standalone',\n  Mongos: 'Mongos',\n  PossiblePrimary: 'PossiblePrimary',\n  RSPrimary: 'RSPrimary',\n  RSSecondary: 'RSSecondary',\n  RSArbiter: 'RSArbiter',\n  RSOther: 'RSOther',\n  RSGhost: 'RSGhost',\n  Unknown: 'Unknown',\n  LoadBalancer: 'LoadBalancer'\n} as const);\n\n/** @public */\nexport type ServerType = (typeof ServerType)[keyof typeof ServerType];\n\n/**\n * @public\n * Gossiped in component for the cluster time tracking the state of user databases\n * across the cluster. It may optionally include a signature identifying the process that\n * generated such a value.\n */\nexport interface ClusterTime {\n  clusterTime: Timestamp;\n  /** Used to validate the identity of a request or response's ClusterTime. */\n  signature?: {\n    hash: Binary;\n    keyId: Long;\n  };\n}\n\n/** Shared function to determine clusterTime for a given topology or session */\nexport function _advanceClusterTime(\n  entity: Topology | ClientSession,\n  $clusterTime: ClusterTime\n): void {\n  if (entity.clusterTime == null) {\n    entity.clusterTime = $clusterTime;\n  } else {\n    if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {\n      entity.clusterTime = $clusterTime;\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;AA8DA,QAAA,mBAAA,GAAA;AA1DA,qBAAqB;AACR,QAAA,aAAa,GAAG;AAChB,QAAA,YAAY,GAAG;AACf,QAAA,gBAAgB,GAAG;AACnB,QAAA,eAAe,GAAG;AAE/B;;;IAIa,QAAA,YAAY,GAAG,OAAO,MAAM,CAAC;IACxC,QAAQ;IACR,qBAAqB;IACrB,uBAAuB;IACvB,SAAS;IACT,SAAS;IACT,cAAc;;AAMhB;;;IAIa,QAAA,UAAU,GAAG,OAAO,MAAM,CAAC;IACtC,YAAY;IACZ,QAAQ;IACR,iBAAiB;IACjB,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,SAAS;IACT,cAAc;;AAqBhB,6EAAA,GACA,SAAgB,oBACd,MAAgC,EAChC,YAAyB;IAEzB,IAAI,OAAO,WAAW,IAAI,MAAM;QAC9B,OAAO,WAAW,GAAG;IACvB,OAAO;QACL,IAAI,aAAa,WAAW,CAAC,WAAW,CAAC,OAAO,WAAW,CAAC,WAAW,GAAG;YACxE,OAAO,WAAW,GAAG;QACvB;IACF;AACF"}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/server_selection.ts"],"sourcesContent":["import { MongoCompatibilityError, MongoInvalidArgumentError } from '../error';\nimport { ReadPreference } from '../read_preference';\nimport { ServerType, TopologyType } from './common';\nimport type { ServerDescription, TagSet } from './server_description';\nimport type { TopologyDescription } from './topology_description';\n\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n\n//  Minimum version to try writes on secondaries.\nexport const MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n\n/** @internal */\nexport type ServerSelector = (\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[],\n  deprioritized?: ServerDescription[]\n) => ServerDescription[];\n\n/**\n * Returns a server selector that selects for writable servers\n */\nexport function writableServerSelector(): ServerSelector {\n  return function writableServer(\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] {\n    return latencyWindowReducer(\n      topologyDescription,\n      servers.filter((s: ServerDescription) => s.isWritable)\n    );\n  };\n}\n\n/**\n * The purpose of this selector is to select the same server, only\n * if it is in a state that it can have commands sent to it.\n */\nexport function sameServerSelector(description?: ServerDescription): ServerSelector {\n  return function sameServerSelector(\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] {\n    if (!description) return [];\n    // Filter the servers to match the provided description only if\n    // the type is not unknown.\n    return servers.filter(sd => {\n      return sd.address === description.address && sd.type !== ServerType.Unknown;\n    });\n  };\n}\n\n/**\n * Returns a server selector that uses a read preference to select a\n * server potentially for a write on a secondary.\n */\nexport function secondaryWritableServerSelector(\n  wireVersion?: number,\n  readPreference?: ReadPreference\n): ServerSelector {\n  // If server version < 5.0, read preference always primary.\n  // If server version >= 5.0...\n  // - If read preference is supplied, use that.\n  // - If no read preference is supplied, use primary.\n  if (\n    !readPreference ||\n    !wireVersion ||\n    (wireVersion && wireVersion < MIN_SECONDARY_WRITE_WIRE_VERSION)\n  ) {\n    return readPreferenceServerSelector(ReadPreference.primary);\n  }\n  return readPreferenceServerSelector(readPreference);\n}\n\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here:\n *\n * @see https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.md\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(\n  readPreference: ReadPreference,\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance =\n    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoInvalidArgumentError(\n      `Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`\n    );\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoInvalidArgumentError(\n      `Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`\n    );\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary: ServerDescription = Array.from(topologyDescription.servers.values()).filter(\n      primaryFilter\n    )[0];\n\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n      const stalenessMS =\n        server.lastUpdateTime -\n        server.lastWriteDate -\n        (primary.lastUpdateTime - primary.lastWriteDate) +\n        topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max: ServerDescription, s: ServerDescription) =>\n      s.lastWriteDate > max.lastWriteDate ? s : max\n    );\n\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n      const stalenessMS =\n        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\nfunction tagSetMatch(tagSet: TagSet, serverTags: TagSet) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\nfunction tagSetReducer(\n  readPreference: ReadPreference,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  if (\n    readPreference.tags == null ||\n    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)\n  ) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce(\n      (matched: ServerDescription[], server: ServerDescription) => {\n        if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n        return matched;\n      },\n      []\n    );\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n *\n * @see https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.md\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  const low = servers.reduce(\n    (min: number, server: ServerDescription) => Math.min(server.roundTripTime, min),\n    Infinity\n  );\n\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n\n// filters\nfunction primaryFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server: ServerDescription): boolean {\n  return server.type !== ServerType.Unknown;\n}\n\nfunction loadBalancerFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.LoadBalancer;\n}\n\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\nexport function readPreferenceServerSelector(readPreference: ReadPreference): ServerSelector {\n  if (!readPreference.isValid()) {\n    throw new MongoInvalidArgumentError('Invalid read preference specified');\n  }\n\n  return function readPreferenceServers(\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[],\n    deprioritized: ServerDescription[] = []\n  ): ServerDescription[] {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (\n      commonWireVersion &&\n      readPreference.minWireVersion &&\n      readPreference.minWireVersion > commonWireVersion\n    ) {\n      throw new MongoCompatibilityError(\n        `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`\n      );\n    }\n\n    if (topologyDescription.type === TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (topologyDescription.type === TopologyType.Single) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    if (topologyDescription.type === TopologyType.Sharded) {\n      const filtered = servers.filter(server => {\n        return !deprioritized.includes(server);\n      });\n      const selectable = filtered.length > 0 ? filtered : deprioritized;\n      return latencyWindowReducer(topologyDescription, selectable.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(\n      topologyDescription,\n      tagSetReducer(\n        readPreference,\n        maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))\n      )\n    );\n\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 277, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/server_description.ts"],"sourcesContent":["import { type Document, Long, type ObjectId } from '../bson';\nimport { type MongoError, MongoRuntimeError } from '../error';\nimport { arrayStrictEqual, compareObjectId, errorStrictEqual, HostAddress, now } from '../utils';\nimport { type ClusterTime, ServerType } from './common';\n\nconst WRITABLE_SERVER_TYPES = new Set<ServerType>([\n  ServerType.RSPrimary,\n  ServerType.Standalone,\n  ServerType.Mongos,\n  ServerType.LoadBalancer\n]);\n\nconst DATA_BEARING_SERVER_TYPES = new Set<ServerType>([\n  ServerType.RSPrimary,\n  ServerType.RSSecondary,\n  ServerType.Mongos,\n  ServerType.Standalone,\n  ServerType.LoadBalancer\n]);\n\n/** @public */\nexport interface TopologyVersion {\n  processId: ObjectId;\n  counter: Long;\n}\n\n/** @public */\nexport type TagSet = { [key: string]: string };\n\n/** @internal */\nexport interface ServerDescriptionOptions {\n  /** An Error used for better reporting debugging */\n  error?: MongoError;\n\n  /** The average round trip time to ping this server (in ms) */\n  roundTripTime?: number;\n  /** The minimum round trip time to ping this server over the past 10 samples(in ms) */\n  minRoundTripTime?: number;\n\n  /** If the client is in load balancing mode. */\n  loadBalanced?: boolean;\n}\n\n/**\n * The client's view of a single server, based on the most recent hello outcome.\n *\n * Internal type, not meant to be directly instantiated\n * @public\n */\nexport class ServerDescription {\n  address: string;\n  type: ServerType;\n  hosts: string[];\n  passives: string[];\n  arbiters: string[];\n  tags: TagSet;\n  error: MongoError | null;\n  topologyVersion: TopologyVersion | null;\n  minWireVersion: number;\n  maxWireVersion: number;\n  roundTripTime: number;\n  /** The minimum measurement of the last 10 measurements of roundTripTime that have been collected */\n  minRoundTripTime: number;\n  lastUpdateTime: number;\n  lastWriteDate: number;\n  me: string | null;\n  primary: string | null;\n  setName: string | null;\n  setVersion: number | null;\n  electionId: ObjectId | null;\n  logicalSessionTimeoutMinutes: number | null;\n  /** The max message size in bytes for the server. */\n  maxMessageSizeBytes: number | null;\n  /** The max number of writes in a bulk write command. */\n  maxWriteBatchSize: number | null;\n  /** The max bson object size. */\n  maxBsonObjectSize: number | null;\n  /** Indicates server is a mongocryptd instance. */\n  iscryptd: boolean;\n\n  // NOTE: does this belong here? It seems we should gossip the cluster time at the CMAP level\n  $clusterTime?: ClusterTime;\n\n  /**\n   * Create a ServerDescription\n   * @internal\n   *\n   * @param address - The address of the server\n   * @param hello - An optional hello response for this server\n   */\n  constructor(\n    address: HostAddress | string,\n    hello?: Document,\n    options: ServerDescriptionOptions = {}\n  ) {\n    if (address == null || address === '') {\n      throw new MongoRuntimeError('ServerDescription must be provided with a non-empty address');\n    }\n\n    this.address =\n      typeof address === 'string'\n        ? HostAddress.fromString(address).toString() // Use HostAddress to normalize\n        : address.toString();\n    this.type = parseServerType(hello, options);\n    this.hosts = hello?.hosts?.map((host: string) => host.toLowerCase()) ?? [];\n    this.passives = hello?.passives?.map((host: string) => host.toLowerCase()) ?? [];\n    this.arbiters = hello?.arbiters?.map((host: string) => host.toLowerCase()) ?? [];\n    this.tags = hello?.tags ?? {};\n    this.minWireVersion = hello?.minWireVersion ?? 0;\n    this.maxWireVersion = hello?.maxWireVersion ?? 0;\n    this.roundTripTime = options?.roundTripTime ?? -1;\n    this.minRoundTripTime = options?.minRoundTripTime ?? 0;\n    this.lastUpdateTime = now();\n    this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;\n    // NOTE: This actually builds the stack string instead of holding onto the getter and all its\n    // associated references. This is done to prevent a memory leak.\n    this.error = options.error ?? null;\n    this.error?.stack;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    this.topologyVersion = this.error?.topologyVersion ?? hello?.topologyVersion ?? null;\n    this.setName = hello?.setName ?? null;\n    this.setVersion = hello?.setVersion ?? null;\n    this.electionId = hello?.electionId ?? null;\n    this.logicalSessionTimeoutMinutes = hello?.logicalSessionTimeoutMinutes ?? null;\n    this.maxMessageSizeBytes = hello?.maxMessageSizeBytes ?? null;\n    this.maxWriteBatchSize = hello?.maxWriteBatchSize ?? null;\n    this.maxBsonObjectSize = hello?.maxBsonObjectSize ?? null;\n    this.primary = hello?.primary ?? null;\n    this.me = hello?.me?.toLowerCase() ?? null;\n    this.$clusterTime = hello?.$clusterTime ?? null;\n    this.iscryptd = Boolean(hello?.iscryptd);\n  }\n\n  get hostAddress(): HostAddress {\n    return HostAddress.fromString(this.address);\n  }\n\n  get allHosts(): string[] {\n    return this.hosts.concat(this.arbiters).concat(this.passives);\n  }\n\n  /** Is this server available for reads*/\n  get isReadable(): boolean {\n    return this.type === ServerType.RSSecondary || this.isWritable;\n  }\n\n  /** Is this server data bearing */\n  get isDataBearing(): boolean {\n    return DATA_BEARING_SERVER_TYPES.has(this.type);\n  }\n\n  /** Is this server available for writes */\n  get isWritable(): boolean {\n    return WRITABLE_SERVER_TYPES.has(this.type);\n  }\n\n  get host(): string {\n    const chopLength = `:${this.port}`.length;\n    return this.address.slice(0, -chopLength);\n  }\n\n  get port(): number {\n    const port = this.address.split(':').pop();\n    return port ? Number.parseInt(port, 10) : 27017;\n  }\n\n  /**\n   * Determines if another `ServerDescription` is equal to this one per the rules defined in the SDAM specification.\n   * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.md\n   */\n  equals(other?: ServerDescription | null): boolean {\n    // Despite using the comparator that would determine a nullish topologyVersion as greater than\n    // for equality we should only always perform direct equality comparison\n    const topologyVersionsEqual =\n      this.topologyVersion === other?.topologyVersion ||\n      compareTopologyVersion(this.topologyVersion, other?.topologyVersion) === 0;\n\n    const electionIdsEqual =\n      this.electionId != null && other?.electionId != null\n        ? compareObjectId(this.electionId, other.electionId) === 0\n        : this.electionId === other?.electionId;\n\n    return (\n      other != null &&\n      other.iscryptd === this.iscryptd &&\n      errorStrictEqual(this.error, other.error) &&\n      this.type === other.type &&\n      this.minWireVersion === other.minWireVersion &&\n      arrayStrictEqual(this.hosts, other.hosts) &&\n      tagsStrictEqual(this.tags, other.tags) &&\n      this.setName === other.setName &&\n      this.setVersion === other.setVersion &&\n      electionIdsEqual &&\n      this.primary === other.primary &&\n      this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes &&\n      topologyVersionsEqual\n    );\n  }\n}\n\n// Parses a `hello` message and determines the server type\nexport function parseServerType(hello?: Document, options?: ServerDescriptionOptions): ServerType {\n  if (options?.loadBalanced) {\n    return ServerType.LoadBalancer;\n  }\n\n  if (!hello || !hello.ok) {\n    return ServerType.Unknown;\n  }\n\n  if (hello.isreplicaset) {\n    return ServerType.RSGhost;\n  }\n\n  if (hello.msg && hello.msg === 'isdbgrid') {\n    return ServerType.Mongos;\n  }\n\n  if (hello.setName) {\n    if (hello.hidden) {\n      return ServerType.RSOther;\n    } else if (hello.isWritablePrimary) {\n      return ServerType.RSPrimary;\n    } else if (hello.secondary) {\n      return ServerType.RSSecondary;\n    } else if (hello.arbiterOnly) {\n      return ServerType.RSArbiter;\n    } else {\n      return ServerType.RSOther;\n    }\n  }\n\n  return ServerType.Standalone;\n}\n\nfunction tagsStrictEqual(tags: TagSet, tags2: TagSet): boolean {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n\n  return (\n    tagsKeys.length === tags2Keys.length &&\n    tagsKeys.every((key: string) => tags2[key] === tags[key])\n  );\n}\n\n/**\n * Compares two topology versions.\n *\n * 1. If the response topologyVersion is unset or the ServerDescription's\n *    topologyVersion is null, the client MUST assume the response is more recent.\n * 1. If the response's topologyVersion.processId is not equal to the\n *    ServerDescription's, the client MUST assume the response is more recent.\n * 1. If the response's topologyVersion.processId is equal to the\n *    ServerDescription's, the client MUST use the counter field to determine\n *    which topologyVersion is more recent.\n *\n * ```ts\n * currentTv <   newTv === -1\n * currentTv === newTv === 0\n * currentTv >   newTv === 1\n * ```\n */\nexport function compareTopologyVersion(\n  currentTv?: TopologyVersion | null,\n  newTv?: TopologyVersion | null\n): 0 | -1 | 1 {\n  if (currentTv == null || newTv == null) {\n    return -1;\n  }\n\n  if (!currentTv.processId.equals(newTv.processId)) {\n    return -1;\n  }\n\n  // TODO(NODE-2674): Preserve int64 sent from MongoDB\n  const currentCounter =\n    typeof currentTv.counter === 'bigint'\n      ? Long.fromBigInt(currentTv.counter)\n      : Long.isLong(currentTv.counter)\n        ? currentTv.counter\n        : Long.fromNumber(currentTv.counter);\n\n  const newCounter =\n    typeof newTv.counter === 'bigint'\n      ? Long.fromBigInt(newTv.counter)\n      : Long.isLong(newTv.counter)\n        ? newTv.counter\n        : Long.fromNumber(newTv.counter);\n\n  return currentCounter.compare(newCounter);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 445, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/topology_description.ts"],"sourcesContent":["import { EJSON, type ObjectId } from '../bson';\nimport * as WIRE_CONSTANTS from '../cmap/wire_protocol/constants';\nimport { type MongoError, MongoRuntimeError, MongoStalePrimaryError } from '../error';\nimport { compareObjectId, shuffle } from '../utils';\nimport { ServerType, TopologyType } from './common';\nimport { ServerDescription } from './server_description';\nimport type { SrvPollingEvent } from './srv_polling';\n\n// constants related to compatibility checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\nconst MONGOS_OR_UNKNOWN = new Set<ServerType>([ServerType.Mongos, ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set<ServerType>([ServerType.Mongos, ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set<ServerType>([\n  ServerType.RSSecondary,\n  ServerType.RSArbiter,\n  ServerType.RSOther\n]);\n\n/** @public */\nexport interface TopologyDescriptionOptions {\n  heartbeatFrequencyMS?: number;\n  localThresholdMS?: number;\n}\n\n/**\n * Representation of a deployment of servers\n * @public\n */\nexport class TopologyDescription {\n  type: TopologyType;\n  setName: string | null;\n  maxSetVersion: number | null;\n  maxElectionId: ObjectId | null;\n  servers: Map<string, ServerDescription>;\n  stale: boolean;\n  compatible: boolean;\n  compatibilityError?: string;\n  logicalSessionTimeoutMinutes: number | null;\n  heartbeatFrequencyMS: number;\n  localThresholdMS: number;\n  commonWireVersion: number;\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(\n    topologyType: TopologyType,\n    serverDescriptions: Map<string, ServerDescription> | null = null,\n    setName: string | null = null,\n    maxSetVersion: number | null = null,\n    maxElectionId: ObjectId | null = null,\n    commonWireVersion: number | null = null,\n    options: TopologyDescriptionOptions | null = null\n  ) {\n    options = options ?? {};\n\n    this.type = topologyType ?? TopologyType.Unknown;\n    this.servers = serverDescriptions ?? new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;\n    this.localThresholdMS = options.localThresholdMS ?? 15;\n    this.setName = setName ?? null;\n    this.maxElectionId = maxElectionId ?? null;\n    this.maxSetVersion = maxSetVersion ?? null;\n    this.commonWireVersion = commonWireVersion ?? 0;\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (\n        serverDescription.type === ServerType.Unknown ||\n        serverDescription.type === ServerType.LoadBalancer\n      ) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from a hello response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    this.logicalSessionTimeoutMinutes = null;\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = null;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        }\n\n        // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n        this.logicalSessionTimeoutMinutes = Math.min(\n          this.logicalSessionTimeoutMinutes,\n          server.logicalSessionTimeoutMinutes\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n  updateFromSrvPollingEvent(ev: SrvPollingEvent, srvMaxHosts = 0): TopologyDescription {\n    /** The SRV addresses defines the set of addresses we should be using */\n    const incomingHostnames = ev.hostnames();\n    const currentHostnames = new Set(this.servers.keys());\n\n    const hostnamesToAdd = new Set<string>(incomingHostnames);\n    const hostnamesToRemove = new Set<string>();\n    for (const hostname of currentHostnames) {\n      // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\n      hostnamesToAdd.delete(hostname);\n      if (!incomingHostnames.has(hostname)) {\n        // If the SRV Records no longer include this hostname\n        // we have to stop using it\n        hostnamesToRemove.add(hostname);\n      }\n    }\n\n    if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\n      // No new hosts to add and none to remove\n      return this;\n    }\n\n    const serverDescriptions = new Map(this.servers);\n    for (const removedHost of hostnamesToRemove) {\n      serverDescriptions.delete(removedHost);\n    }\n\n    if (hostnamesToAdd.size > 0) {\n      if (srvMaxHosts === 0) {\n        // Add all!\n        for (const hostToAdd of hostnamesToAdd) {\n          serverDescriptions.set(hostToAdd, new ServerDescription(hostToAdd));\n        }\n      } else if (serverDescriptions.size < srvMaxHosts) {\n        // Add only the amount needed to get us back to srvMaxHosts\n        const selectedHosts = shuffle(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\n        for (const selectedHostToAdd of selectedHosts) {\n          serverDescriptions.set(selectedHostToAdd, new ServerDescription(selectedHostToAdd));\n        }\n      }\n    }\n\n    return new TopologyDescription(\n      this.type,\n      serverDescriptions,\n      this.setName,\n      this.maxSetVersion,\n      this.maxElectionId,\n      this.commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n  update(serverDescription: ServerDescription): TopologyDescription {\n    const address = serverDescription.address;\n\n    // potentially mutated values\n    let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;\n\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    if (\n      typeof serverDescription.setName === 'string' &&\n      typeof setName === 'string' &&\n      serverDescription.setName !== setName\n    ) {\n      if (topologyType === TopologyType.Single) {\n        // \"Single\" Topology with setName mismatch is direct connection usage, mark unknown do not remove\n        serverDescription = new ServerDescription(address);\n      } else {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(\n        TopologyType.Single,\n        serverDescriptions,\n        setName,\n        maxSetVersion,\n        maxElectionId,\n        commonWireVersion,\n        { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n      );\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(\n          serverDescriptions,\n          serverDescription,\n          setName\n        );\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(\n      topologyType,\n      serverDescriptions,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  get error(): MongoError | null {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(\n      (sd: ServerDescription) => sd.error\n    );\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n\n    return null;\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers(): boolean {\n    return Array.from(this.servers.values()).some(\n      (sd: ServerDescription) => sd.type !== ServerType.Unknown\n    );\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers(): boolean {\n    return Array.from(this.servers.values()).some((sd: ServerDescription) => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n  hasServer(address: string): boolean {\n    return this.servers.has(address);\n  }\n\n  /**\n   * Returns a JSON-serializable representation of the TopologyDescription.  This is primarily\n   * intended for use with JSON.stringify().\n   *\n   * This method will not throw.\n   */\n  toJSON() {\n    return EJSON.serialize(this);\n  }\n}\n\nfunction topologyTypeForServerType(serverType: ServerType): TopologyType {\n  switch (serverType) {\n    case ServerType.Standalone:\n      return TopologyType.Single;\n    case ServerType.Mongos:\n      return TopologyType.Sharded;\n    case ServerType.RSPrimary:\n      return TopologyType.ReplicaSetWithPrimary;\n    case ServerType.RSOther:\n    case ServerType.RSSecondary:\n      return TopologyType.ReplicaSetNoPrimary;\n    default:\n      return TopologyType.Unknown;\n  }\n}\n\nfunction updateRsFromPrimary(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null,\n  maxSetVersion: number | null = null,\n  maxElectionId: ObjectId | null = null\n): [TopologyType, string | null, number | null, ObjectId | null] {\n  const setVersionElectionIdMismatch = (\n    serverDescription: ServerDescription,\n    maxSetVersion: number | null,\n    maxElectionId: ObjectId | null\n  ) => {\n    return (\n      `primary marked stale due to electionId/setVersion mismatch:` +\n      ` server setVersion: ${serverDescription.setVersion},` +\n      ` server electionId: ${serverDescription.electionId},` +\n      ` topology setVersion: ${maxSetVersion},` +\n      ` topology electionId: ${maxElectionId}`\n    );\n  };\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  if (serverDescription.maxWireVersion >= 17) {\n    const electionIdComparison = compareObjectId(maxElectionId, serverDescription.electionId);\n    const maxElectionIdIsEqual = electionIdComparison === 0;\n    const maxElectionIdIsLess = electionIdComparison === -1;\n    const maxSetVersionIsLessOrEqual =\n      (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);\n\n    if (maxElectionIdIsLess || (maxElectionIdIsEqual && maxSetVersionIsLessOrEqual)) {\n      // The reported electionId was greater\n      // or the electionId was equal and reported setVersion was greater\n      // Always update both values, they are a tuple\n      maxElectionId = serverDescription.electionId;\n      maxSetVersion = serverDescription.setVersion;\n    } else {\n      // Stale primary\n      // replace serverDescription with a default ServerDescription of type \"Unknown\"\n      serverDescriptions.set(\n        serverDescription.address,\n        new ServerDescription(serverDescription.address, undefined, {\n          error: new MongoStalePrimaryError(\n            setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId)\n          )\n        })\n      );\n\n      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n    }\n  } else {\n    const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n    if (serverDescription.setVersion && electionId) {\n      if (maxSetVersion && maxElectionId) {\n        if (\n          maxSetVersion > serverDescription.setVersion ||\n          compareObjectId(maxElectionId, electionId) > 0\n        ) {\n          // this primary is stale, we must remove it\n          serverDescriptions.set(\n            serverDescription.address,\n            new ServerDescription(serverDescription.address, undefined, {\n              error: new MongoStalePrimaryError(\n                setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId)\n              )\n            })\n          );\n\n          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n        }\n      }\n\n      maxElectionId = serverDescription.electionId;\n    }\n\n    if (\n      serverDescription.setVersion != null &&\n      (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\n    ) {\n      maxSetVersion = serverDescription.setVersion;\n    }\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(\n        address,\n        new ServerDescription(server.address, undefined, {\n          error: new MongoStalePrimaryError(\n            'primary marked stale due to discovery of newer primary'\n          )\n        })\n      );\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses\n    .filter((addr: string) => responseAddresses.indexOf(addr) === -1)\n    .forEach((address: string) => {\n      serverDescriptions.delete(address);\n    });\n\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null\n): TopologyType {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (\n    setName !== serverDescription.setName ||\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\n  ) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null\n): [TopologyType, string | null] {\n  const topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName ?? serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions: Map<string, ServerDescription>): TopologyType {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 842, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 846, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/events.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport {\n  SERVER_CLOSED,\n  SERVER_DESCRIPTION_CHANGED,\n  SERVER_HEARTBEAT_FAILED,\n  SERVER_HEARTBEAT_STARTED,\n  SERVER_HEARTBEAT_SUCCEEDED,\n  SERVER_OPENING,\n  TOPOLOGY_CLOSED,\n  TOPOLOGY_DESCRIPTION_CHANGED,\n  TOPOLOGY_OPENING\n} from '../constants';\nimport type { ServerDescription } from './server_description';\nimport type { TopologyDescription } from './topology_description';\n\n/**\n * Emitted when server description changes, but does NOT include changes to the RTT.\n * @public\n * @category Event\n */\nexport class ServerDescriptionChangedEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** The address (host/port pair) of the server */\n  address: string;\n  /** The previous server description */\n  previousDescription: ServerDescription;\n  /** The new server description */\n  newDescription: ServerDescription;\n  name = SERVER_DESCRIPTION_CHANGED;\n\n  /** @internal */\n  constructor(\n    topologyId: number,\n    address: string,\n    previousDescription: ServerDescription,\n    newDescription: ServerDescription\n  ) {\n    this.topologyId = topologyId;\n    this.address = address;\n    this.previousDescription = previousDescription;\n    this.newDescription = newDescription;\n  }\n}\n\n/**\n * Emitted when server is initialized.\n * @public\n * @category Event\n */\nexport class ServerOpeningEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** The address (host/port pair) of the server */\n  address: string;\n  /** @internal */\n  name = SERVER_OPENING;\n\n  /** @internal */\n  constructor(topologyId: number, address: string) {\n    this.topologyId = topologyId;\n    this.address = address;\n  }\n}\n\n/**\n * Emitted when server is closed.\n * @public\n * @category Event\n */\nexport class ServerClosedEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** The address (host/port pair) of the server */\n  address: string;\n  /** @internal */\n  name = SERVER_CLOSED;\n\n  /** @internal */\n  constructor(topologyId: number, address: string) {\n    this.topologyId = topologyId;\n    this.address = address;\n  }\n}\n\n/**\n * Emitted when topology description changes.\n * @public\n * @category Event\n */\nexport class TopologyDescriptionChangedEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** The old topology description */\n  previousDescription: TopologyDescription;\n  /** The new topology description */\n  newDescription: TopologyDescription;\n  /** @internal */\n  name = TOPOLOGY_DESCRIPTION_CHANGED;\n\n  /** @internal */\n  constructor(\n    topologyId: number,\n    previousDescription: TopologyDescription,\n    newDescription: TopologyDescription\n  ) {\n    this.topologyId = topologyId;\n    this.previousDescription = previousDescription;\n    this.newDescription = newDescription;\n  }\n}\n\n/**\n * Emitted when topology is initialized.\n * @public\n * @category Event\n */\nexport class TopologyOpeningEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** @internal */\n  name = TOPOLOGY_OPENING;\n\n  /** @internal */\n  constructor(topologyId: number) {\n    this.topologyId = topologyId;\n  }\n}\n\n/**\n * Emitted when topology is closed.\n * @public\n * @category Event\n */\nexport class TopologyClosedEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** @internal */\n  name = TOPOLOGY_CLOSED;\n\n  /** @internal */\n  constructor(topologyId: number) {\n    this.topologyId = topologyId;\n  }\n}\n\n/**\n * Emitted when the server monitors hello command is started - immediately before\n * the hello command is serialized into raw BSON and written to the socket.\n *\n * @public\n * @category Event\n */\nexport class ServerHeartbeatStartedEvent {\n  /** The connection id for the command */\n  connectionId: string;\n  /** Is true when using the streaming protocol */\n  awaited: boolean;\n  /** @internal */\n  name = SERVER_HEARTBEAT_STARTED;\n\n  /** @internal */\n  constructor(connectionId: string, awaited: boolean) {\n    this.connectionId = connectionId;\n    this.awaited = awaited;\n  }\n}\n\n/**\n * Emitted when the server monitors hello succeeds.\n * @public\n * @category Event\n */\nexport class ServerHeartbeatSucceededEvent {\n  /** The connection id for the command */\n  connectionId: string;\n  /** The execution time of the event in ms */\n  duration: number;\n  /** The command reply */\n  reply: Document;\n  /** Is true when using the streaming protocol */\n  awaited: boolean;\n  /** @internal */\n  name = SERVER_HEARTBEAT_SUCCEEDED;\n\n  /** @internal */\n  constructor(connectionId: string, duration: number, reply: Document | null, awaited: boolean) {\n    this.connectionId = connectionId;\n    this.duration = duration;\n    this.reply = reply ?? {};\n    this.awaited = awaited;\n  }\n}\n\n/**\n * Emitted when the server monitors hello fails, either with an ok: 0 or a socket exception.\n * @public\n * @category Event\n */\nexport class ServerHeartbeatFailedEvent {\n  /** The connection id for the command */\n  connectionId: string;\n  /** The execution time of the event in ms */\n  duration: number;\n  /** The command failure */\n  failure: Error;\n  /** Is true when using the streaming protocol */\n  awaited: boolean;\n  /** @internal */\n  name = SERVER_HEARTBEAT_FAILED;\n\n  /** @internal */\n  constructor(connectionId: string, duration: number, failure: Error, awaited: boolean) {\n    this.connectionId = connectionId;\n    this.duration = duration;\n    this.failure = failure;\n    this.awaited = awaited;\n  }\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAcA;;;;IAKA,MAAa;IAWX,cAAA,GACA,YACE,UAAkB,EAClB,OAAe,EACf,mBAAsC,EACtC,cAAiC,CAAA;QAPnC,IAAA,CAAA,IAAI,GAAG,YAAA,0BAA0B;QAS/B,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,mBAAmB,GAAG;QAC3B,IAAI,CAAC,cAAc,GAAG;IACxB;;AAtBF,QAAA,6BAAA,GAAA;AAyBA;;;;IAKA,MAAa;IAQX,cAAA,GACA,YAAY,UAAkB,EAAE,OAAe,CAAA;QAJ/C,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,cAAc;QAInB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,OAAO,GAAG;IACjB;;AAZF,QAAA,kBAAA,GAAA;AAeA;;;;IAKA,MAAa;IAQX,cAAA,GACA,YAAY,UAAkB,EAAE,OAAe,CAAA;QAJ/C,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,aAAa;QAIlB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,OAAO,GAAG;IACjB;;AAZF,QAAA,iBAAA,GAAA;AAeA;;;;IAKA,MAAa;IAUX,cAAA,GACA,YACE,UAAkB,EAClB,mBAAwC,EACxC,cAAmC,CAAA;QAPrC,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,4BAA4B;QAQjC,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,mBAAmB,GAAG;QAC3B,IAAI,CAAC,cAAc,GAAG;IACxB;;AAnBF,QAAA,+BAAA,GAAA;AAsBA;;;;IAKA,MAAa;IAMX,cAAA,GACA,YAAY,UAAkB,CAAA;QAJ9B,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,gBAAgB;QAIrB,IAAI,CAAC,UAAU,GAAG;IACpB;;AATF,QAAA,oBAAA,GAAA;AAYA;;;;IAKA,MAAa;IAMX,cAAA,GACA,YAAY,UAAkB,CAAA;QAJ9B,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,eAAe;QAIpB,IAAI,CAAC,UAAU,GAAG;IACpB;;AATF,QAAA,mBAAA,GAAA;AAYA;;;;;;IAOA,MAAa;IAQX,cAAA,GACA,YAAY,YAAoB,EAAE,OAAgB,CAAA;QAJlD,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,wBAAwB;QAI7B,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,OAAO,GAAG;IACjB;;AAZF,QAAA,2BAAA,GAAA;AAeA;;;;IAKA,MAAa;IAYX,cAAA,GACA,YAAY,YAAoB,EAAE,QAAgB,EAAE,KAAsB,EAAE,OAAgB,CAAA;QAJ5F,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,0BAA0B;QAI/B,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAA;QACtB,IAAI,CAAC,OAAO,GAAG;IACjB;;AAlBF,QAAA,6BAAA,GAAA;AAqBA;;;;IAKA,MAAa;IAYX,cAAA,GACA,YAAY,YAAoB,EAAE,QAAgB,EAAE,OAAc,EAAE,OAAgB,CAAA;QAJpF,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,uBAAuB;QAI5B,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG;IACjB;;AAlBF,QAAA,0BAAA,GAAA"}},
    {"offset": {"line": 967, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 971, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/server.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { type AutoEncrypter } from '../client-side-encryption/auto_encrypter';\nimport { type CommandOptions, Connection } from '../cmap/connection';\nimport {\n  ConnectionPool,\n  type ConnectionPoolEvents,\n  type ConnectionPoolOptions\n} from '../cmap/connection_pool';\nimport { PoolClearedError } from '../cmap/errors';\nimport { type MongoDBResponseConstructor } from '../cmap/wire_protocol/responses';\nimport {\n  APM_EVENTS,\n  CLOSED,\n  CMAP_EVENTS,\n  CONNECT,\n  DESCRIPTION_RECEIVED,\n  ENDED,\n  HEARTBEAT_EVENTS,\n  SERVER_HEARTBEAT_FAILED,\n  SERVER_HEARTBEAT_STARTED,\n  SERVER_HEARTBEAT_SUCCEEDED\n} from '../constants';\nimport {\n  type AnyError,\n  isNodeShuttingDownError,\n  isSDAMUnrecoverableError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoErrorLabel,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  MongoServerClosedError,\n  type MongoServerError,\n  needsRetryableWriteLabel\n} from '../error';\nimport type { ServerApi } from '../mongo_client';\nimport { type Abortable, TypedEventEmitter } from '../mongo_types';\nimport type { GetMoreOptions } from '../operations/get_more';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { isTransactionCommand } from '../transactions';\nimport {\n  abortable,\n  type EventEmitterWithState,\n  makeStateMachine,\n  maxWireVersion,\n  type MongoDBNamespace,\n  noop,\n  squashError,\n  supportsRetryableWrites\n} from '../utils';\nimport { throwIfWriteConcernError } from '../write_concern';\nimport {\n  type ClusterTime,\n  STATE_CLOSED,\n  STATE_CLOSING,\n  STATE_CONNECTED,\n  STATE_CONNECTING,\n  TopologyType\n} from './common';\nimport type {\n  ServerHeartbeatFailedEvent,\n  ServerHeartbeatStartedEvent,\n  ServerHeartbeatSucceededEvent\n} from './events';\nimport { Monitor, type MonitorOptions } from './monitor';\nimport { compareTopologyVersion, ServerDescription } from './server_description';\nimport type { Topology } from './topology';\n\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\n\n/** @internal */\nexport type ServerOptions = Omit<ConnectionPoolOptions, 'id' | 'generation' | 'hostAddress'> &\n  MonitorOptions;\n\n/** @internal */\nexport interface ServerPrivate {\n  /** The server description for this server */\n  description: ServerDescription;\n  /** A copy of the options used to construct this instance */\n  options: ServerOptions;\n  /** The current state of the Server */\n  state: string;\n  /** MongoDB server API version */\n  serverApi?: ServerApi;\n  /** A count of the operations currently running against the server. */\n  operationCount: number;\n}\n\n/** @public */\nexport type ServerEvents = {\n  serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;\n  serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;\n  serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;\n  /** Top level MongoClient doesn't emit this so it is marked: @internal */\n  connect(server: Server): void;\n  descriptionReceived(description: ServerDescription): void;\n  closed(): void;\n  ended(): void;\n} & ConnectionPoolEvents &\n  EventEmitterWithState;\n\n/** @internal */\nexport type ServerCommandOptions = Omit<CommandOptions, 'timeoutContext' | 'socketTimeoutMS'> & {\n  timeoutContext: TimeoutContext;\n} & Abortable;\n\n/** @internal */\nexport class Server extends TypedEventEmitter<ServerEvents> {\n  /** @internal */\n  s: ServerPrivate;\n  /** @internal */\n  topology: Topology;\n  /** @internal */\n  pool: ConnectionPool;\n  serverApi?: ServerApi;\n  hello?: Document;\n  monitor: Monitor | null;\n\n  /** @event */\n  static readonly SERVER_HEARTBEAT_STARTED = SERVER_HEARTBEAT_STARTED;\n  /** @event */\n  static readonly SERVER_HEARTBEAT_SUCCEEDED = SERVER_HEARTBEAT_SUCCEEDED;\n  /** @event */\n  static readonly SERVER_HEARTBEAT_FAILED = SERVER_HEARTBEAT_FAILED;\n  /** @event */\n  static readonly CONNECT = CONNECT;\n  /** @event */\n  static readonly DESCRIPTION_RECEIVED = DESCRIPTION_RECEIVED;\n  /** @event */\n  static readonly CLOSED = CLOSED;\n  /** @event */\n  static readonly ENDED = ENDED;\n\n  /**\n   * Create a server\n   */\n  constructor(topology: Topology, description: ServerDescription, options: ServerOptions) {\n    super();\n    this.on('error', noop);\n\n    this.serverApi = options.serverApi;\n\n    const poolOptions = { hostAddress: description.hostAddress, ...options };\n\n    this.topology = topology;\n    this.pool = new ConnectionPool(this, poolOptions);\n\n    this.s = {\n      description,\n      options,\n      state: STATE_CLOSED,\n      operationCount: 0\n    };\n\n    for (const event of [...CMAP_EVENTS, ...APM_EVENTS]) {\n      this.pool.on(event, (e: any) => this.emit(event, e));\n    }\n\n    this.pool.on(Connection.CLUSTER_TIME_RECEIVED, (clusterTime: ClusterTime) => {\n      this.clusterTime = clusterTime;\n    });\n\n    if (this.loadBalanced) {\n      this.monitor = null;\n      // monitoring is disabled in load balancing mode\n      return;\n    }\n\n    // create the monitor\n    this.monitor = new Monitor(this, this.s.options);\n\n    for (const event of HEARTBEAT_EVENTS) {\n      this.monitor.on(event, (e: any) => this.emit(event, e));\n    }\n\n    this.monitor.on('resetServer', (error: MongoServerError) => markServerUnknown(this, error));\n    this.monitor.on(Server.SERVER_HEARTBEAT_SUCCEEDED, (event: ServerHeartbeatSucceededEvent) => {\n      this.emit(\n        Server.DESCRIPTION_RECEIVED,\n        new ServerDescription(this.description.hostAddress, event.reply, {\n          roundTripTime: this.monitor?.roundTripTime,\n          minRoundTripTime: this.monitor?.minRoundTripTime\n        })\n      );\n\n      if (this.s.state === STATE_CONNECTING) {\n        stateTransition(this, STATE_CONNECTED);\n        this.emit(Server.CONNECT, this);\n      }\n    });\n  }\n\n  get clusterTime(): ClusterTime | undefined {\n    return this.topology.clusterTime;\n  }\n\n  set clusterTime(clusterTime: ClusterTime | undefined) {\n    this.topology.clusterTime = clusterTime;\n  }\n\n  get description(): ServerDescription {\n    return this.s.description;\n  }\n\n  get name(): string {\n    return this.s.description.address;\n  }\n\n  get autoEncrypter(): AutoEncrypter | undefined {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n    return;\n  }\n\n  get loadBalanced(): boolean {\n    return this.topology.description.type === TopologyType.LoadBalanced;\n  }\n\n  /**\n   * Initiate server connect\n   */\n  connect(): void {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    stateTransition(this, STATE_CONNECTING);\n\n    // If in load balancer mode we automatically set the server to\n    // a load balancer. It never transitions out of this state and\n    // has no monitor.\n    if (!this.loadBalanced) {\n      this.monitor?.connect();\n    } else {\n      stateTransition(this, STATE_CONNECTED);\n      this.emit(Server.CONNECT, this);\n    }\n  }\n\n  closeCheckedOutConnections() {\n    return this.pool.closeCheckedOutConnections();\n  }\n\n  /** Destroy the server connection */\n  close(): void {\n    if (this.s.state === STATE_CLOSED) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n\n    if (!this.loadBalanced) {\n      this.monitor?.close();\n    }\n\n    this.pool.close();\n    stateTransition(this, STATE_CLOSED);\n    this.emit('closed');\n  }\n\n  /**\n   * Immediately schedule monitoring of this server. If there already an attempt being made\n   * this will be a no-op.\n   */\n  requestCheck(): void {\n    if (!this.loadBalanced) {\n      this.monitor?.requestCheck();\n    }\n  }\n\n  public async command<T extends MongoDBResponseConstructor>(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: ServerCommandOptions,\n    responseType: T | undefined\n  ): Promise<typeof responseType extends undefined ? Document : InstanceType<T>>;\n\n  public async command(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: ServerCommandOptions\n  ): Promise<Document>;\n\n  public async command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    { ...options }: ServerCommandOptions,\n    responseType?: MongoDBResponseConstructor\n  ): Promise<Document> {\n    if (ns.db == null || typeof ns === 'string') {\n      throw new MongoInvalidArgumentError('Namespace must not be a string');\n    }\n\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      throw new MongoServerClosedError();\n    }\n\n    options.directConnection = this.topology.s.options.directConnection;\n\n    // There are cases where we need to flag the read preference not to get sent in\n    // the command, such as pre-5.0 servers attempting to perform an aggregate write\n    // with a non-primary read preference. In this case the effective read preference\n    // (primary) is not the same as the provided and must be removed completely.\n    if (options.omitReadPreference) {\n      delete options.readPreference;\n    }\n\n    if (this.description.iscryptd) {\n      options.omitMaxTimeMS = true;\n    }\n\n    const session = options.session;\n    let conn = session?.pinnedConnection;\n\n    this.incrementOperationCount();\n    if (conn == null) {\n      try {\n        conn = await this.pool.checkOut(options);\n        if (this.loadBalanced && isPinnableCommand(cmd, session)) {\n          session?.pin(conn);\n        }\n      } catch (checkoutError) {\n        this.decrementOperationCount();\n        if (!(checkoutError instanceof PoolClearedError)) this.handleError(checkoutError);\n        throw checkoutError;\n      }\n    }\n\n    let reauthPromise: Promise<void> | null = null;\n\n    try {\n      try {\n        const res = await conn.command(ns, cmd, options, responseType);\n        throwIfWriteConcernError(res);\n        return res;\n      } catch (commandError) {\n        throw this.decorateCommandError(conn, cmd, options, commandError);\n      }\n    } catch (operationError) {\n      if (\n        operationError instanceof MongoError &&\n        operationError.code === MONGODB_ERROR_CODES.Reauthenticate\n      ) {\n        reauthPromise = this.pool.reauthenticate(conn);\n        reauthPromise.then(undefined, error => {\n          reauthPromise = null;\n          squashError(error);\n        });\n\n        await abortable(reauthPromise, options);\n        reauthPromise = null; // only reachable if reauth succeeds\n\n        try {\n          const res = await conn.command(ns, cmd, options, responseType);\n          throwIfWriteConcernError(res);\n          return res;\n        } catch (commandError) {\n          throw this.decorateCommandError(conn, cmd, options, commandError);\n        }\n      } else {\n        throw operationError;\n      }\n    } finally {\n      this.decrementOperationCount();\n      if (session?.pinnedConnection !== conn) {\n        if (reauthPromise != null) {\n          // The reauth promise only exists if it hasn't thrown.\n          const checkBackIn = () => {\n            this.pool.checkIn(conn);\n          };\n          void reauthPromise.then(checkBackIn, checkBackIn);\n        } else {\n          this.pool.checkIn(conn);\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle SDAM error\n   * @internal\n   */\n  handleError(error: AnyError, connection?: Connection) {\n    if (!(error instanceof MongoError)) {\n      return;\n    }\n\n    const isStaleError =\n      error.connectionGeneration && error.connectionGeneration < this.pool.generation;\n    if (isStaleError) {\n      return;\n    }\n\n    const isNetworkNonTimeoutError =\n      error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError);\n    const isNetworkTimeoutBeforeHandshakeError =\n      error instanceof MongoNetworkError && error.beforeHandshake;\n    const isAuthHandshakeError = error.hasErrorLabel(MongoErrorLabel.HandshakeError);\n    if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {\n      // In load balanced mode we never mark the server as unknown and always\n      // clear for the specific service id.\n      if (!this.loadBalanced) {\n        error.addErrorLabel(MongoErrorLabel.ResetPool);\n        markServerUnknown(this, error);\n      } else if (connection) {\n        this.pool.clear({ serviceId: connection.serviceId });\n      }\n    } else {\n      if (isSDAMUnrecoverableError(error)) {\n        if (shouldHandleStateChangeError(this, error)) {\n          const shouldClearPool = maxWireVersion(this) <= 7 || isNodeShuttingDownError(error);\n          if (this.loadBalanced && connection && shouldClearPool) {\n            this.pool.clear({ serviceId: connection.serviceId });\n          }\n\n          if (!this.loadBalanced) {\n            if (shouldClearPool) {\n              error.addErrorLabel(MongoErrorLabel.ResetPool);\n            }\n            markServerUnknown(this, error);\n            process.nextTick(() => this.requestCheck());\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Ensure that error is properly decorated and internal state is updated before throwing\n   * @internal\n   */\n  private decorateCommandError(\n    connection: Connection,\n    cmd: Document,\n    options: CommandOptions | GetMoreOptions | undefined,\n    error: unknown\n  ): Error {\n    if (typeof error !== 'object' || error == null || !('name' in error)) {\n      throw new MongoRuntimeError('An unexpected error type: ' + typeof error);\n    }\n\n    if (error.name === 'AbortError' && 'cause' in error && error.cause instanceof MongoError) {\n      error = error.cause;\n    }\n\n    if (!(error instanceof MongoError)) {\n      // Node.js or some other error we have not special handling for\n      return error as Error;\n    }\n\n    if (connectionIsStale(this.pool, connection)) {\n      return error;\n    }\n\n    const session = options?.session;\n    if (error instanceof MongoNetworkError) {\n      if (session && !session.hasEnded && session.serverSession) {\n        session.serverSession.isDirty = true;\n      }\n\n      // inActiveTransaction check handles commit and abort.\n      if (\n        inActiveTransaction(session, cmd) &&\n        !error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)\n      ) {\n        error.addErrorLabel(MongoErrorLabel.TransientTransactionError);\n      }\n\n      if (\n        (isRetryableWritesEnabled(this.topology) || isTransactionCommand(cmd)) &&\n        supportsRetryableWrites(this) &&\n        !inActiveTransaction(session, cmd)\n      ) {\n        error.addErrorLabel(MongoErrorLabel.RetryableWriteError);\n      }\n    } else {\n      if (\n        (isRetryableWritesEnabled(this.topology) || isTransactionCommand(cmd)) &&\n        needsRetryableWriteLabel(error, maxWireVersion(this), this.description.type) &&\n        !inActiveTransaction(session, cmd)\n      ) {\n        error.addErrorLabel(MongoErrorLabel.RetryableWriteError);\n      }\n    }\n\n    if (\n      session &&\n      session.isPinned &&\n      error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)\n    ) {\n      session.unpin({ force: true });\n    }\n\n    this.handleError(error, connection);\n\n    return error;\n  }\n\n  /**\n   * Decrement the operation count, returning the new count.\n   */\n  private decrementOperationCount(): number {\n    return (this.s.operationCount -= 1);\n  }\n\n  /**\n   * Increment the operation count, returning the new count.\n   */\n  private incrementOperationCount(): number {\n    return (this.s.operationCount += 1);\n  }\n}\n\nfunction markServerUnknown(server: Server, error?: MongoError) {\n  // Load balancer servers can never be marked unknown.\n  if (server.loadBalanced) {\n    return;\n  }\n\n  if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {\n    server.monitor?.reset();\n  }\n\n  server.emit(\n    Server.DESCRIPTION_RECEIVED,\n    new ServerDescription(server.description.hostAddress, undefined, { error })\n  );\n}\n\nfunction isPinnableCommand(cmd: Document, session?: ClientSession): boolean {\n  if (session) {\n    return (\n      session.inTransaction() ||\n      (session.transaction.isCommitted && 'commitTransaction' in cmd) ||\n      'aggregate' in cmd ||\n      'find' in cmd ||\n      'getMore' in cmd ||\n      'listCollections' in cmd ||\n      'listIndexes' in cmd ||\n      'bulkWrite' in cmd\n    );\n  }\n\n  return false;\n}\n\nfunction connectionIsStale(pool: ConnectionPool, connection: Connection) {\n  if (connection.serviceId) {\n    return (\n      connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString())\n    );\n  }\n\n  return connection.generation !== pool.generation;\n}\n\nfunction shouldHandleStateChangeError(server: Server, err: MongoError) {\n  const etv = err.topologyVersion;\n  const stv = server.description.topologyVersion;\n  return compareTopologyVersion(stv, etv) < 0;\n}\n\nfunction inActiveTransaction(session: ClientSession | undefined, cmd: Document) {\n  return session && session.inTransaction() && !isTransactionCommand(cmd);\n}\n\n/** this checks the retryWrites option passed down from the client options, it\n * does not check if the server supports retryable writes */\nfunction isRetryableWritesEnabled(topology: Topology) {\n  return topology.s.options.retryWrites !== false;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1338, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1342, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/monitor.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\n\nimport { type Document, Long } from '../bson';\nimport { connect, makeConnection, makeSocket, performInitialHandshake } from '../cmap/connect';\nimport type { Connection, ConnectionOptions } from '../cmap/connection';\nimport { getFAASEnv } from '../cmap/handshake/client_metadata';\nimport { LEGACY_HELLO_COMMAND } from '../constants';\nimport { MongoError, MongoErrorLabel, MongoNetworkTimeoutError } from '../error';\nimport { MongoLoggableComponent } from '../mongo_logger';\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport {\n  calculateDurationInMs,\n  type Callback,\n  type EventEmitterWithState,\n  makeStateMachine,\n  noop,\n  now,\n  ns\n} from '../utils';\nimport { ServerType, STATE_CLOSED, STATE_CLOSING } from './common';\nimport {\n  ServerHeartbeatFailedEvent,\n  ServerHeartbeatStartedEvent,\n  ServerHeartbeatSucceededEvent\n} from './events';\nimport { Server } from './server';\nimport type { TopologyVersion } from './server_description';\n\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\n\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor: Monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\n/** @public */\nexport const ServerMonitoringMode = Object.freeze({\n  auto: 'auto',\n  poll: 'poll',\n  stream: 'stream'\n} as const);\n\n/** @public */\nexport type ServerMonitoringMode = (typeof ServerMonitoringMode)[keyof typeof ServerMonitoringMode];\n\n/** @internal */\nexport interface MonitorPrivate {\n  state: string;\n}\n\n/** @public */\nexport interface MonitorOptions\n  extends Omit<ConnectionOptions, 'id' | 'generation' | 'hostAddress'> {\n  connectTimeoutMS: number;\n  heartbeatFrequencyMS: number;\n  minHeartbeatFrequencyMS: number;\n  serverMonitoringMode: ServerMonitoringMode;\n}\n\n/** @public */\nexport type MonitorEvents = {\n  serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;\n  serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;\n  serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;\n  resetServer(error?: MongoError): void;\n  resetConnectionPool(): void;\n  close(): void;\n} & EventEmitterWithState;\n\n/** @internal */\nexport class Monitor extends TypedEventEmitter<MonitorEvents> {\n  /** @internal */\n  s: MonitorPrivate;\n  address: string;\n  options: Readonly<\n    Pick<\n      MonitorOptions,\n      | 'connectTimeoutMS'\n      | 'heartbeatFrequencyMS'\n      | 'minHeartbeatFrequencyMS'\n      | 'serverMonitoringMode'\n    >\n  >;\n  connectOptions: ConnectionOptions;\n  isRunningInFaasEnv: boolean;\n  server: Server;\n  connection: Connection | null;\n  cancellationToken: CancellationToken;\n  /** @internal */\n  monitorId?: MonitorInterval;\n  rttPinger?: RTTPinger;\n  /** @internal */\n  override component = MongoLoggableComponent.TOPOLOGY;\n  /** @internal */\n  private rttSampler: RTTSampler;\n\n  constructor(server: Server, options: MonitorOptions) {\n    super();\n    this.on('error', noop);\n\n    this.server = server;\n    this.connection = null;\n    this.cancellationToken = new CancellationToken();\n    this.cancellationToken.setMaxListeners(Infinity);\n    this.monitorId = undefined;\n    this.s = {\n      state: STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: options.connectTimeoutMS ?? 10000,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,\n      serverMonitoringMode: options.serverMonitoringMode\n    });\n    this.isRunningInFaasEnv = getFAASEnv() != null;\n    this.mongoLogger = this.server.topology.client?.mongoLogger;\n    this.rttSampler = new RTTSampler(10);\n\n    const cancellationToken = this.cancellationToken;\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = {\n      id: '<monitor>' as const,\n      generation: server.pool.generation,\n      cancellationToken,\n      hostAddress: server.description.hostAddress,\n      ...options,\n      // force BSON serialization options\n      raw: false,\n      useBigInt64: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    };\n\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect(): void {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this.monitorId = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck(): void {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this.monitorId?.wake();\n  }\n\n  reset(): void {\n    const topologyVersion = this.server.description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this.monitorId = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\n    });\n  }\n\n  close(): void {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // close monitor\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n\n  get roundTripTime(): number {\n    return this.rttSampler.average();\n  }\n\n  get minRoundTripTime(): number {\n    return this.rttSampler.min();\n  }\n\n  get latestRtt(): number | null {\n    return this.rttSampler.last;\n  }\n\n  addRttSample(rtt: number) {\n    this.rttSampler.addSample(rtt);\n  }\n\n  clearRttSamples() {\n    this.rttSampler.clear();\n  }\n}\n\nfunction resetMonitorState(monitor: Monitor) {\n  monitor.monitorId?.stop();\n  monitor.monitorId = undefined;\n\n  monitor.rttPinger?.close();\n  monitor.rttPinger = undefined;\n\n  monitor.cancellationToken.emit('cancel');\n\n  monitor.connection?.destroy();\n  monitor.connection = null;\n\n  monitor.clearRttSamples();\n}\n\nfunction useStreamingProtocol(monitor: Monitor, topologyVersion: TopologyVersion | null): boolean {\n  // If we have no topology version we always poll no matter\n  // what the user provided, since the server does not support\n  // the streaming protocol.\n  if (topologyVersion == null) return false;\n\n  const serverMonitoringMode = monitor.options.serverMonitoringMode;\n  if (serverMonitoringMode === ServerMonitoringMode.poll) return false;\n  if (serverMonitoringMode === ServerMonitoringMode.stream) return true;\n\n  // If we are in auto mode, we need to figure out if we're in a FaaS\n  // environment or not and choose the appropriate mode.\n  if (monitor.isRunningInFaasEnv) return false;\n  return true;\n}\n\nfunction checkServer(monitor: Monitor, callback: Callback<Document | null>) {\n  let start: number;\n  let awaited: boolean;\n  const topologyVersion = monitor.server.description.topologyVersion;\n  const isAwaitable = useStreamingProtocol(monitor, topologyVersion);\n  monitor.emitAndLogHeartbeat(\n    Server.SERVER_HEARTBEAT_STARTED,\n    monitor.server.topology.s.id,\n    undefined,\n    new ServerHeartbeatStartedEvent(monitor.address, isAwaitable)\n  );\n\n  function onHeartbeatFailed(err: Error) {\n    monitor.connection?.destroy();\n    monitor.connection = null;\n    monitor.emitAndLogHeartbeat(\n      Server.SERVER_HEARTBEAT_FAILED,\n      monitor.server.topology.s.id,\n      undefined,\n      new ServerHeartbeatFailedEvent(monitor.address, calculateDurationInMs(start), err, awaited)\n    );\n\n    const error = !(err instanceof MongoError)\n      ? new MongoError(MongoError.buildErrorMessage(err), { cause: err })\n      : err;\n    error.addErrorLabel(MongoErrorLabel.ResetPool);\n    if (error instanceof MongoNetworkTimeoutError) {\n      error.addErrorLabel(MongoErrorLabel.InterruptInUseConnections);\n    }\n\n    monitor.emit('resetServer', error);\n    callback(err);\n  }\n\n  function onHeartbeatSucceeded(hello: Document) {\n    if (!('isWritablePrimary' in hello)) {\n      // Provide hello-style response document.\n      hello.isWritablePrimary = hello[LEGACY_HELLO_COMMAND];\n    }\n\n    // NOTE: here we use the latestRtt as this measurement corresponds with the value\n    // obtained for this successful heartbeat, if there is no latestRtt, then we calculate the\n    // duration\n    const duration =\n      isAwaitable && monitor.rttPinger\n        ? (monitor.rttPinger.latestRtt ?? calculateDurationInMs(start))\n        : calculateDurationInMs(start);\n\n    monitor.addRttSample(duration);\n\n    monitor.emitAndLogHeartbeat(\n      Server.SERVER_HEARTBEAT_SUCCEEDED,\n      monitor.server.topology.s.id,\n      hello.connectionId,\n      new ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable)\n    );\n\n    if (isAwaitable) {\n      // If we are using the streaming protocol then we immediately issue another 'started'\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      monitor.emitAndLogHeartbeat(\n        Server.SERVER_HEARTBEAT_STARTED,\n        monitor.server.topology.s.id,\n        undefined,\n        new ServerHeartbeatStartedEvent(monitor.address, true)\n      );\n      // We have not actually sent an outgoing handshake, but when we get the next response we\n      // want the duration to reflect the time since we last heard from the server\n      start = now();\n    } else {\n      monitor.rttPinger?.close();\n      monitor.rttPinger = undefined;\n\n      callback(undefined, hello);\n    }\n  }\n\n  const { connection } = monitor;\n  if (connection && !connection.closed) {\n    const { serverApi, helloOk } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n\n    const cmd = {\n      [serverApi?.version || helloOk ? 'hello' : LEGACY_HELLO_COMMAND]: 1,\n      ...(isAwaitable && topologyVersion\n        ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\n        : {})\n    };\n\n    const options = isAwaitable\n      ? {\n          socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n          exhaustAllowed: true\n        }\n      : { socketTimeoutMS: connectTimeoutMS };\n\n    if (isAwaitable && monitor.rttPinger == null) {\n      monitor.rttPinger = new RTTPinger(monitor);\n    }\n\n    // Record new start time before sending handshake\n    start = now();\n\n    if (isAwaitable) {\n      awaited = true;\n      return connection.exhaustCommand(ns('admin.$cmd'), cmd, options, (error, hello) => {\n        if (error) return onHeartbeatFailed(error);\n        return onHeartbeatSucceeded(hello);\n      });\n    }\n\n    awaited = false;\n    connection\n      .command(ns('admin.$cmd'), cmd, options)\n      .then(onHeartbeatSucceeded, onHeartbeatFailed);\n\n    return;\n  }\n\n  // connecting does an implicit `hello`\n  (async () => {\n    const socket = await makeSocket(monitor.connectOptions);\n    const connection = makeConnection(monitor.connectOptions, socket);\n    // The start time is after socket creation but before the handshake\n    start = now();\n    try {\n      await performInitialHandshake(connection, monitor.connectOptions);\n      return connection;\n    } catch (error) {\n      connection.destroy();\n      throw error;\n    }\n  })().then(\n    connection => {\n      if (isInCloseState(monitor)) {\n        connection.destroy();\n        return;\n      }\n      const duration = calculateDurationInMs(start);\n      monitor.addRttSample(duration);\n\n      monitor.connection = connection;\n      monitor.emitAndLogHeartbeat(\n        Server.SERVER_HEARTBEAT_SUCCEEDED,\n        monitor.server.topology.s.id,\n        connection.hello?.connectionId,\n        new ServerHeartbeatSucceededEvent(\n          monitor.address,\n          duration,\n          connection.hello,\n          useStreamingProtocol(monitor, connection.hello?.topologyVersion)\n        )\n      );\n\n      callback(undefined, connection.hello);\n    },\n    error => {\n      monitor.connection = null;\n      awaited = false;\n      onHeartbeatFailed(error);\n    }\n  );\n}\n\nfunction monitorServer(monitor: Monitor) {\n  return (callback: Callback) => {\n    if (monitor.s.state === STATE_MONITORING) {\n      process.nextTick(callback);\n      return;\n    }\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    checkServer(monitor, (err, hello) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor.server.description.type === ServerType.Unknown) {\n          return done();\n        }\n      }\n\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (useStreamingProtocol(monitor, hello?.topologyVersion)) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor.monitorId?.wake();\n          }\n        }, 0);\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv: TopologyVersion) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    counter: Long.isLong(tv.counter) ? tv.counter : Long.fromNumber(tv.counter)\n  };\n}\n\n/** @internal */\nexport interface RTTPingerOptions extends ConnectionOptions {\n  heartbeatFrequencyMS: number;\n}\n\n/** @internal */\nexport class RTTPinger {\n  connection?: Connection;\n  /** @internal */\n  cancellationToken: CancellationToken;\n  /** @internal */\n  monitorId: NodeJS.Timeout;\n  /** @internal */\n  monitor: Monitor;\n  closed: boolean;\n  /** @internal */\n  latestRtt?: number;\n\n  constructor(monitor: Monitor) {\n    this.connection = undefined;\n    this.cancellationToken = monitor.cancellationToken;\n    this.closed = false;\n    this.monitor = monitor;\n    this.latestRtt = monitor.latestRtt ?? undefined;\n\n    const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;\n    this.monitorId = setTimeout(() => this.measureRoundTripTime(), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime(): number {\n    return this.monitor.roundTripTime;\n  }\n\n  get minRoundTripTime(): number {\n    return this.monitor.minRoundTripTime;\n  }\n\n  close(): void {\n    this.closed = true;\n    clearTimeout(this.monitorId);\n\n    this.connection?.destroy();\n    this.connection = undefined;\n  }\n\n  private measureAndReschedule(start: number, conn?: Connection) {\n    if (this.closed) {\n      conn?.destroy();\n      return;\n    }\n\n    if (this.connection == null) {\n      this.connection = conn;\n    }\n\n    this.latestRtt = calculateDurationInMs(start);\n    this.monitorId = setTimeout(\n      () => this.measureRoundTripTime(),\n      this.monitor.options.heartbeatFrequencyMS\n    );\n  }\n\n  private measureRoundTripTime() {\n    const start = now();\n\n    if (this.closed) {\n      return;\n    }\n\n    const connection = this.connection;\n    if (connection == null) {\n      connect(this.monitor.connectOptions).then(\n        connection => {\n          this.measureAndReschedule(start, connection);\n        },\n        () => {\n          this.connection = undefined;\n        }\n      );\n      return;\n    }\n\n    const commandName =\n      connection.serverApi?.version || connection.helloOk ? 'hello' : LEGACY_HELLO_COMMAND;\n\n    connection.command(ns('admin.$cmd'), { [commandName]: 1 }, undefined).then(\n      () => this.measureAndReschedule(start),\n      () => {\n        this.connection?.destroy();\n        this.connection = undefined;\n        return;\n      }\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport interface MonitorIntervalOptions {\n  /** The interval to execute a method on */\n  heartbeatFrequencyMS: number;\n  /** A minimum interval that must elapse before the method is called */\n  minHeartbeatFrequencyMS: number;\n  /** Whether the method should be called immediately when the interval is started  */\n  immediate: boolean;\n}\n\n/**\n * @internal\n */\nexport class MonitorInterval {\n  fn: (callback: Callback) => void;\n  timerId: NodeJS.Timeout | undefined;\n  lastExecutionEnded: number;\n  isExpeditedCallToFnScheduled = false;\n  stopped = false;\n  isExecutionInProgress = false;\n  hasExecutedOnce = false;\n\n  heartbeatFrequencyMS: number;\n  minHeartbeatFrequencyMS: number;\n\n  constructor(fn: (callback: Callback) => void, options: Partial<MonitorIntervalOptions> = {}) {\n    this.fn = fn;\n    this.lastExecutionEnded = -Infinity;\n\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;\n    this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;\n\n    if (options.immediate) {\n      this._executeAndReschedule();\n    } else {\n      this._reschedule(undefined);\n    }\n  }\n\n  wake() {\n    const currentTime = now();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n\n    // TODO(NODE-4674): Add error handling and logging to the monitor\n    if (timeSinceLastCall < 0) {\n      return this._executeAndReschedule();\n    }\n\n    if (this.isExecutionInProgress) {\n      return;\n    }\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (this.isExpeditedCallToFnScheduled) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {\n      this.isExpeditedCallToFnScheduled = true;\n      this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);\n      return;\n    }\n\n    this._executeAndReschedule();\n  }\n\n  stop() {\n    this.stopped = true;\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n      this.timerId = undefined;\n    }\n\n    this.lastExecutionEnded = -Infinity;\n    this.isExpeditedCallToFnScheduled = false;\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toJSON() {\n    const currentTime = now();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n    return {\n      timerId: this.timerId != null ? 'set' : 'cleared',\n      lastCallTime: this.lastExecutionEnded,\n      isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,\n      stopped: this.stopped,\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,\n      currentTime,\n      timeSinceLastCall\n    };\n  }\n\n  private _reschedule(ms?: number) {\n    if (this.stopped) return;\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n    }\n\n    this.timerId = setTimeout(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\n  }\n\n  private _executeAndReschedule = () => {\n    if (this.stopped) return;\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n    }\n\n    this.isExpeditedCallToFnScheduled = false;\n    this.isExecutionInProgress = true;\n\n    this.fn(() => {\n      this.lastExecutionEnded = now();\n      this.isExecutionInProgress = false;\n      this._reschedule(this.heartbeatFrequencyMS);\n    });\n  };\n}\n\n/** @internal\n * This class implements the RTT sampling logic specified for [CSOT](https://github.com/mongodb/specifications/blob/bbb335e60cd7ea1e0f7cd9a9443cb95fc9d3b64d/source/client-side-operations-timeout/client-side-operations-timeout.md#drivers-use-minimum-rtt-to-short-circuit-operations)\n *\n * This is implemented as a [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) keeping\n * the most recent `windowSize` samples\n * */\nexport class RTTSampler {\n  /** Index of the next slot to be overwritten */\n  private writeIndex: number;\n  private length: number;\n  private rttSamples: Float64Array;\n\n  constructor(windowSize = 10) {\n    this.rttSamples = new Float64Array(windowSize);\n    this.length = 0;\n    this.writeIndex = 0;\n  }\n\n  /**\n   * Adds an rtt sample to the end of the circular buffer\n   * When `windowSize` samples have been collected, `addSample` overwrites the least recently added\n   * sample\n   */\n  addSample(sample: number) {\n    this.rttSamples[this.writeIndex++] = sample;\n    if (this.length < this.rttSamples.length) {\n      this.length++;\n    }\n\n    this.writeIndex %= this.rttSamples.length;\n  }\n\n  /**\n   * When \\< 2 samples have been collected, returns 0\n   * Otherwise computes the minimum value samples contained in the buffer\n   */\n  min(): number {\n    if (this.length < 2) return 0;\n    let min = this.rttSamples[0];\n    for (let i = 1; i < this.length; i++) {\n      if (this.rttSamples[i] < min) min = this.rttSamples[i];\n    }\n\n    return min;\n  }\n\n  /**\n   * Returns mean of samples contained in the buffer\n   */\n  average(): number {\n    if (this.length === 0) return 0;\n    let sum = 0;\n    for (let i = 0; i < this.length; i++) {\n      sum += this.rttSamples[i];\n    }\n\n    return sum / this.length;\n  }\n\n  /**\n   * Returns most recently inserted element in the buffer\n   * Returns null if the buffer is empty\n   * */\n  get last(): number | null {\n    if (this.length === 0) return null;\n    return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];\n  }\n\n  /**\n   * Clear the buffer\n   * NOTE: this does not overwrite the data held in the internal array, just the pointers into\n   * this array\n   */\n  clear() {\n    this.length = 0;\n    this.writeIndex = 0;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1880, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1884, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/server_selection_events.ts"],"sourcesContent":["import { HostAddress } from '.././utils';\nimport {\n  SERVER_SELECTION_FAILED,\n  SERVER_SELECTION_STARTED,\n  SERVER_SELECTION_SUCCEEDED,\n  WAITING_FOR_SUITABLE_SERVER\n} from '../constants';\nimport { type ReadPreference } from '../read_preference';\nimport { type ServerSelector } from './server_selection';\nimport type { TopologyDescription } from './topology_description';\n\n/**\n * The base export class for all logs published from server selection\n * @internal\n * @category Log Type\n */\nexport abstract class ServerSelectionEvent {\n  /** String representation of the selector being used to select the server.\n   *  Defaults to 'custom selector' for application-provided custom selector case.\n   */\n  selector: string | ReadPreference | ServerSelector;\n  /** The name of the operation for which a server is being selected.  */\n  operation: string;\n  /** \tThe current topology description.  */\n  topologyDescription: TopologyDescription;\n\n  /** @internal */\n  abstract name:\n    | typeof SERVER_SELECTION_STARTED\n    | typeof SERVER_SELECTION_SUCCEEDED\n    | typeof SERVER_SELECTION_FAILED\n    | typeof WAITING_FOR_SUITABLE_SERVER;\n\n  abstract message: string;\n\n  /** @internal */\n  constructor(\n    selector: string | ReadPreference | ServerSelector,\n    topologyDescription: TopologyDescription,\n    operation: string\n  ) {\n    this.selector = selector;\n    this.operation = operation;\n    this.topologyDescription = topologyDescription;\n  }\n}\n\n/**\n * An event published when server selection starts\n * @internal\n * @category Event\n */\nexport class ServerSelectionStartedEvent extends ServerSelectionEvent {\n  /** @internal */\n  name = SERVER_SELECTION_STARTED;\n  message = 'Server selection started';\n\n  /** @internal */\n  constructor(\n    selector: string | ReadPreference | ServerSelector,\n    topologyDescription: TopologyDescription,\n    operation: string\n  ) {\n    super(selector, topologyDescription, operation);\n  }\n}\n\n/**\n * An event published when a server selection fails\n * @internal\n * @category Event\n */\nexport class ServerSelectionFailedEvent extends ServerSelectionEvent {\n  /** @internal */\n  name = SERVER_SELECTION_FAILED;\n  message = 'Server selection failed';\n  /** Representation of the error the driver will throw regarding server selection failing. */\n  failure: Error;\n\n  /** @internal */\n  constructor(\n    selector: string | ReadPreference | ServerSelector,\n    topologyDescription: TopologyDescription,\n    error: Error,\n    operation: string\n  ) {\n    super(selector, topologyDescription, operation);\n    this.failure = error;\n  }\n}\n\n/**\n * An event published when server selection succeeds\n * @internal\n * @category Event\n */\nexport class ServerSelectionSucceededEvent extends ServerSelectionEvent {\n  /** @internal */\n  name = SERVER_SELECTION_SUCCEEDED;\n  message = 'Server selection succeeded';\n  /** \tThe hostname, IP address, or Unix domain socket path for the selected server. */\n  serverHost: string;\n  /** The port for the selected server. Optional; not present for Unix domain sockets. When the user does not specify a port and the default (27017) is used, the driver SHOULD include it here. */\n  serverPort: number | undefined;\n\n  /** @internal */\n  constructor(\n    selector: string | ReadPreference | ServerSelector,\n    topologyDescription: TopologyDescription,\n    address: string,\n    operation: string\n  ) {\n    super(selector, topologyDescription, operation);\n    const { host, port } = HostAddress.fromString(address).toHostPort();\n    this.serverHost = host;\n    this.serverPort = port;\n  }\n}\n\n/**\n * An event published when server selection is waiting for a suitable server to become available\n * @internal\n * @category Event\n */\nexport class WaitingForSuitableServerEvent extends ServerSelectionEvent {\n  /** @internal */\n  name = WAITING_FOR_SUITABLE_SERVER;\n  message = 'Waiting for suitable server to become available';\n  /** The remaining time left until server selection will time out. */\n  remainingTimeMS: number;\n\n  /** @internal */\n  constructor(\n    selector: string | ReadPreference | ServerSelector,\n    topologyDescription: TopologyDescription,\n    remainingTimeMS: number,\n    operation: string\n  ) {\n    super(selector, topologyDescription, operation);\n    this.remainingTimeMS = remainingTimeMS;\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AAUA;;;;IAKA,MAAsB;IAmBpB,cAAA,GACA,YACE,QAAkD,EAClD,mBAAwC,EACxC,SAAiB,CAAA;QAEjB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,mBAAmB,GAAG;IAC7B;;AA5BF,QAAA,oBAAA,GAAA;AA+BA;;;;IAKA,MAAa,oCAAoC;IAK/C,cAAA,GACA,YACE,QAAkD,EAClD,mBAAwC,EACxC,SAAiB,CAAA;QAEjB,KAAK,CAAC,UAAU,qBAAqB;QAVvC,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,wBAAwB;QAC/B,IAAA,CAAA,OAAO,GAAG;IASV;;AAZF,QAAA,2BAAA,GAAA;AAeA;;;;IAKA,MAAa,mCAAmC;IAO9C,cAAA,GACA,YACE,QAAkD,EAClD,mBAAwC,EACxC,KAAY,EACZ,SAAiB,CAAA;QAEjB,KAAK,CAAC,UAAU,qBAAqB;QAbvC,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,uBAAuB;QAC9B,IAAA,CAAA,OAAO,GAAG;QAYR,IAAI,CAAC,OAAO,GAAG;IACjB;;AAhBF,QAAA,0BAAA,GAAA;AAmBA;;;;IAKA,MAAa,sCAAsC;IASjD,cAAA,GACA,YACE,QAAkD,EAClD,mBAAwC,EACxC,OAAe,EACf,SAAiB,CAAA;QAEjB,KAAK,CAAC,UAAU,qBAAqB;QAfvC,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,0BAA0B;QACjC,IAAA,CAAA,OAAO,GAAG;QAcR,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,QAAA,WAAW,CAAC,UAAU,CAAC,SAAS,UAAU;QACjE,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,UAAU,GAAG;IACpB;;AApBF,QAAA,6BAAA,GAAA;AAuBA;;;;IAKA,MAAa,sCAAsC;IAOjD,cAAA,GACA,YACE,QAAkD,EAClD,mBAAwC,EACxC,eAAuB,EACvB,SAAiB,CAAA;QAEjB,KAAK,CAAC,UAAU,qBAAqB;QAbvC,cAAA,GACA,IAAA,CAAA,IAAI,GAAG,YAAA,2BAA2B;QAClC,IAAA,CAAA,OAAO,GAAG;QAYR,IAAI,CAAC,eAAe,GAAG;IACzB;;AAhBF,QAAA,6BAAA,GAAA"}},
    {"offset": {"line": 1956, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1960, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/srv_polling.ts"],"sourcesContent":["import * as dns from 'dns';\nimport { clearTimeout, setTimeout } from 'timers';\n\nimport { MongoRuntimeError } from '../error';\nimport { TypedEventEmitter } from '../mongo_types';\nimport { checkParentDomainMatch, HostAddress, noop, squashError } from '../utils';\n\n/**\n * @internal\n * @category Event\n */\nexport class SrvPollingEvent {\n  srvRecords: dns.SrvRecord[];\n  constructor(srvRecords: dns.SrvRecord[]) {\n    this.srvRecords = srvRecords;\n  }\n\n  hostnames(): Set<string> {\n    return new Set(this.srvRecords.map(r => HostAddress.fromSrvRecord(r).toString()));\n  }\n}\n\n/** @internal */\nexport interface SrvPollerOptions {\n  srvServiceName: string;\n  srvMaxHosts: number;\n  srvHost: string;\n  heartbeatFrequencyMS: number;\n}\n\n/** @internal */\nexport type SrvPollerEvents = {\n  srvRecordDiscovery(event: SrvPollingEvent): void;\n};\n\n/** @internal */\nexport class SrvPoller extends TypedEventEmitter<SrvPollerEvents> {\n  srvHost: string;\n  rescanSrvIntervalMS: number;\n  heartbeatFrequencyMS: number;\n  haMode: boolean;\n  generation: number;\n  srvMaxHosts: number;\n  srvServiceName: string;\n  _timeout?: NodeJS.Timeout;\n\n  /** @event */\n  static readonly SRV_RECORD_DISCOVERY = 'srvRecordDiscovery' as const;\n\n  constructor(options: SrvPollerOptions) {\n    super();\n    this.on('error', noop);\n\n    if (!options || !options.srvHost) {\n      throw new MongoRuntimeError('Options for SrvPoller must exist and include srvHost');\n    }\n\n    this.srvHost = options.srvHost;\n    this.srvMaxHosts = options.srvMaxHosts ?? 0;\n    this.srvServiceName = options.srvServiceName ?? 'mongodb';\n    this.rescanSrvIntervalMS = 60000;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 10000;\n\n    this.haMode = false;\n    this.generation = 0;\n\n    this._timeout = undefined;\n  }\n\n  get srvAddress(): string {\n    return `_${this.srvServiceName}._tcp.${this.srvHost}`;\n  }\n\n  get intervalMS(): number {\n    return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;\n  }\n\n  start(): void {\n    if (!this._timeout) {\n      this.schedule();\n    }\n  }\n\n  stop(): void {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this.generation += 1;\n      this._timeout = undefined;\n    }\n  }\n\n  // TODO(NODE-4994): implement new logging logic for SrvPoller failures\n  schedule(): void {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    this._timeout = setTimeout(() => {\n      this._poll().then(undefined, squashError);\n    }, this.intervalMS);\n  }\n\n  success(srvRecords: dns.SrvRecord[]): void {\n    this.haMode = false;\n    this.schedule();\n    this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));\n  }\n\n  failure(): void {\n    this.haMode = true;\n    this.schedule();\n  }\n\n  async _poll(): Promise<void> {\n    const generation = this.generation;\n    let srvRecords;\n\n    try {\n      srvRecords = await dns.promises.resolveSrv(this.srvAddress);\n    } catch {\n      this.failure();\n      return;\n    }\n\n    if (generation !== this.generation) {\n      return;\n    }\n\n    const finalAddresses: dns.SrvRecord[] = [];\n    for (const record of srvRecords) {\n      try {\n        checkParentDomainMatch(record.name, this.srvHost);\n        finalAddresses.push(record);\n      } catch (error) {\n        squashError(error);\n      }\n    }\n\n    if (!finalAddresses.length) {\n      this.failure();\n      return;\n    }\n\n    this.success(finalAddresses);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2064, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2068, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mongodb/src/sdam/topology.ts"],"sourcesContent":["import type { BSONSerializeOptions, Document } from '../bson';\nimport type { MongoCredentials } from '../cmap/auth/mongo_credentials';\nimport type { ConnectionEvents } from '../cmap/connection';\nimport type { ConnectionPoolEvents } from '../cmap/connection_pool';\nimport type { ClientMetadata } from '../cmap/handshake/client_metadata';\nimport { DEFAULT_OPTIONS } from '../connection_string';\nimport {\n  CLOSE,\n  CONNECT,\n  ERROR,\n  LOCAL_SERVER_EVENTS,\n  OPEN,\n  SERVER_CLOSED,\n  SERVER_DESCRIPTION_CHANGED,\n  SERVER_OPENING,\n  SERVER_RELAY_EVENTS,\n  TIMEOUT,\n  TOPOLOGY_CLOSED,\n  TOPOLOGY_DESCRIPTION_CHANGED,\n  TOPOLOGY_OPENING\n} from '../constants';\nimport {\n  MongoCompatibilityError,\n  type MongoDriverError,\n  MongoError,\n  MongoErrorLabel,\n  MongoOperationTimeoutError,\n  MongoRuntimeError,\n  MongoServerSelectionError,\n  MongoTopologyClosedError\n} from '../error';\nimport type { MongoClient, ServerApi } from '../mongo_client';\nimport { MongoLoggableComponent, type MongoLogger, SeverityLevel } from '../mongo_logger';\nimport { type Abortable, TypedEventEmitter } from '../mongo_types';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport type { ClientSession } from '../sessions';\nimport { Timeout, TimeoutContext, TimeoutError } from '../timeout';\nimport type { Transaction } from '../transactions';\nimport {\n  addAbortListener,\n  type Callback,\n  type EventEmitterWithState,\n  HostAddress,\n  kDispose,\n  List,\n  makeStateMachine,\n  noop,\n  now,\n  ns,\n  promiseWithResolvers,\n  shuffle\n} from '../utils';\nimport {\n  _advanceClusterTime,\n  type ClusterTime,\n  ServerType,\n  STATE_CLOSED,\n  STATE_CLOSING,\n  STATE_CONNECTED,\n  STATE_CONNECTING,\n  TopologyType\n} from './common';\nimport {\n  ServerClosedEvent,\n  ServerDescriptionChangedEvent,\n  ServerOpeningEvent,\n  TopologyClosedEvent,\n  TopologyDescriptionChangedEvent,\n  TopologyOpeningEvent\n} from './events';\nimport type { ServerMonitoringMode } from './monitor';\nimport { Server, type ServerEvents, type ServerOptions } from './server';\nimport { compareTopologyVersion, ServerDescription } from './server_description';\nimport { readPreferenceServerSelector, type ServerSelector } from './server_selection';\nimport {\n  ServerSelectionFailedEvent,\n  ServerSelectionStartedEvent,\n  ServerSelectionSucceededEvent,\n  WaitingForSuitableServerEvent\n} from './server_selection_events';\nimport { SrvPoller, type SrvPollingEvent } from './srv_polling';\nimport { TopologyDescription } from './topology_description';\n\n// Global state\nlet globalTopologyCounter = 0;\n\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\n\n/** @internal */\nexport type ServerSelectionCallback = Callback<Server>;\n\n/** @internal */\nexport interface ServerSelectionRequest {\n  serverSelector: ServerSelector;\n  topologyDescription: TopologyDescription;\n  mongoLogger: MongoLogger | undefined;\n  transaction?: Transaction;\n  startTime: number;\n  resolve: (server: Server) => void;\n  reject: (error: MongoError) => void;\n  cancelled: boolean;\n  operationName: string;\n  waitingLogged: boolean;\n  previousServer?: ServerDescription;\n}\n\n/** @internal */\nexport interface TopologyPrivate {\n  /** the id of this topology */\n  id: number;\n  /** passed in options */\n  options: TopologyOptions;\n  /** initial seedlist of servers to connect to */\n  seedlist: HostAddress[];\n  /** initial state */\n  state: string;\n  /** the topology description */\n  description: TopologyDescription;\n  serverSelectionTimeoutMS: number;\n  heartbeatFrequencyMS: number;\n  minHeartbeatFrequencyMS: number;\n  /** A map of server instances to normalized addresses */\n  servers: Map<string, Server>;\n  credentials?: MongoCredentials;\n  clusterTime?: ClusterTime;\n\n  /** related to srv polling */\n  srvPoller?: SrvPoller;\n  detectShardedTopology: (event: TopologyDescriptionChangedEvent) => void;\n  detectSrvRecords: (event: SrvPollingEvent) => void;\n}\n\n/** @internal */\nexport interface TopologyOptions extends BSONSerializeOptions, ServerOptions {\n  srvMaxHosts: number;\n  srvServiceName: string;\n  hosts: HostAddress[];\n  retryWrites: boolean;\n  retryReads: boolean;\n  /** How long to block for server selection before throwing an error */\n  serverSelectionTimeoutMS: number;\n  /** The name of the replica set to connect to */\n  replicaSet?: string;\n  srvHost?: string;\n  srvPoller?: SrvPoller;\n  /** Indicates that a client should directly connect to a node without attempting to discover its topology type */\n  directConnection: boolean;\n  loadBalanced: boolean;\n  metadata: ClientMetadata;\n  extendedMetadata: Promise<Document>;\n  serverMonitoringMode: ServerMonitoringMode;\n  /** MongoDB server API version */\n  serverApi?: ServerApi;\n  __skipPingOnConnect?: boolean;\n}\n\n/** @public */\nexport interface ConnectOptions {\n  readPreference?: ReadPreference;\n}\n\n/** @public */\nexport interface SelectServerOptions {\n  readPreference?: ReadPreferenceLike;\n  /** How long to block for server selection before throwing an error */\n  serverSelectionTimeoutMS?: number;\n  session?: ClientSession;\n  operationName: string;\n  previousServer?: ServerDescription;\n  /**\n   * @internal\n   * TODO(NODE-6496): Make this required by making ChangeStream use LegacyTimeoutContext\n   * */\n  timeoutContext?: TimeoutContext;\n}\n\n/** @public */\nexport type TopologyEvents = {\n  /** Top level MongoClient doesn't emit this so it is marked: @internal */\n  connect(topology: Topology): void;\n  serverOpening(event: ServerOpeningEvent): void;\n  serverClosed(event: ServerClosedEvent): void;\n  serverDescriptionChanged(event: ServerDescriptionChangedEvent): void;\n  topologyClosed(event: TopologyClosedEvent): void;\n  topologyOpening(event: TopologyOpeningEvent): void;\n  topologyDescriptionChanged(event: TopologyDescriptionChangedEvent): void;\n  error(error: Error): void;\n  /** @internal */\n  open(topology: Topology): void;\n  close(): void;\n  timeout(): void;\n} & Omit<ServerEvents, 'connect'> &\n  ConnectionPoolEvents &\n  ConnectionEvents &\n  EventEmitterWithState;\n/**\n * A container of server instances representing a connection to a MongoDB topology.\n * @internal\n */\nexport class Topology extends TypedEventEmitter<TopologyEvents> {\n  /** @internal */\n  s: TopologyPrivate;\n  /** @internal */\n  waitQueue: List<ServerSelectionRequest>;\n  /** @internal */\n  hello?: Document;\n  /** @internal */\n  _type?: string;\n\n  client!: MongoClient;\n\n  /** @internal */\n  private connectionLock?: Promise<Topology>;\n\n  /** @event */\n  static readonly SERVER_OPENING = SERVER_OPENING;\n  /** @event */\n  static readonly SERVER_CLOSED = SERVER_CLOSED;\n  /** @event */\n  static readonly SERVER_DESCRIPTION_CHANGED = SERVER_DESCRIPTION_CHANGED;\n  /** @event */\n  static readonly TOPOLOGY_OPENING = TOPOLOGY_OPENING;\n  /** @event */\n  static readonly TOPOLOGY_CLOSED = TOPOLOGY_CLOSED;\n  /** @event */\n  static readonly TOPOLOGY_DESCRIPTION_CHANGED = TOPOLOGY_DESCRIPTION_CHANGED;\n  /** @event */\n  static readonly ERROR = ERROR;\n  /** @event */\n  static readonly OPEN = OPEN;\n  /** @event */\n  static readonly CONNECT = CONNECT;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly TIMEOUT = TIMEOUT;\n\n  /**\n   * @param seedlist - a list of HostAddress instances to connect to\n   */\n  constructor(\n    client: MongoClient,\n    seeds: string | string[] | HostAddress | HostAddress[],\n    options: TopologyOptions\n  ) {\n    super();\n    this.on('error', noop);\n\n    this.client = client;\n    // Options should only be undefined in tests, MongoClient will always have defined options\n    options = options ?? {\n      hosts: [HostAddress.fromString('localhost:27017')],\n      ...Object.fromEntries(DEFAULT_OPTIONS.entries())\n    };\n\n    if (typeof seeds === 'string') {\n      seeds = [HostAddress.fromString(seeds)];\n    } else if (!Array.isArray(seeds)) {\n      seeds = [seeds];\n    }\n\n    const seedlist: HostAddress[] = [];\n    for (const seed of seeds) {\n      if (typeof seed === 'string') {\n        seedlist.push(HostAddress.fromString(seed));\n      } else if (seed instanceof HostAddress) {\n        seedlist.push(seed);\n      } else {\n        // FIXME(NODE-3483): May need to be a MongoParseError\n        throw new MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);\n      }\n    }\n\n    const topologyType = topologyTypeFromOptions(options);\n    const topologyId = globalTopologyCounter++;\n\n    const selectedHosts =\n      options.srvMaxHosts == null ||\n      options.srvMaxHosts === 0 ||\n      options.srvMaxHosts >= seedlist.length\n        ? seedlist\n        : shuffle(seedlist, options.srvMaxHosts);\n\n    const serverDescriptions = new Map();\n    for (const hostAddress of selectedHosts) {\n      serverDescriptions.set(hostAddress.toString(), new ServerDescription(hostAddress));\n    }\n\n    this.waitQueue = new List();\n    this.s = {\n      // the id of this topology\n      id: topologyId,\n      // passed in options\n      options,\n      // initial seedlist of servers to connect to\n      seedlist,\n      // initial state\n      state: STATE_CLOSED,\n      // the topology description\n      description: new TopologyDescription(\n        topologyType,\n        serverDescriptions,\n        options.replicaSet,\n        undefined,\n        undefined,\n        undefined,\n        options\n      ),\n      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,\n      // a map of server instances to normalized addresses\n      servers: new Map(),\n      credentials: options?.credentials,\n      clusterTime: undefined,\n\n      detectShardedTopology: ev => this.detectShardedTopology(ev),\n      detectSrvRecords: ev => this.detectSrvRecords(ev)\n    };\n\n    this.mongoLogger = client.mongoLogger;\n    this.component = 'topology';\n\n    if (options.srvHost && !options.loadBalanced) {\n      this.s.srvPoller =\n        options.srvPoller ??\n        new SrvPoller({\n          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,\n          srvHost: options.srvHost,\n          srvMaxHosts: options.srvMaxHosts,\n          srvServiceName: options.srvServiceName\n        });\n\n      this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);\n    }\n    this.connectionLock = undefined;\n  }\n\n  private detectShardedTopology(event: TopologyDescriptionChangedEvent) {\n    const previousType = event.previousDescription.type;\n    const newType = event.newDescription.type;\n\n    const transitionToSharded =\n      previousType !== TopologyType.Sharded && newType === TopologyType.Sharded;\n    const srvListeners = this.s.srvPoller?.listeners(SrvPoller.SRV_RECORD_DISCOVERY);\n    const listeningToSrvPolling = !!srvListeners?.includes(this.s.detectSrvRecords);\n\n    if (transitionToSharded && !listeningToSrvPolling) {\n      this.s.srvPoller?.on(SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);\n      this.s.srvPoller?.start();\n    }\n  }\n\n  private detectSrvRecords(ev: SrvPollingEvent) {\n    const previousTopologyDescription = this.s.description;\n    this.s.description = this.s.description.updateFromSrvPollingEvent(\n      ev,\n      this.s.options.srvMaxHosts\n    );\n    if (this.s.description === previousTopologyDescription) {\n      // Nothing changed, so return\n      return;\n    }\n\n    updateServers(this);\n\n    this.emitAndLog(\n      Topology.TOPOLOGY_DESCRIPTION_CHANGED,\n      new TopologyDescriptionChangedEvent(\n        this.s.id,\n        previousTopologyDescription,\n        this.s.description\n      )\n    );\n  }\n\n  /**\n   * @returns A `TopologyDescription` for this topology\n   */\n  get description(): TopologyDescription {\n    return this.s.description;\n  }\n\n  get loadBalanced(): boolean {\n    return this.s.options.loadBalanced;\n  }\n\n  get serverApi(): ServerApi | undefined {\n    return this.s.options.serverApi;\n  }\n\n  get capabilities(): ServerCapabilities {\n    return new ServerCapabilities(this.lastHello());\n  }\n\n  /** Initiate server connect */\n  async connect(options?: ConnectOptions): Promise<Topology> {\n    this.connectionLock ??= this._connect(options);\n    try {\n      await this.connectionLock;\n      return this;\n    } finally {\n      this.connectionLock = undefined;\n    }\n  }\n\n  private async _connect(options?: ConnectOptions): Promise<Topology> {\n    options = options ?? {};\n    if (this.s.state === STATE_CONNECTED) {\n      return this;\n    }\n\n    stateTransition(this, STATE_CONNECTING);\n\n    // emit SDAM monitoring events\n    this.emitAndLog(Topology.TOPOLOGY_OPENING, new TopologyOpeningEvent(this.s.id));\n\n    // emit an event for the topology change\n    this.emitAndLog(\n      Topology.TOPOLOGY_DESCRIPTION_CHANGED,\n      new TopologyDescriptionChangedEvent(\n        this.s.id,\n        new TopologyDescription(TopologyType.Unknown), // initial is always Unknown\n        this.s.description\n      )\n    );\n\n    // connect all known servers, then attempt server selection to connect\n    const serverDescriptions = Array.from(this.s.description.servers.values());\n    this.s.servers = new Map(\n      serverDescriptions.map(serverDescription => [\n        serverDescription.address,\n        createAndConnectServer(this, serverDescription)\n      ])\n    );\n\n    // In load balancer mode we need to fake a server description getting\n    // emitted from the monitor, since the monitor doesn't exist.\n    if (this.s.options.loadBalanced) {\n      for (const description of serverDescriptions) {\n        const newDescription = new ServerDescription(description.hostAddress, undefined, {\n          loadBalanced: this.s.options.loadBalanced\n        });\n        this.serverUpdateHandler(newDescription);\n      }\n    }\n\n    const serverSelectionTimeoutMS = this.client.s.options.serverSelectionTimeoutMS;\n    const readPreference = options.readPreference ?? ReadPreference.primary;\n    const timeoutContext = TimeoutContext.create({\n      // TODO(NODE-6448): auto-connect ignores timeoutMS; potential future feature\n      timeoutMS: undefined,\n      serverSelectionTimeoutMS,\n      waitQueueTimeoutMS: this.client.s.options.waitQueueTimeoutMS\n    });\n    const selectServerOptions = {\n      operationName: 'ping',\n      ...options,\n      timeoutContext\n    };\n\n    try {\n      const server = await this.selectServer(\n        readPreferenceServerSelector(readPreference),\n        selectServerOptions\n      );\n      const skipPingOnConnect = this.s.options.__skipPingOnConnect === true;\n      if (!skipPingOnConnect && this.s.credentials) {\n        await server.command(ns('admin.$cmd'), { ping: 1 }, { timeoutContext });\n        stateTransition(this, STATE_CONNECTED);\n        this.emit(Topology.OPEN, this);\n        this.emit(Topology.CONNECT, this);\n\n        return this;\n      }\n\n      stateTransition(this, STATE_CONNECTED);\n      this.emit(Topology.OPEN, this);\n      this.emit(Topology.CONNECT, this);\n\n      return this;\n    } catch (error) {\n      this.close();\n      throw error;\n    }\n  }\n\n  closeCheckedOutConnections() {\n    for (const server of this.s.servers.values()) {\n      return server.closeCheckedOutConnections();\n    }\n  }\n\n  /** Close this topology */\n  close(): void {\n    if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {\n      return;\n    }\n\n    for (const server of this.s.servers.values()) {\n      closeServer(server, this);\n    }\n\n    this.s.servers.clear();\n\n    stateTransition(this, STATE_CLOSING);\n\n    drainWaitQueue(this.waitQueue, new MongoTopologyClosedError());\n\n    if (this.s.srvPoller) {\n      this.s.srvPoller.stop();\n      this.s.srvPoller.removeListener(SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);\n    }\n\n    this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);\n\n    stateTransition(this, STATE_CLOSED);\n\n    // emit an event for close\n    this.emitAndLog(Topology.TOPOLOGY_CLOSED, new TopologyClosedEvent(this.s.id));\n  }\n\n  /**\n   * Selects a server according to the selection predicate provided\n   *\n   * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window\n   * @param options - Optional settings related to server selection\n   * @param callback - The callback used to indicate success or failure\n   * @returns An instance of a `Server` meeting the criteria of the predicate provided\n   */\n  async selectServer(\n    selector: string | ReadPreference | ServerSelector,\n    options: SelectServerOptions & Abortable\n  ): Promise<Server> {\n    let serverSelector;\n    if (typeof selector !== 'function') {\n      if (typeof selector === 'string') {\n        serverSelector = readPreferenceServerSelector(ReadPreference.fromString(selector));\n      } else {\n        let readPreference;\n        if (selector instanceof ReadPreference) {\n          readPreference = selector;\n        } else {\n          ReadPreference.translate(options);\n          readPreference = options.readPreference || ReadPreference.primary;\n        }\n\n        serverSelector = readPreferenceServerSelector(readPreference as ReadPreference);\n      }\n    } else {\n      serverSelector = selector;\n    }\n\n    options = { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS, ...options };\n    if (\n      this.client.mongoLogger?.willLog(MongoLoggableComponent.SERVER_SELECTION, SeverityLevel.DEBUG)\n    ) {\n      this.client.mongoLogger?.debug(\n        MongoLoggableComponent.SERVER_SELECTION,\n        new ServerSelectionStartedEvent(selector, this.description, options.operationName)\n      );\n    }\n    let timeout;\n    if (options.timeoutContext) timeout = options.timeoutContext.serverSelectionTimeout;\n    else {\n      timeout = Timeout.expires(options.serverSelectionTimeoutMS ?? 0);\n    }\n\n    const isSharded = this.description.type === TopologyType.Sharded;\n    const session = options.session;\n    const transaction = session && session.transaction;\n\n    if (isSharded && transaction && transaction.server) {\n      if (\n        this.client.mongoLogger?.willLog(\n          MongoLoggableComponent.SERVER_SELECTION,\n          SeverityLevel.DEBUG\n        )\n      ) {\n        this.client.mongoLogger?.debug(\n          MongoLoggableComponent.SERVER_SELECTION,\n          new ServerSelectionSucceededEvent(\n            selector,\n            this.description,\n            transaction.server.pool.address,\n            options.operationName\n          )\n        );\n      }\n      if (options.timeoutContext?.clearServerSelectionTimeout) timeout?.clear();\n      return transaction.server;\n    }\n\n    const { promise: serverPromise, resolve, reject } = promiseWithResolvers<Server>();\n\n    const waitQueueMember: ServerSelectionRequest = {\n      serverSelector,\n      topologyDescription: this.description,\n      mongoLogger: this.client.mongoLogger,\n      transaction,\n      resolve,\n      reject,\n      cancelled: false,\n      startTime: now(),\n      operationName: options.operationName,\n      waitingLogged: false,\n      previousServer: options.previousServer\n    };\n\n    const abortListener = addAbortListener(options.signal, function () {\n      waitQueueMember.cancelled = true;\n      reject(this.reason);\n    });\n\n    this.waitQueue.push(waitQueueMember);\n    processWaitQueue(this);\n\n    try {\n      timeout?.throwIfExpired();\n      const server = await (timeout ? Promise.race([serverPromise, timeout]) : serverPromise);\n      if (options.timeoutContext?.csotEnabled() && server.description.minRoundTripTime !== 0) {\n        options.timeoutContext.minRoundTripTime = server.description.minRoundTripTime;\n      }\n      return server;\n    } catch (error) {\n      if (TimeoutError.is(error)) {\n        // Timeout\n        waitQueueMember.cancelled = true;\n        const timeoutError = new MongoServerSelectionError(\n          `Server selection timed out after ${timeout?.duration} ms`,\n          this.description\n        );\n        if (\n          this.client.mongoLogger?.willLog(\n            MongoLoggableComponent.SERVER_SELECTION,\n            SeverityLevel.DEBUG\n          )\n        ) {\n          this.client.mongoLogger?.debug(\n            MongoLoggableComponent.SERVER_SELECTION,\n            new ServerSelectionFailedEvent(\n              selector,\n              this.description,\n              timeoutError,\n              options.operationName\n            )\n          );\n        }\n\n        if (options.timeoutContext?.csotEnabled()) {\n          throw new MongoOperationTimeoutError('Timed out during server selection', {\n            cause: timeoutError\n          });\n        }\n        throw timeoutError;\n      }\n      // Other server selection error\n      throw error;\n    } finally {\n      abortListener?.[kDispose]();\n      if (options.timeoutContext?.clearServerSelectionTimeout) timeout?.clear();\n    }\n  }\n  /**\n   * Update the internal TopologyDescription with a ServerDescription\n   *\n   * @param serverDescription - The server to update in the internal list of server descriptions\n   */\n  serverUpdateHandler(serverDescription: ServerDescription): void {\n    if (!this.s.description.hasServer(serverDescription.address)) {\n      return;\n    }\n\n    // ignore this server update if its from an outdated topologyVersion\n    if (isStaleServerDescription(this.s.description, serverDescription)) {\n      return;\n    }\n\n    // these will be used for monitoring events later\n    const previousTopologyDescription = this.s.description;\n    const previousServerDescription = this.s.description.servers.get(serverDescription.address);\n    if (!previousServerDescription) {\n      return;\n    }\n\n    // Driver Sessions Spec: \"Whenever a driver receives a cluster time from\n    // a server it MUST compare it to the current highest seen cluster time\n    // for the deployment. If the new cluster time is higher than the\n    // highest seen cluster time it MUST become the new highest seen cluster\n    // time. Two cluster times are compared using only the BsonTimestamp\n    // value of the clusterTime embedded field.\"\n    const clusterTime = serverDescription.$clusterTime;\n    if (clusterTime) {\n      _advanceClusterTime(this, clusterTime);\n    }\n\n    // If we already know all the information contained in this updated description, then\n    // we don't need to emit SDAM events, but still need to update the description, in order\n    // to keep client-tracked attributes like last update time and round trip time up to date\n    const equalDescriptions =\n      previousServerDescription && previousServerDescription.equals(serverDescription);\n\n    // first update the TopologyDescription\n    this.s.description = this.s.description.update(serverDescription);\n    if (this.s.description.compatibilityError) {\n      this.emit(Topology.ERROR, new MongoCompatibilityError(this.s.description.compatibilityError));\n      return;\n    }\n\n    // emit monitoring events for this change\n    if (!equalDescriptions) {\n      const newDescription = this.s.description.servers.get(serverDescription.address);\n      if (newDescription) {\n        this.emit(\n          Topology.SERVER_DESCRIPTION_CHANGED,\n          new ServerDescriptionChangedEvent(\n            this.s.id,\n            serverDescription.address,\n            previousServerDescription,\n            newDescription\n          )\n        );\n      }\n    }\n\n    // update server list from updated descriptions\n    updateServers(this, serverDescription);\n\n    // attempt to resolve any outstanding server selection attempts\n    if (this.waitQueue.length > 0) {\n      processWaitQueue(this);\n    }\n\n    if (!equalDescriptions) {\n      this.emitAndLog(\n        Topology.TOPOLOGY_DESCRIPTION_CHANGED,\n        new TopologyDescriptionChangedEvent(\n          this.s.id,\n          previousTopologyDescription,\n          this.s.description\n        )\n      );\n    }\n  }\n\n  auth(credentials?: MongoCredentials, callback?: Callback): void {\n    if (typeof credentials === 'function') (callback = credentials), (credentials = undefined);\n    if (typeof callback === 'function') callback(undefined, true);\n  }\n\n  get clientMetadata(): ClientMetadata {\n    return this.s.options.metadata;\n  }\n\n  isConnected(): boolean {\n    return this.s.state === STATE_CONNECTED;\n  }\n\n  isDestroyed(): boolean {\n    return this.s.state === STATE_CLOSED;\n  }\n\n  // NOTE: There are many places in code where we explicitly check the last hello\n  //       to do feature support detection. This should be done any other way, but for\n  //       now we will just return the first hello seen, which should suffice.\n  lastHello(): Document {\n    const serverDescriptions = Array.from(this.description.servers.values());\n    if (serverDescriptions.length === 0) return {};\n    const sd = serverDescriptions.filter(\n      (sd: ServerDescription) => sd.type !== ServerType.Unknown\n    )[0];\n\n    const result = sd || { maxWireVersion: this.description.commonWireVersion };\n    return result;\n  }\n\n  get commonWireVersion(): number | undefined {\n    return this.description.commonWireVersion;\n  }\n\n  get logicalSessionTimeoutMinutes(): number | null {\n    return this.description.logicalSessionTimeoutMinutes;\n  }\n\n  get clusterTime(): ClusterTime | undefined {\n    return this.s.clusterTime;\n  }\n\n  set clusterTime(clusterTime: ClusterTime | undefined) {\n    this.s.clusterTime = clusterTime;\n  }\n}\n\n/** Destroys a server, and removes all event listeners from the instance */\nfunction closeServer(server: Server, topology: Topology) {\n  for (const event of LOCAL_SERVER_EVENTS) {\n    server.removeAllListeners(event);\n  }\n\n  server.close();\n  topology.emitAndLog(\n    Topology.SERVER_CLOSED,\n    new ServerClosedEvent(topology.s.id, server.description.address)\n  );\n\n  for (const event of SERVER_RELAY_EVENTS) {\n    server.removeAllListeners(event);\n  }\n}\n\n/** Predicts the TopologyType from options */\nfunction topologyTypeFromOptions(options?: TopologyOptions) {\n  if (options?.directConnection) {\n    return TopologyType.Single;\n  }\n\n  if (options?.replicaSet) {\n    return TopologyType.ReplicaSetNoPrimary;\n  }\n\n  if (options?.loadBalanced) {\n    return TopologyType.LoadBalanced;\n  }\n\n  return TopologyType.Unknown;\n}\n\n/**\n * Creates new server instances and attempts to connect them\n *\n * @param topology - The topology that this server belongs to\n * @param serverDescription - The description for the server to initialize and connect to\n */\nfunction createAndConnectServer(topology: Topology, serverDescription: ServerDescription) {\n  topology.emitAndLog(\n    Topology.SERVER_OPENING,\n    new ServerOpeningEvent(topology.s.id, serverDescription.address)\n  );\n\n  const server = new Server(topology, serverDescription, topology.s.options);\n  for (const event of SERVER_RELAY_EVENTS) {\n    server.on(event, (e: any) => topology.emit(event, e));\n  }\n\n  server.on(Server.DESCRIPTION_RECEIVED, description => topology.serverUpdateHandler(description));\n\n  server.connect();\n  return server;\n}\n\n/**\n * @param topology - Topology to update.\n * @param incomingServerDescription - New server description.\n */\nfunction updateServers(topology: Topology, incomingServerDescription?: ServerDescription) {\n  // update the internal server's description\n  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {\n    const server = topology.s.servers.get(incomingServerDescription.address);\n    if (server) {\n      server.s.description = incomingServerDescription;\n      if (\n        incomingServerDescription.error instanceof MongoError &&\n        incomingServerDescription.error.hasErrorLabel(MongoErrorLabel.ResetPool)\n      ) {\n        const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(\n          MongoErrorLabel.InterruptInUseConnections\n        );\n\n        server.pool.clear({ interruptInUseConnections });\n      } else if (incomingServerDescription.error == null) {\n        const newTopologyType = topology.s.description.type;\n        const shouldMarkPoolReady =\n          incomingServerDescription.isDataBearing ||\n          (incomingServerDescription.type !== ServerType.Unknown &&\n            newTopologyType === TopologyType.Single);\n        if (shouldMarkPoolReady) {\n          server.pool.ready();\n        }\n      }\n    }\n  }\n\n  // add new servers for all descriptions we currently don't know about locally\n  for (const serverDescription of topology.description.servers.values()) {\n    if (!topology.s.servers.has(serverDescription.address)) {\n      const server = createAndConnectServer(topology, serverDescription);\n      topology.s.servers.set(serverDescription.address, server);\n    }\n  }\n\n  // for all servers no longer known, remove their descriptions and destroy their instances\n  for (const entry of topology.s.servers) {\n    const serverAddress = entry[0];\n    if (topology.description.hasServer(serverAddress)) {\n      continue;\n    }\n\n    if (!topology.s.servers.has(serverAddress)) {\n      continue;\n    }\n\n    const server = topology.s.servers.get(serverAddress);\n    topology.s.servers.delete(serverAddress);\n\n    // prepare server for garbage collection\n    if (server) {\n      closeServer(server, topology);\n    }\n  }\n}\n\nfunction drainWaitQueue(queue: List<ServerSelectionRequest>, drainError: MongoDriverError) {\n  while (queue.length) {\n    const waitQueueMember = queue.shift();\n    if (!waitQueueMember) {\n      continue;\n    }\n\n    if (!waitQueueMember.cancelled) {\n      if (\n        waitQueueMember.mongoLogger?.willLog(\n          MongoLoggableComponent.SERVER_SELECTION,\n          SeverityLevel.DEBUG\n        )\n      ) {\n        waitQueueMember.mongoLogger?.debug(\n          MongoLoggableComponent.SERVER_SELECTION,\n          new ServerSelectionFailedEvent(\n            waitQueueMember.serverSelector,\n            waitQueueMember.topologyDescription,\n            drainError,\n            waitQueueMember.operationName\n          )\n        );\n      }\n      waitQueueMember.reject(drainError);\n    }\n  }\n}\n\nfunction processWaitQueue(topology: Topology) {\n  if (topology.s.state === STATE_CLOSED) {\n    drainWaitQueue(topology.waitQueue, new MongoTopologyClosedError());\n    return;\n  }\n\n  const isSharded = topology.description.type === TopologyType.Sharded;\n  const serverDescriptions = Array.from(topology.description.servers.values());\n  const membersToProcess = topology.waitQueue.length;\n  for (let i = 0; i < membersToProcess; ++i) {\n    const waitQueueMember = topology.waitQueue.shift();\n    if (!waitQueueMember) {\n      continue;\n    }\n\n    if (waitQueueMember.cancelled) {\n      continue;\n    }\n\n    let selectedDescriptions;\n    try {\n      const serverSelector = waitQueueMember.serverSelector;\n      const previousServer = waitQueueMember.previousServer;\n      selectedDescriptions = serverSelector\n        ? serverSelector(\n            topology.description,\n            serverDescriptions,\n            previousServer ? [previousServer] : []\n          )\n        : serverDescriptions;\n    } catch (selectorError) {\n      if (\n        topology.client.mongoLogger?.willLog(\n          MongoLoggableComponent.SERVER_SELECTION,\n          SeverityLevel.DEBUG\n        )\n      ) {\n        topology.client.mongoLogger?.debug(\n          MongoLoggableComponent.SERVER_SELECTION,\n          new ServerSelectionFailedEvent(\n            waitQueueMember.serverSelector,\n            topology.description,\n            selectorError,\n            waitQueueMember.operationName\n          )\n        );\n      }\n      waitQueueMember.reject(selectorError);\n      continue;\n    }\n\n    let selectedServer: Server | undefined;\n    if (selectedDescriptions.length === 0) {\n      if (!waitQueueMember.waitingLogged) {\n        if (\n          topology.client.mongoLogger?.willLog(\n            MongoLoggableComponent.SERVER_SELECTION,\n            SeverityLevel.INFORMATIONAL\n          )\n        ) {\n          topology.client.mongoLogger?.info(\n            MongoLoggableComponent.SERVER_SELECTION,\n            new WaitingForSuitableServerEvent(\n              waitQueueMember.serverSelector,\n              topology.description,\n              topology.s.serverSelectionTimeoutMS !== 0\n                ? topology.s.serverSelectionTimeoutMS - (now() - waitQueueMember.startTime)\n                : -1,\n              waitQueueMember.operationName\n            )\n          );\n        }\n        waitQueueMember.waitingLogged = true;\n      }\n      topology.waitQueue.push(waitQueueMember);\n      continue;\n    } else if (selectedDescriptions.length === 1) {\n      selectedServer = topology.s.servers.get(selectedDescriptions[0].address);\n    } else {\n      const descriptions = shuffle(selectedDescriptions, 2);\n      const server1 = topology.s.servers.get(descriptions[0].address);\n      const server2 = topology.s.servers.get(descriptions[1].address);\n\n      selectedServer =\n        server1 && server2 && server1.s.operationCount < server2.s.operationCount\n          ? server1\n          : server2;\n    }\n\n    if (!selectedServer) {\n      const serverSelectionError = new MongoServerSelectionError(\n        'server selection returned a server description but the server was not found in the topology',\n        topology.description\n      );\n      if (\n        topology.client.mongoLogger?.willLog(\n          MongoLoggableComponent.SERVER_SELECTION,\n          SeverityLevel.DEBUG\n        )\n      ) {\n        topology.client.mongoLogger?.debug(\n          MongoLoggableComponent.SERVER_SELECTION,\n          new ServerSelectionFailedEvent(\n            waitQueueMember.serverSelector,\n            topology.description,\n            serverSelectionError,\n            waitQueueMember.operationName\n          )\n        );\n      }\n      waitQueueMember.reject(serverSelectionError);\n      return;\n    }\n    const transaction = waitQueueMember.transaction;\n    if (isSharded && transaction && transaction.isActive && selectedServer) {\n      transaction.pinServer(selectedServer);\n    }\n\n    if (\n      topology.client.mongoLogger?.willLog(\n        MongoLoggableComponent.SERVER_SELECTION,\n        SeverityLevel.DEBUG\n      )\n    ) {\n      topology.client.mongoLogger?.debug(\n        MongoLoggableComponent.SERVER_SELECTION,\n        new ServerSelectionSucceededEvent(\n          waitQueueMember.serverSelector,\n          waitQueueMember.topologyDescription,\n          selectedServer.pool.address,\n          waitQueueMember.operationName\n        )\n      );\n    }\n    waitQueueMember.resolve(selectedServer);\n  }\n\n  if (topology.waitQueue.length > 0) {\n    // ensure all server monitors attempt monitoring soon\n    for (const [, server] of topology.s.servers) {\n      process.nextTick(function scheduleServerCheck() {\n        return server.requestCheck();\n      });\n    }\n  }\n}\n\nfunction isStaleServerDescription(\n  topologyDescription: TopologyDescription,\n  incomingServerDescription: ServerDescription\n) {\n  const currentServerDescription = topologyDescription.servers.get(\n    incomingServerDescription.address\n  );\n  const currentTopologyVersion = currentServerDescription?.topologyVersion;\n  return (\n    compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0\n  );\n}\n\n/** @public */\nexport class ServerCapabilities {\n  maxWireVersion: number;\n  minWireVersion: number;\n\n  constructor(hello: Document) {\n    this.minWireVersion = hello.minWireVersion || 0;\n    this.maxWireVersion = hello.maxWireVersion || 0;\n  }\n\n  get hasAggregationCursor(): boolean {\n    return this.maxWireVersion >= 1;\n  }\n\n  get hasWriteCommands(): boolean {\n    return this.maxWireVersion >= 2;\n  }\n  get hasTextSearch(): boolean {\n    return this.minWireVersion >= 0;\n  }\n\n  get hasAuthCommands(): boolean {\n    return this.maxWireVersion >= 1;\n  }\n\n  get hasListCollectionsCommand(): boolean {\n    return this.maxWireVersion >= 3;\n  }\n\n  get hasListIndexesCommand(): boolean {\n    return this.maxWireVersion >= 3;\n  }\n\n  get supportsSnapshotReads(): boolean {\n    return this.maxWireVersion >= 13;\n  }\n\n  get commandsTakeWriteConcern(): boolean {\n    return this.maxWireVersion >= 5;\n  }\n\n  get commandsTakeCollation(): boolean {\n    return this.maxWireVersion >= 5;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2736, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}